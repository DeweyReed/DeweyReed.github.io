<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Animated Vector Drawable搜集</title>
    <url>/2019/11/27/android-animated_vector_drawables/</url>
    <content><![CDATA[<p>各种会动的图标，性能好，免费用。随缘更新，找到了就丢在这里。</p>
<span id="more"></span>

<ul>
<li><p><a href="https://github.com/StylingAndroid/AnimatedIcons/">StylingAndroid/AnimatedIcons</a></p>
<p>  <a href="https://blog.stylingandroid.com/animatedicons-max-min/"><img src="https://blog.stylingandroid.com/wp-content/uploads/2019/10/MaxMin.gif" alt="AnimatedIcons: Max / Min"></a></p>
<p>  <a href="https://blog.stylingandroid.com/animatedicons-loading-v3/"><img src="https://blog.stylingandroid.com/wp-content/uploads/2019/10/LoadingV3.gif" alt="AnimatedIcons: Loading V3"></a></p>
<p>  <a href="https://blog.stylingandroid.com/animated-icons-plus-x/"><img src="https://blog.stylingandroid.com/wp-content/uploads/2019/10/PlusX.gif" alt="AnimatedIcons: Plus / X"></a></p>
<p>  <a href="https://blog.stylingandroid.com/animatedicons-strikethru/"><img src="https://blog.stylingandroid.com/wp-content/uploads/2019/08/Strikethru.gif" alt="AnimatedIcons: Strikethru"></a></p>
<p>  <a href="https://blog.stylingandroid.com/animatedicons-loading-v2/"><img src="https://blog.stylingandroid.com/wp-content/uploads/2019/08/Loading_V2.gif" alt="AnimatedIcons: Loading V2"></a></p>
<p>  <a href="https://blog.stylingandroid.com/animatedicons-search-x/"><img src="https://blog.stylingandroid.com/wp-content/uploads/2019/12/search_x-1.gif" alt="AnimatedIcons: Search / X"></a></p>
<p>  <a href="https://blog.stylingandroid.com/animated-icons-burger-menu/"><img src="https://blog.stylingandroid.com/wp-content/uploads/2020/01/BurgerMenu.gif" alt="Animated Icons: Burger Menu"></a></p>
</li>
<li><p><a href="https://github.com/alexjlockwood/adp-delightful-details"><img src="https://camo.githubusercontent.com/079cd7f1079153cd0489dc58bc0fa121b3ecb767/687474703a2f2f692e696d6775722e636f6d2f306146646a4a6e2e676966" alt="A lot of icons"></a></p>
</li>
<li><p><a href="https://github.com/tarek360/RichPath"><img src="https://github.com/tarek360/RichPath/raw/develop/screenshots/samples.gif" alt="tarek360/RichPath"></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android Animation</title>
    <url>/2018/12/11/android-animation/</url>
    <content><![CDATA[<p>整理自<a href="https://www.youtube.com/watch?v=N_x7SV3I3P0">Get Animated (Android Dev Summit ‘18)</a>，解释那复杂的Android动画框架和工具。</p>
<span id="more"></span>

<ol>
<li><p><code>android.view.animation</code>：过时的动画</p>
<p> 过时了，不好用了。包括创建在<code>R.anim.</code>中的资源（考虑使用<code>R.animator.</code>）。</p>
<p> 当且仅当处理Window Animation时或Fragment Transition的自定义动画需确保View已经measured不得不使用这个，</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowEnterAnimation&quot;</span>&gt;</span>@anim/foo<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>android.animation</code>：从API 11开始的Animator</p>
<p> 来自<code>R.animator.</code>的资源。</p>
<p> Animator =&gt; ValueAnimator =&gt; ObjectAnimator</p>
<ol>
<li><p>ValueAniamtor</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ValueAnimator.ofFloat(<span class="number">1f</span>, <span class="number">0f</span>).apply &#123;</span><br><span class="line">    addUpdateListener &#123; ... &#125;</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure></li>
<li><p>ObjectAniamtor</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, View.ALPHA, <span class="number">1f</span>, <span class="number">0f</span>).start()</span><br></pre></td></tr></table></figure>

<p> PropertyValueHolder是ValueAnimator的内部实现</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObjectAnimator.ofPropertyValueHolder(</span><br><span class="line">    view,</span><br><span class="line">    PropertyValueHolder.ofFloat(View.ALPHA, <span class="number">1f</span>, <span class="number">0f</span>),</span><br><span class="line">    PropertyValueHolder.ofFloat(View.SCALE_X, <span class="number">1f</span>, <span class="number">0f</span>)</span><br><span class="line">).start()</span><br></pre></td></tr></table></figure></li>
<li><p>AnimatorSet：属于Aniamtor，管理多个动画</p>
</li>
<li><p>ViewPropertyAnimator：使用了ValueAnimator，但效率更高</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.animate()....start()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Transitions：在布局间中切换</p>
<p> 用于Shared Element Transition、Window Content Transition、模块化动画。</p>
<p> <code>TransitionManager.beginDelayedTransition(viewGroup)</code></p>
<p> 调用后，修改View，自动启动动画。</p>
</li>
<li><p>AnimatedVectorDrawable: VectorDrawable + Animator</p>
<p> 用于Icon Animation、一次性动画、性能要求高的情况。</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> avd = AppCompatResources.getDrawable(context, R.drawable.avd) <span class="keyword">as</span> AnimatedVectorDrawable</span><br><span class="line">imageView.drawable = avd</span><br><span class="line">avd.start()</span><br></pre></td></tr></table></figure></li>
<li><p>Phycisc-based Animation：强交互时提供流畅体验</p>
</li>
<li><p>MotionLayout：饼，真香。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android AppCompat 1.1.0渐隐式切换夜间模式</title>
    <url>/2019/09/07/android-appcompt110-fading-dark/</url>
    <content><![CDATA[<p><strong>2020年5月7日更新，原方案有误，废弃，给我移步2020年5月的深色模式的新文章</strong></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android自动切换深色主题</title>
    <url>/2018/10/04/android-auto-night/</url>
    <content><![CDATA[<p><strong>2020年8月26日新方案，乖乖穷举</strong></p>
<p><strong>2020年6月1日我发现还有问题！</strong></p>
<p><strong>2020年5月22日新方案又来了，希望能结束这个问题</strong></p>
<p><strong>2020年4月21日还有Bug，正在修。反正也没人看，估计也没坑到什么人</strong></p>
<p><strong>2020年1月27日憋出了新方案，似乎修好了</strong></p>
<p><strong>2019年11月4日现在的实现有Bug，正在研究</strong></p>
<p><strong>2019年10月18日更新AppCompat 1.1.0的使用说明</strong></p>
<p><strong>2019年8月18日更新增强版</strong></p>
<p>网上搜怎么实现自动切换深色主题都没资料的，全是实现，只能自己想办法了。</p>
<p>最终解决的方案倒是很简单，不过走了<strong>很多、很多、很多、很多</strong>弯路。<del>脑子不是很好使了</del>我好菜啊。</p>
<span id="more"></span>

<p>已有数据：上一次的启动时间、本次的启动时间（就是现在）、自动启动深色模式的几点几分开始和几点几分结束。</p>
<p>举个例子，设置八点自动进入深色主题，九点退出深色主题，我们需要满足：1. 上一次启动是在今天八点前。2. 本次启动在今天八点后。3.本次启动在今天九点前。4. 现在是浅色主题。退出深色主题同理。</p>
<p>下述方案储存几点几分是把小时和分钟分开储存的，另外一种方案是只储存一个值：<code>60 * 小时 + 分钟</code>。</p>
<p>代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> True if we should revert the current dark.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculateAutoDarkChange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    currentIsDark: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    nowMilli: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    lastLaunchMilli: <span class="type">Long</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lastLaunch =</span><br><span class="line">        LocalDateTime.ofInstant(Instant.ofEpochMilli(lastLaunchMilli), ZoneId.systemDefault())</span><br><span class="line">    <span class="keyword">val</span> now = LocalDateTime.ofInstant(Instant.ofEpochMilli(nowMilli), ZoneId.systemDefault())</span><br><span class="line">    <span class="keyword">val</span> today = LocalDate.now()</span><br><span class="line">    <span class="keyword">val</span> nightRange = scheduleRange</span><br><span class="line">    <span class="keyword">val</span> nightStart =</span><br><span class="line">        LocalDateTime.of(today, LocalTime.of(nightRange.fromHour, nightRange.fromMinute))</span><br><span class="line">    <span class="keyword">val</span> nightEnd =</span><br><span class="line">        LocalDateTime.of(today, LocalTime.of(nightRange.toHour, nightRange.toMinute))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isEnteringTheSpanFirst</span><span class="params">(from: <span class="type">LocalDateTime</span>, to: <span class="type">LocalDateTime</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from == to) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        require(from.isBefore(to))</span><br><span class="line">        <span class="keyword">return</span> (now.isAfter(from) || now == from) &amp;&amp;</span><br><span class="line">            now.isBefore(to) &amp;&amp;</span><br><span class="line">            lastLaunch.isBefore(from)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isEnteringNight</span><span class="params">(nightStart: <span class="type">LocalDateTime</span>, nightEnd: <span class="type">LocalDateTime</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEnteringTheSpanFirst(from = nightStart, to = nightEnd) &amp;&amp; !currentIsDark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isExitingNight</span><span class="params">(nightEnd: <span class="type">LocalDateTime</span>, nextNightStart: <span class="type">LocalDateTime</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEnteringTheSpanFirst(from = nightEnd, to = nextNightStart) &amp;&amp; currentIsDark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (nightStart.isBefore(nightEnd)) &#123;</span><br><span class="line">        <span class="comment">// |day start           |night start------------|night end          |day end</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            now.isBefore(nightStart) -&gt; &#123;</span><br><span class="line">                isExitingNight(</span><br><span class="line">                    nightEnd = nightEnd.minusDays(<span class="number">1</span>),</span><br><span class="line">                    nextNightStart = nightStart</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            now.isBefore(nightEnd) -&gt; &#123;</span><br><span class="line">                isEnteringNight(</span><br><span class="line">                    nightStart = nightStart,</span><br><span class="line">                    nightEnd = nightEnd</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                isExitingNight(</span><br><span class="line">                    nightEnd = nightEnd,</span><br><span class="line">                    nextNightStart = nightStart.plusDays(<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// |day start-----------|night end              |night start--------|day end</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            now.isBefore(nightEnd) -&gt; &#123;</span><br><span class="line">                isEnteringNight(</span><br><span class="line">                    nightStart = nightStart.minusDays(<span class="number">1</span>),</span><br><span class="line">                    nightEnd = nightEnd</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            now.isBefore(nightStart) -&gt; &#123;</span><br><span class="line">                isExitingNight(</span><br><span class="line">                    nightEnd = nightEnd,</span><br><span class="line">                    nextNightStart = nightStart</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                isEnteringNight(</span><br><span class="line">                    nightStart = nightStart,</span><br><span class="line">                    nightEnd = nightEnd.plusDays(<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在MainActivity里：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> now = Instant.now().toEpochMilli()</span><br><span class="line"><span class="keyword">val</span> lastStartTime = prefs.getLong(<span class="string">&quot;last_start_time&quot;</span>, now)</span><br><span class="line">prefs.edit().putLong(<span class="string">&quot;last_start_time&quot;</span>, now).apply()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> currentIsDark = resources.isDarkTheme</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (darkTheme.calculateAutoDarkChange(</span><br><span class="line">        currentIsDark = currentIsDark,</span><br><span class="line">        nowMilli = now,</span><br><span class="line">        lastLaunchMilli = lastStartTime</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    updateDark(isDark = !currentIsDark)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Resources.isDarkTheme: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>在国内做Android开发踩过的坑</title>
    <url>/2019/08/25/android-chinese-pitfalls/</url>
    <content><![CDATA[<p>曾经怀疑过很多次是不是自己的代码有问题，到头来全是各厂商的魔改惹的祸。</p>
<span id="more"></span>

<h2 id="android-in-chia-Compatility"><a href="#android-in-chia-Compatility" class="headerlink" title="android-in-chia/Compatility"></a><a href="https://github.com/android-in-china/Compatibility/issues">android-in-chia/Compatility</a></h2><p>前人踩过的坑，以此祭天。</p>
<h2 id="LeanCloud混淆规则"><a href="#LeanCloud混淆规则" class="headerlink" title="LeanCloud混淆规则"></a>LeanCloud混淆规则</h2><p>官网的当然是keep所有喽，但我发现使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-dontwarn com.avos.**</span><br><span class="line">-dontnote com.avos.**</span><br><span class="line">-keepnames class com.avos.** &#123; *;&#125;</span><br></pre></td></tr></table></figure>

<p>似乎并不影响。</p>
<h2 id="fastjson混淆规则"><a href="#fastjson混淆规则" class="headerlink" title="fastjson混淆规则"></a>fastjson混淆规则</h2><p>这里指的是Java版并不是fastjson-android版。</p>
<p>官网的当然是。。没有啦，所以民间流传的当然是keep所有喽，但我发现使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-dontwarn com.alibaba.fastjson.**</span><br><span class="line">-dontnote com.alibaba.fastjson.**</span><br></pre></td></tr></table></figure>

<p>似乎并不影响。</p>
<h2 id="抖音SDK没有混淆规则"><a href="#抖音SDK没有混淆规则" class="headerlink" title="抖音SDK没有混淆规则"></a>抖音SDK没有混淆规则</h2><p>它们的“开放”平台没有混淆规则，但不加混淆会调用失败，只能keep所有了。感兴趣的可以试一试<code>-keepnames</code>。</p>
<h2 id="QQ钱包的Android-SDK接入"><a href="#QQ钱包的Android-SDK接入" class="headerlink" title="QQ钱包的Android SDK接入"></a>QQ钱包的Android SDK接入</h2><p><a href="https://qpay.qq.com/buss/wiki/99/1233">官网的文档</a>有错。</p>
<p>参数<code>serialNumber</code>为<code>null</code>或为空会导致失败，而服务端又没有提供，但填个任意字符串（我用了当前时间）就能调用了。</p>
<p>另外，在它们的SDK里发现了这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (TextUtils.isEmpty(<span class="string">&quot;native&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;native&quot;</span>.compareTo(<span class="string">&quot;native&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>看不懂有啥用，希望哪位大佬点拨一下。</p>
<p>另外的另外，它们的SDK也应该没提供混淆，只能惯例keep所有。</p>
<h2 id="友盟Share-SDK"><a href="#友盟Share-SDK" class="headerlink" title="友盟Share SDK"></a>友盟Share SDK</h2><p>QQ配置文档有错。用了AAR的依赖后，不需要修改Manifest，而要在app module中添加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        manifestPlaceholders = [<span class="attr">qqappid:</span> <span class="string">&#x27;appid&#x27;</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>另外，不需要分享的回调结果时，就不需要在<code>onActivityResult</code>调用它们的API的。</p>
<h2 id="BitmapFactory返回旧图像"><a href="#BitmapFactory返回旧图像" class="headerlink" title="BitmapFactory返回旧图像"></a><code>BitmapFactory</code>返回旧图像</h2><p>在一些特定的设备（只在华为设备上遇到过，其他未知）上，对一些特定尺寸的图片（640 * 640），使用<code>BitmapFactory.decodeFile/Stream</code>等类似方法解码<code>Bitmap</code>时，返回的不是此时此刻文件里的图片，而是上一次保存的图片。</p>
<p>最后换了<code>Glide</code>加载图片解决的。简单看了下源码，<code>Glide</code>似乎是用<code>ByteBuffer</code>加载本地图片的。</p>
<p>此问题的发生原因和解决方法暂时未知。</p>
<h2 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h2><blockquote>
<p>你觉得我喜欢去研究这些东西嘛？</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android简繁体翻译到底该放哪儿？</title>
    <url>/2022/12/25/android-chinese-strings/</url>
    <content><![CDATA[<p>Android开发有着和<a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ISO 639-1</a>与<a href="https://www.rfc-editor.org/info/bcp47">BCP 47</a>相似但不同的语言管理方案。</p>
<span id="more"></span>

<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>如果minSdk大于等于24(Android 7, Nougat)，根据<a href="https://developer.android.com/guide/topics/resources/providing-resources#AlternativeResources">官方文档</a>，简体中文放<code>values-b+zh+Hans</code>，繁体中文放<code>values-b+zh+Hant</code>。</p>
<p>但没人会这么做吧！</p>
<p>如果minSdk小于等于23(Android 6, Marshmallow)，经过个人测试，简体中文放<code>values-rCN</code>，繁体中文放<code>values-rTW</code>。如果要针对香港特殊翻译，再用<code>values-rHK</code>，澳门、新加坡同理。</p>
<h2 id="官方文档有坑"><a href="#官方文档有坑" class="headerlink" title="官方文档有坑"></a>官方文档有坑</h2><p><a href="https://developer.android.com/training/basics/supporting-devices/languages">讲解如何增加翻译的官方文档</a>和前段时间的Android Dev Summit的一个视频中中，都推荐BCP 47格式（比如<code>values-b+zh+Hans</code>），但<strong>都不提示这是Android 7及之后才支持的格式</strong>。</p>
<p>在之前的版本使用该格式时，应用并不会崩溃。但在缺少对应的翻译时，系统会发现新格式包含<code>zh</code>，进而先显示新格式的简体翻译，没有时显示新格式的繁体翻译。</p>
<h2 id="英文翻译"><a href="#英文翻译" class="headerlink" title="英文翻译"></a>英文翻译</h2><p>以情况简单的英文为例，Android系统并没有单独的“英语”的语言选择，而有的是诸如“英语（美国）”、“英语（英国）”和“英语（印度）”等选择。这种情况下<code>Locale.getDefault().toLanguageTag()</code>将会是<code>en-US</code>、<code>en-GB</code>和<code>en-IN</code>等。</p>
<p>这里可以把英文翻译统一放到<code>values-en</code>，但通常英语是直接放到<code>values</code>中作为默认语言。</p>
<h2 id="中文翻译"><a href="#中文翻译" class="headerlink" title="中文翻译"></a>中文翻译</h2><p>但简繁体中文并不能统一放到一个文件夹中。Android系统团队显然意识到了类似问题，但Android 7才支持为时已晚<del>（要是AGP向前兼容就好了）</del>。</p>
<p>以情况复杂的繁体中文为例，虽然翻译放到了台湾（<code>values-rTW</code>），但是：</p>
<p>在Android 5和6中，只有“简体中文”和“繁体中文”两个语言选项。前者对应<code>values-rCN</code>，后者对应<code>values-rTW</code>。这里并没有之后系统中，可以选择地区的选项。</p>
<p>从Android 7开始，在选择语言的同时，也必须选择语言的地区。这时就出现了港澳台三地的繁体中文版本。</p>
<p>在个人测试中，以香港繁体中文为例，系统选择<code>values-b+zh+Hant</code>和<code>values-rTW</code>或<code>values-rHK</code>的优先级在不同手机上是不同的。但肯定是繁体中文。</p>
<p>系统也足够智能，如果没有<code>values-rHK</code>，它会选择<code>values-rTW</code>，即使这里的地区是台湾而不是用户设置的香港。</p>
<p>系统会选择和用户设置地区不同的文件夹，这里是最反直觉的地方。这是因为找不到地区对应的翻译时，系统会选择同语言的其他地区翻译，来确保至少是语言是正确的。</p>
<h2 id="奖励1"><a href="#奖励1" class="headerlink" title="奖励1"></a>奖励1</h2><p><code>build.gradle</code>中的指定语言的<code>resConfigs</code>是要和对应文件夹一致的。比如<code>resConfigs &#39;en&#39;, &#39;zh-rCN&#39;, &#39;zh-rTW&#39;</code></p>
<h2 id="奖励2"><a href="#奖励2" class="headerlink" title="奖励2"></a>奖励2</h2><p>在<a href="https://developer.android.com/guide/topics/resources/app-languages">Per-app language preferences</a>，Android依然沿用了<a href="https://developer.android.com/guide/topics/resources/app-languages#sample-config">反直觉的缩写</a>。这里似乎和<code>Locale.toLanguageTag()</code>是一致的。</p>
<h2 id="更新1"><a href="#更新1" class="headerlink" title="更新1"></a>更新1</h2><p>不要假设简体中文只有<code>values-rCN</code>、<code>values-rSG</code>等几个地区标签。有的手机允许用户分别任意选择语言和地区，这样会有很多很多的组合。不过文件夹的检测顺序是通用的。</p>
<h2 id="更新2"><a href="#更新2" class="headerlink" title="更新2"></a>更新2</h2><p>如何检测应用当前是否是简体中文？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> languageTag = Locale.getDefault().toLanguageTag()</span><br><span class="line"><span class="keyword">if</span> (languageTag == <span class="string">&quot;zh-CN&quot;</span> || languageTag.startsWith(<span class="string">&quot;zh-Hans&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂时并没有找到更靠谱的办法。</p>
<p>往对应<code>values</code>文件夹中放对应语言的标识<code>string</code>似乎可以，但这让翻译协作变得困难。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/guide/topics/resources/localization">https://developer.android.com/guide/topics/resources/localization</a></li>
<li><a href="https://developer.android.com/guide/topics/resources/providing-resources#AlternativeResources">https://developer.android.com/guide/topics/resources/providing-resources#AlternativeResources</a></li>
<li><a href="https://developer.android.com/training/basics/supporting-devices/languages">https://developer.android.com/training/basics/supporting-devices/languages</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>一些可能有用的Android代码 - Android Makers 2022版</title>
    <url>/2022/06/25/android-code-snippets-android-makers22/</url>
    <content><![CDATA[<p><a href="https://www.youtube.com/playlist?list=PLn7H9CUCuXAuLnmPD-wsljzYxHt3UD5zn">Android Makers 2022</a></p>
<span id="more"></span>

<h2 id="buildSrc-Deprecated"><a href="#buildSrc-Deprecated" class="headerlink" title="buildSrc Deprecated"></a>buildSrc Deprecated</h2><p>对编译速度有影响，所以过气了。换用Version Catalogs。</p>
<h2 id="Single-variant-Libraries"><a href="#Single-variant-Libraries" class="headerlink" title="Single-variant Libraries"></a>Single-variant Libraries</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">androidComponents &#123;</span><br><span class="line">    beforeVariants(selector().withBuildType(<span class="string">&quot;debug&quot;</span>)) &#123; builder -&gt;</span><br><span class="line">        builder.enable = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Disable-Android-Features"><a href="#Disable-Android-Features" class="headerlink" title="Disable Android Features"></a>Disable Android Features</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"># Build features that are disabled by <span class="keyword">default</span> <span class="keyword">in</span> all projects</span><br><span class="line">android.<span class="keyword">default</span>.buildFeatures.aidl=<span class="literal">false</span></span><br><span class="line">android.<span class="keyword">default</span>.buildFeatures.buildconfig=<span class="literal">false</span></span><br><span class="line">android.<span class="keyword">default</span>.buildFeatures.renderscript=<span class="literal">false</span></span><br><span class="line">android.<span class="keyword">default</span>.buildFeatures.resvalues=<span class="literal">false</span></span><br><span class="line">android.<span class="keyword">default</span>.buildFeatures.shaders=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="TaskUpToDateValidator-kt"><a href="#TaskUpToDateValidator-kt" class="headerlink" title="TaskUpToDateValidator.kt"></a>TaskUpToDateValidator.kt</h2><p><a href="https://github.com/androidx/androidx/blob/androidx-main/buildSrc/private/src/main/kotlin/androidx/build/uptodatedness/TaskUpToDateValidator.kt">TaskUpToDateValidator.kt</a></p>
<h2 id="modules-graph-assert"><a href="#modules-graph-assert" class="headerlink" title="modules-graph-assert"></a>modules-graph-assert</h2><p><a href="https://github.com/jraska/modules-graph-assert">https://github.com/jraska/modules-graph-assert</a></p>
<h2 id="文件保存"><a href="#文件保存" class="headerlink" title="文件保存"></a>文件保存</h2><img src="/2022/06/25/android-code-snippets-android-makers22/save_files.png" class="" title="[save_files.png](.&#x2F;android-code-snippets-android-makers22&#x2F;save_files.png)">
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>一些可能有用的Android代码</title>
    <url>/2019/06/15/android-code-snippets/</url>
    <content><![CDATA[<p><strong>2020年11月6日 更新<code>View.outlineProvider</code></strong></p>
<p>没地儿放它们。</p>
<span id="more"></span>

<h2 id="渐隐重启Activity"><a href="#渐隐重启Activity" class="headerlink" title="渐隐重启Activity"></a>渐隐重启Activity</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">startActivity(Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java))</span><br><span class="line">finish()</span><br><span class="line">overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">startActivity(Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java),</span><br><span class="line">    ActivityOptions.makeCustomAnimation(<span class="keyword">this</span>, android.R.anim.fade_in, android.R.anim.fade_out).toBundle()</span><br><span class="line">)</span><br><span class="line">finish()</span><br></pre></td></tr></table></figure>

<h2 id="RingtoneManager"><a href="#RingtoneManager" class="headerlink" title="RingtoneManager"></a><a href="https://developer.android.com/reference/android/media/RingtoneManager.html">RingtoneManager</a></h2><blockquote>
<p>Note that the list of ringtones available will differ depending on whether the caller has the {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission.</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(RingtoneManager.ACTION_RINGTONE_PICKER)</span><br><span class="line">        .putExtra(RingtoneManager.EXTRA_RINGTONE_TITLE, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        .putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALL)</span><br><span class="line">        .putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_SILENT, <span class="literal">true</span>)</span><br><span class="line">        .putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, <span class="literal">true</span>)</span><br><span class="line">        .putExtra(RingtoneManager.EXTRA_RINGTONE_DEFAULT_URI, Uri.EMPTY)</span><br><span class="line">        .putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, Uri.EMPTY)</span><br><span class="line">startActivityForResult(intent, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>onActivityResult</code>,</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> uri = <span class="keyword">data</span>?.getParcelableExtra&lt;Uri&gt;(RingtoneManager.EXTRA_RINGTONE_PICKED_URI)</span><br><span class="line"><span class="keyword">val</span> name = <span class="keyword">if</span> (uri != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> rng = RingtoneManager.getRingtone(<span class="keyword">this</span>, uri)</span><br><span class="line">    <span class="keyword">if</span> (rng != <span class="literal">null</span>) &#123;</span><br><span class="line">        rng.stop()</span><br><span class="line">        rng.getTitle(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getString(R.string.unknown)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getString(R.string.unknown)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件选择"><a href="#文件选择" class="headerlink" title="文件选择"></a>文件选择</h2><p><a href="https://github.com/googlecodelabs/android-storage-permissions/blob/master/app/src/main/java/com/google/samples/dataprivacy/page/importimage/ImageImportActivity.java#L125">来自Codelab的一段代码</a>.</p>
<p>需要<code>READ_EXTERNAL_STORAGE</code>权限。</p>
<h2 id="RecyclerView头部视差显示"><a href="#RecyclerView头部视差显示" class="headerlink" title="RecyclerView头部视差显示"></a>RecyclerView头部视差显示</h2><p>使第一个View渐隐退出Window。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.addOnScrollListener(<span class="keyword">object</span> :RecyclerView.OnScrollListener()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onScrolled</span><span class="params">(recyclerView: <span class="type">RecyclerView</span>, dx: <span class="type">Int</span>, dy: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrolled(recyclerView, dx, dy)</span><br><span class="line">        <span class="keyword">val</span> view = recyclerView.getChildAt(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="literal">null</span> &amp;&amp; recyclerView.getChildAdapterPosition(view) == <span class="number">0</span>) &#123;</span><br><span class="line">            view.translationY = view.top / <span class="number">3f</span></span><br><span class="line">            view.alpha =  <span class="number">1</span> - -view.top.toFloat() / view.height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ADB查看当前Activity"><a href="#ADB查看当前Activity" class="headerlink" title="ADB查看当前Activity"></a>ADB查看当前Activity</h2><ol>
<li><code>adb shell &quot;dumpsys window w | grep name=&quot;</code></li>
<li>栈顶：<code>adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code></li>
<li>栈顶Fragment：<code>adb shell dumpsys activity your.package.name</code></li>
</ol>
<h2 id="ADB截屏并保存"><a href="#ADB截屏并保存" class="headerlink" title="ADB截屏并保存"></a>ADB截屏并保存</h2><p><code>adb shell screencap -p | perl -pe &#39;s/\x0D\x0A/\x0A/g&#39; &gt; screen.png</code></p>
<p>或者</p>
<p><code>adb exec-out screencap -p &gt; screen.png</code></p>
<p><a href="https://blog.shvetsov.com/2013/02/grab-android-screenshot-to-computer-via.html">Grab Android screenshot to computer via ADB</a></p>
<h2 id="让一个Activity有类似Android-O或P彩蛋一样的背景。"><a href="#让一个Activity有类似Android-O或P彩蛋一样的背景。" class="headerlink" title="让一个Activity有类似Android O或P彩蛋一样的背景。"></a>让一个Activity有类似Android O或P彩蛋一样的背景。</h2><p>设置theme为<code>android:theme=&quot;@android:style/Theme.Wallpaper.NoTitleBar.Fullscreen&quot;</code>。</p>
<h2 id="给Layout添加Ripple"><a href="#给Layout添加Ripple" class="headerlink" title="给Layout添加Ripple"></a>给Layout添加Ripple</h2><ol>
<li><p>创建<code>ripple_press.xml</code></p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">&quot;@android:color/white&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/mask&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">&quot;rectangle&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;@android:color/white&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在Layout中使用</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:clickable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foreground</span>=<span class="string">&quot;@drawable/ripple_press&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <code>clickable</code>和<code>focusable</code>很重要，<code>View</code>之前的View会有Ripple效果，之后的View则没有。</p>
</li>
</ol>
<h2 id="AutoClearedValue"><a href="#AutoClearedValue" class="headerlink" title="AutoClearedValue"></a>AutoClearedValue</h2><p><a href="https://github.com/googlesamples/android-architecture-components/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/util/AutoClearedValue.kt">https://github.com/googlesamples/android-architecture-components/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/util/AutoClearedValue.kt</a></p>
<h2 id="带清除按钮的EditText"><a href="#带清除按钮的EditText" class="headerlink" title="带清除按钮的EditText"></a>带清除按钮的EditText</h2><p>来自<a href="https://youtu.be/fpSfCvP36aA?t=1672">Best Practices for Using Text in Android (Google I/O’19)</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:addStatesFromChildren</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;?editTextBackground&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span> <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageButton</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Custom-View中的onSaveInstanceState"><a href="#Custom-View中的onSaveInstanceState" class="headerlink" title="Custom View中的onSaveInstanceState"></a>Custom View中的<code>onSaveInstanceState</code></h2><p><a href="https://stackoverflow.com/a/28586444/5507158">Android didn’t manage the onSaveInstanceState/onRestoreInstanceState if no id is set to the view.</a></p>
<h2 id="attr-android-attr-colorPrimary-attr-colorPrimary…"><a href="#attr-android-attr-colorPrimary-attr-colorPrimary…" class="headerlink" title="?attr, ?android:attr, ?colorPrimary, ?attr/colorPrimary…"></a>?attr, ?android:attr, ?colorPrimary, ?attr/colorPrimary…</h2><p><a href="https://developer.android.com/guide/topics/resources/providing-resources#ResourcesFromXml">https://developer.android.com/guide/topics/resources/providing-resources#ResourcesFromXml</a> =&gt; Referencing style attributes`</p>
<h2 id="File-Mark-As-Plain-Text"><a href="#File-Mark-As-Plain-Text" class="headerlink" title="File - Mark As Plain Text"></a>File - Mark As Plain Text</h2><p>重构时很有用，不会影响VS。</p>
<h2 id="FragmentManager-setCustomAnimations-‘s-Parameters"><a href="#FragmentManager-setCustomAnimations-‘s-Parameters" class="headerlink" title="FragmentManager.setCustomAnimations()‘s Parameters"></a><code>FragmentManager.setCustomAnimations()</code>‘s Parameters</h2><ul>
<li><code>@AnimatorRes @AnimRes int enter</code>: 应用到动画中进入屏幕的Fragment</li>
<li><code>@AnimatorRes @AnimRes int exit</code>: 应用到动画中退出屏幕的Fragment</li>
<li><code>@AnimatorRes @AnimRes int popEnter</code>: 应用到<code>popBackStack</code>时动画中进入屏幕的Fragment</li>
<li><code>@AnimatorRes @AnimRes int popExit</code>: 应用到<code>popBackStack</code>时动画中退出屏幕的Fragment</li>
</ul>
<h2 id="Kotlin-in-and-out"><a href="#Kotlin-in-and-out" class="headerlink" title="Kotlin in and out"></a>Kotlin <code>in</code> and <code>out</code></h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个RecyclerView.ViewHolder子类的List</span></span><br><span class="line"><span class="comment">// 因为不知道到底是哪个子类，所以不能安全的添加或修改</span></span><br><span class="line"><span class="comment">// 但肯定能拿到一个RecyclerView.ViewHolder</span></span><br><span class="line"><span class="comment">// 只能拿，所以叫out，Java里叫extends</span></span><br><span class="line"><span class="keyword">val</span> outList: MutableList&lt;<span class="keyword">out</span> RecyclerView.ViewHolder&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个RecyclerView.ViewHolder父类的List</span></span><br><span class="line"><span class="comment">// 因为不知道到底是哪个父类，所以只能强行拿到顶层的Any?</span></span><br><span class="line"><span class="comment">// 但是可以随便添加或修改RecyclerView.ViewHolder及其子类</span></span><br><span class="line"><span class="comment">// 只有添加或修改方便，所以叫in，Java里叫super</span></span><br><span class="line"><span class="keyword">val</span> inList: MutableList&lt;<span class="keyword">in</span> RecyclerView.ViewHolder&gt; = mutableListOf()</span><br></pre></td></tr></table></figure>

<h2 id="clipToPadidng"><a href="#clipToPadidng" class="headerlink" title="clipToPadidng"></a><code>clipToPadidng</code></h2><p><code>Enables our items to still be drawn within the parent&#39;s padding.</code></p>
<h2 id="View-outlineProvider"><a href="#View-outlineProvider" class="headerlink" title="View.outlineProvider"></a><code>View.outlineProvider</code></h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.imageView.run &#123;</span><br><span class="line">    clipToOutline = <span class="literal">true</span></span><br><span class="line">    outlineProvider = <span class="keyword">object</span> : ViewOutlineProvider() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOutline</span><span class="params">(view: <span class="type">View</span>, outline: <span class="type">Outline</span>)</span></span> &#123;</span><br><span class="line">            outline.setOval(</span><br><span class="line">                view.paddingLeft,</span><br><span class="line">                view.paddingTop,</span><br><span class="line">                view.width - view.paddingRight,</span><br><span class="line">                view.height - view.paddingBottom</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>一些可能有用的Android代码 - IO22版</title>
    <url>/2022/05/29/android-code-snippets-io22/</url>
    <content><![CDATA[<p>记录了一些可以直接拿来使用的内容。出处全是IO视频截图。</p>
<span id="more"></span>

<h2 id="搜索按钮的触发事件"><a href="#搜索按钮的触发事件" class="headerlink" title="搜索按钮的触发事件"></a>搜索按钮的触发事件</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">btnSearch.setOnEditorActionListener &#123; _, actionId, _ -&gt;</span><br><span class="line">    <span class="keyword">if</span> (actionId == EditorInfo.IME_ACTION_SEARCH) &#123;</span><br><span class="line">        performSearch()</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">btnSearch.setOnKeyListener &#123; _, keyCode, event -&gt;</span><br><span class="line">    <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_ENTER &amp;&amp; event.action == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">        performSearch()</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ViewPager中的Fragment获取ViewModel"><a href="#ViewPager中的Fragment获取ViewModel" class="headerlink" title="ViewPager中的Fragment获取ViewModel"></a>ViewPager中的Fragment获取ViewModel</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scope the fragment to the parent fragment</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> sharedViewModel: PagerViewModel</span><br><span class="line">  <span class="keyword">by</span> viewModels(ownerProducer = &#123; requireParentFragment() &#125; )</span><br></pre></td></tr></table></figure>

<h2 id="获取硬盘剩余空间"><a href="#获取硬盘剩余空间" class="headerlink" title="获取硬盘剩余空间"></a>获取硬盘剩余空间</h2><p><a href="https://stackoverflow.com/questions/8133417/android-get-free-size-of-internal-external-memory">Stackoverflow上</a>说：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sf = StatFs(file.absolutePath)</span><br><span class="line"><span class="keyword">val</span> availableBytes = sf.availableBlocksLong * sf.blockSizeLong</span><br></pre></td></tr></table></figure>

<p>IO上说：</p>
<p>Use <code>File.getUsableSpace</code> to check available space on storage.</p>
<p>二者数据似乎相等。</p>
<h2 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> target = <span class="keyword">if</span> (filesDir.usableSpace &gt; fileSize) &#123;</span><br><span class="line">    filesDir</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getExternalFilesDir(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line">requireNotNull(target) &#123; <span class="string">&quot;Not enough space&quot;</span> &#125;</span><br><span class="line">bigInputStream.use &#123; input -&gt;</span><br><span class="line">    File(target, <span class="string">&quot;big-file.zip&quot;</span>).outputStream().use &#123; output -&gt;</span><br><span class="line">        input.copyTo(output)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取屏幕大小"><a href="#获取屏幕大小" class="headerlink" title="获取屏幕大小"></a>获取屏幕大小</h2><p>使用<a href="https://developer.android.com/jetpack/androidx/releases/window">Jetpack WindowManager</a>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> current = WindowMetricsCalculator.getOrCreate().computeCurrentWindowMetrics(activity)</span><br><span class="line"><span class="keyword">val</span> max = WindowMetricsCalculator.getOrCreate().computeMaximumWindowMetrics(activity)</span><br></pre></td></tr></table></figure>

<p>但如果没有Activity呢？先用古法凑活一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> wm = context.getSystemService&lt;WindowManager&gt;()</span><br><span class="line">requireNotNull(wm)</span><br><span class="line"><span class="keyword">val</span> point = Point()</span><br><span class="line"><span class="keyword">val</span> defaultDisplay = wm.defaultDisplay</span><br><span class="line">defaultDisplay.getRealSize(point)</span><br><span class="line"><span class="keyword">if</span> (point.x &lt;= <span class="number">0</span> || point.y &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> rect = Rect()</span><br><span class="line">    defaultDisplay.getRectSize(rect)</span><br><span class="line">    point.<span class="keyword">set</span>(rect.right, rect.bottom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码部分来自于<code>WindowMetricsCalculator.getOrCreate().computeCurrentWindowMetrics(activity)</code>。</p>
<p>注意：</p>
<ol>
<li>所有方法都会根据屏幕旋转进行数值调换。</li>
<li><code>Resources.getSystem().displayMetrics.heightPixels</code>并不包括状态栏和（或）状态栏。</li>
</ol>
<h2 id="相机旋转和设备旋转"><a href="#相机旋转和设备旋转" class="headerlink" title="相机旋转和设备旋转"></a>相机旋转和设备旋转</h2><p><a href="https://developer.android.com/codelabs/android-camera2-preview">Support resizable surfaces in your camera app</a>，或者用1.1.0及以上的CameraX。</p>
<h2 id="实现列表特殊Footer效果"><a href="#实现列表特殊Footer效果" class="headerlink" title="实现列表特殊Footer效果"></a>实现列表特殊Footer效果</h2><ol>
<li>内容不满一屏幕时，Footer显示在屏幕底端。</li>
<li>屏幕超过一屏幕时，Footer和其他条目一样排排坐。</li>
</ol>
<p>使用Jetpack Compose来实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LazyColumn(</span><br><span class="line">    modifier = Modifier.fillMaxHeight(),</span><br><span class="line">    verticalArrangement = TopWithFooter,</span><br><span class="line">) &#123;</span><br><span class="line">    items(list) &#123;</span><br><span class="line">        Item()</span><br><span class="line">    &#125;</span><br><span class="line">    item &#123;</span><br><span class="line">        Footer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，LazyColumn不满一屏幕会<code>WRAP_CONTENT</code>，用<code>fillMaxHeight()</code>来指定高度。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> TopWithFooter : Arrangement.Vertical &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">arrange</span><span class="params">(totalSize: <span class="type">Int</span>, sizes: <span class="type">IntArray</span>, outPositions: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">        sizes.forEachIndexed &#123; index, size -&gt;</span><br><span class="line">            outPositions[index] = y</span><br><span class="line">            y += size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; totalSize) &#123;</span><br><span class="line">            outPositions[outPositions.lastIndex] = totalSize - (sizes.lastOrNull() ?: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code>判断前内容就是默认的<code>verticalArrangement</code>（<code>Arrangement.Top</code>）的实现。</p>
<p>代码过于简单以至于不需要其他解释了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>巧用Android CoordinatorLayout实现复杂布局 + 滚动内容</title>
    <url>/2019/10/02/android-coordinator-layout-hack/</url>
    <content><![CDATA[<p>一个使用情景是：页面上半部分是一个不算短的、复杂的Layout，后半部分是一个嵌套了RecyclerView的Fragment的横向ViewPager。使用效果是，上半部分会充当下半部分可滚动内容的Header。怎么做？</p>
<span id="more"></span>

<h2 id="常见的解决办法"><a href="#常见的解决办法" class="headerlink" title="常见的解决办法"></a>常见的解决办法</h2><p>如果下半部分只是RecyclerView而不是ViewPager的话，可以把上半部分当作RecyclerView的Header，使用多类型Adapter实现，除了每次找头部有点麻烦外，没问题。</p>
<p>但下面是ViewPager，这时如果用ScrollView/NestedScrollView，可能会发生一下情况：</p>
<ol>
<li><p>滚顿位置错误、初始位置不是最顶部</p>
<p> 从下往上滚动到ViewPager顶部时，滚动停止，需要再次下拉才能看到头部。记忆中SO上给出一种解决方案是，修改fousable，但这样会伤害到a11y，虽然不少人不在乎这个东西，但是还是有更优雅的解决方案的。</p>
</li>
<li><p>ViewPager双向滚动不流畅</p>
<p> 只要ViewPager嵌套RecyclerView都会多少出现这个问题。解决方案可以参考<a href="https://rubensousa.com/2019/08/16/nested_recyclerview_part1/">Improving scrolling behavior of nested RecyclerViews - Part 1</a></p>
</li>
<li><p>使用ViewPager2来解决问题</p>
<p> 之前试了一下，似乎能解决不少问题，但遇到了横向滚动时位置错误/空白的问题，无奈只能放弃。另外，它的双向滚动不流畅问题比ViewPager还要严重。也许未来的Release会修好这些问题。</p>
</li>
</ol>
<p>更严重的是，如果在SO上找答案，会根据不同Target API和不同AndroidX/Support版本，方案都不一样，有新有旧，有的有用有的没用。</p>
<h2 id="要用CoordinatorLayout啊"><a href="#要用CoordinatorLayout啊" class="headerlink" title="要用CoordinatorLayout啊"></a>要用CoordinatorLayout啊</h2><p>前段时间找到了一个不错的解决办法，就是使用CoordinatorLayout，把上半部分塞到AppBarLayout中，下半部分放到正文中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:elevation</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- Top Content --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.viewpager.widget.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/viewPager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CoordinatorLayouthe和AppBarLayout不一定非要用在根部嘛，无论哪里都可以用。</p>
<p>既然不放Toolbar，可以把AppBarLayout的颜色和elevation去掉：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:elevation</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>让CollapsingToolbarLayout滚起来，可以让顶部内容成为Header：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，滚动位置、初始位置、a11y什么的都没问题啦。</p>
<h2 id="奖励：带一个可滚动的TabLayout"><a href="#奖励：带一个可滚动的TabLayout" class="headerlink" title="奖励：带一个可滚动的TabLayout"></a>奖励：带一个可滚动的TabLayout</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.tabs.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tabLayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>TabLayout是顶部内容最后一个，会跟随滚动，离开屏幕。</p>
<h2 id="奖励励：带一个常驻的TabLayout"><a href="#奖励励：带一个常驻的TabLayout" class="headerlink" title="奖励励：带一个常驻的TabLayout"></a>奖励励：带一个常驻的TabLayout</h2><p>把TabLayout移到下半部分：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.tabs.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tabLayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.viewpager.widget.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/viewPager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样TabLayout一开始会跟随滚动，到达顶部后，就不动了，而下半部分的ViewPager会继续滚，相当于一个Sticky Header。如果一开始使用多类型Adapter + Header实现的话，要解决这个就需要点劳动了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浓眉大眼的CoordinatorLayout和它的一帮小弟有时候还有点用。希望material 1.1.0不会出现陨石坑吧。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android Dark Theme/深色模式使用体验</title>
    <url>/2020/05/07/android-dark-theme/</url>
    <content><![CDATA[<p>虽说一行代码<code>AppCompatDelegate.setDefaultNightMode</code>就能搞定的问题，但实际上坑不少哩。</p>
<span id="more"></span>

<h2 id="命名问题"><a href="#命名问题" class="headerlink" title="命名问题"></a>命名问题</h2><p>之前Google自己在文档中和API中混用Night Theme/Dark Theme，后来才统一用Dark Theme，毕竟不一定非得晚上才可以用这个模式嘛。同样的，在Dark Theme的中文文档里，将其翻译为深色/浅色主题，个人觉得比之前大伙儿用的夜间模式、黑色模式、黑夜模式、暗夜模式、暗黑模式等好听不少。</p>
<h2 id="自带的坑"><a href="#自带的坑" class="headerlink" title="自带的坑"></a>自带的坑</h2><p>AppCompat 1.1.0给我们带来了深色模式，也带来了不少问题。像是<a href="https://issuetracker.google.com/issues/141351441">因为从rc到正式版时只改了一行关于深色模式的代码，导致棒棒糖的WebView全线崩溃的问题</a>。</p>
<p><code>setDefaultNightMode</code>在1.1.0中会自动重启所有Activity，这导致不少应用的深色主题的逻辑被打乱不说，这个实现也很难自定义。当然，你别动它，自然什么毛病没有。</p>
<h2 id="自挖的坑"><a href="#自挖的坑" class="headerlink" title="自挖的坑"></a>自挖的坑</h2><p><code>setDefaultNightMode</code>会调用<a href="https://developer.android.com/reference/kotlin/androidx/core/app/ActivityCompat#recreate(android.app.Activity)"><code>ActivityCompat.recreate()</code></a>。</p>
<p>这个方法没有任何动画不说，而且在某些设备上会黑屏闪一下。在之前<code>setDefaultNightMode</code>不会自动重启的日子里，我的办法是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Activity.<span class="title">restartWithFading</span><span class="params">()</span></span> &#123;</span><br><span class="line">    startActivity(intent)</span><br><span class="line">    finish()</span><br><span class="line">    overridePendingTransition(R.anim.fade_in_short, R.anim.fade_out_short)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但现在不行了。那么如何拦截<code>recreate()</code>呢？</p>
<p>我的第一次尝试是根据文档中<a href="https://developer.android.com/guide/topics/ui/look-and-feel/darktheme#configuration_changes">对<code>onConfigurationChanged()</code>进行拦截</a>，在拦截后手动重启Activity。</p>
<p>这么做用了没问题，但如果我从一个没有拦截<code>onConfigurationChanged()</code>的Activity中切换深色主题（比如通过省电模式），那这时会切换失效。</p>
<p>这是因为文档中有一句话：</p>
<blockquote>
<p>An app can handle the implementation of Dark theme itself by declaring that <strong>each</strong> Activity can handle the uiMode configuration change:</p>
</blockquote>
<p>我们需要对每个Activity都进行拦截。但这时如果我用了第三方的Activity（像CustomTabs），这依然会失效。至此我只能另寻他路。</p>
<p>我的第二次尝试是重写<code>recreate()</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">recreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">        <span class="comment">// 不在前台时执行此处会导致Activity成为栈顶。</span></span><br><span class="line">        restartWithFading()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.recreate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用后皆大欢喜，但当我在另一台机器上测试时，发现失效了。原因是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recreate</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">    <span class="comment">// On Android P and later we can safely rely on the platform recreate()</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">28</span>) &#123;</span><br><span class="line">        activity.recreate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ActivityRecreator.recreate(activity)) &#123;</span><br><span class="line">            <span class="comment">// If ActivityRecreator did not start a recreation, we&#x27;ll just invoke the platform</span></span><br><span class="line">            activity.recreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ActivityCompat.recreate</code>在派之后才会调用<code>recreate</code>，而在之前只是<strong>可能</strong>调用，比如我在27的设备上没调用，但在21的模拟器上调用了。</p>
<p>至此我没办法了，只能委屈部分老用户闪一下了。╮(╯▽╰)╭</p>
<h2 id="我都不知道我不知道的坑"><a href="#我都不知道我不知道的坑" class="headerlink" title="我都不知道我不知道的坑"></a>我都不知道我不知道的坑</h2><p>我的一个应用里有一个指定时间段内自动打开/关闭深色主题的功能。具体如下，</p>
<p>一个Switch显示是否使用了深色主题：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">switchDark.isChecked = resources.isDarkTheme</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Resources.isDarkTheme: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES</span><br></pre></td></tr></table></figure>

<p>切换Switch时切换深色模式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">switchDark.setOnCheckedChangeListener &#123; _, isChecked -&gt;</span><br><span class="line">    toggleDark(toDark = isChecked)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">toggleDark</span><span class="params">(toDark: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    AppCompatDelegate.setDefaultNightMode(</span><br><span class="line">        <span class="keyword">if</span> (toDark) &#123;</span><br><span class="line">            AppCompatDelegate.MODE_NIGHT_YES</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AppCompatDelegate.MODE_NIGHT_NO</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，在onCreate中根据需要自动切换深色模式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldToggleAutoDark) &#123;</span><br><span class="line">    toggleDark(toDark = !resources.isDarkTheme)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有啥问题，有啥问题呀？</p>
<p>如果使用之前在<code>recreate</code>中重启应用的方法，那么在派及之后的设备上没有任何问题。否则，在所有设备上 + 使用之前在<code>recreate</code>中重启应用的方法且在派之前的设备上，都会出现自动切换失效的问题。</p>
<p>比如现在是浅色主题，Switch为关，在启动时触发自动深色主题，<code>setDefaultNightMode</code>呼叫<code>recreate()</code>，应用重启，Switch为开，但这时Switch会经历一次<code>onSaveInstanceState</code>，将它的状态设置为之前的关，同时触发<code>OnCheckedChangeListener</code>，把应用设置为浅色模式，然后我们回到了原点。╮(╯▽╰)╭</p>
<p>最后我把Switch在切换前把所有可能调用<code>onSaveInstanceState</code>的地方（<code>toggleDark</code>和<code>recreate</code>中）删掉View后，修好了。</p>
<p>也可以在那些地方清空掉Listener，再把isChecked设为新的值。</p>
<p>完。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android Dev Summit 2019 笔记</title>
    <url>/2019/11/13/android-dev-summit-2019/</url>
    <content><![CDATA[<p>RT</p>
<span id="more"></span>

<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><ul>
<li>MAC: <code>system-Profiler SPUSBDataType</code></li>
<li>Linux: <code>lsusb -vvv</code></li>
<li>Windows: <code>USBView.exe</code></li>
</ul>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p><code>settings.gradle</code>: <code>project(&quot;:core&quot;).projectDir = new File(rootDir, &quot;libraries/core&quot;)</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> androidx = [:]</span><br><span class="line">androidx.appcompat = <span class="string">&quot;androidx.apcompat:appcompat:1.1.0&quot;</span></span><br><span class="line"></span><br><span class="line">ext.libs = [:]</span><br><span class="line">exit.libs.androidx = androidx</span><br><span class="line"></span><br><span class="line">implementation libs.androidx.appcompat</span><br></pre></td></tr></table></figure>

<h3 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb emu <span class="built_in">fold</span></span><br><span class="line">adb emu wm size</span><br><span class="line">adb emu wm size 1148x2480</span><br><span class="line">adb emu wm size reset</span><br></pre></td></tr></table></figure>

<h3 id="Drawing-Behind-System-Bar"><a href="#Drawing-Behind-System-Bar" class="headerlink" title="Drawing Behind System Bar"></a>Drawing Behind System Bar</h3><ol>
<li><p>Change system bar colors</p>
<p> values-v29/themes.xml:</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:navigationBarColor&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> values/themes.xml: <code>#B3FFFFFF</code>(70% white)</p>
<p> values-night/themes.xml: <code>#B3000000</code>(70% black)</p>
</li>
<li><p>Request to be laid out fullscreen</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.systemUiVisibility =</span><br><span class="line">    <span class="comment">// We wish to be laid out as if the navigation bar was hidden</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or</span><br><span class="line">    <span class="comment">// We wish to be laid out fullscreen, behind the status bar</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or</span><br><span class="line">    <span class="comment">// We wish to be laid out at the most extreme scenario of any other flags</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br></pre></td></tr></table></figure></li>
<li><p>Avoid overlays with system UI</p>
<p> Always use the ViewCompat method:</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ViewCompat.setOnApplyWindowInsetsListener(view) &#123; v, insets -&gt;</span><br><span class="line">    <span class="comment">// Do something with the insets</span></span><br><span class="line">    v.updatePadding(</span><br><span class="line">        bottom = insets.systemWindowInsets.bottom</span><br><span class="line">    )</span><br><span class="line">    v.updateLayoutParams&lt;MarginLayoutParams&gt;(</span><br><span class="line">        bottomMargin = insets.systemWindowInsets.bottom</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// return the insets</span></span><br><span class="line">    insets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WindowInsetsCompat.getSystemWindowInsets(): Insets</span><br><span class="line">WindowInsetsCompat.getSystemGestureInsets(): Insets</span><br><span class="line">WindowInsetsCompat.getMandatorySystemGestureInsets(): Insets</span><br></pre></td></tr></table></figure>

<p> onLayout/onDraw: <code>View.setSystemGestureExclusionRects(List&lt;Rect&gt; rects)</code></p>
</li>
</ol>
<h3 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h3><p>Fragment, Fragment ViewModel, Activity, Activity ViewModel, Application &amp; its ViewModel</p>
<h3 id="One-way-to-handle-back"><a href="#One-way-to-handle-back" class="headerlink" title="One way to handle back"></a>One way to handle back</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dispatcher <span class="keyword">by</span> lazy &#123; requireActivity().onBackPressedDispatcher &#125;</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> callback: OnBackPressedCallback</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    callback = dispatcher.addCallback(<span class="keyword">this</span>) &#123;</span><br><span class="line">        showConfirmDialog()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConfirm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    callback.enabled = <span class="literal">false</span></span><br><span class="line">    dispatcher.onBackPressed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Intent-Handling"><a href="#Intent-Handling" class="headerlink" title="Intent Handling"></a>Intent Handling</h3><ol>
<li>A lot of intent handlers couble be disabled.</li>
<li>Check if an intent handler exists, don’t assume it will just work.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (intent.resolveActivity(packageManager) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Error!</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scoped-Storage"><a href="#Scoped-Storage" class="headerlink" title="Scoped Storage"></a>Scoped Storage</h3><ol>
<li><p>Read only video/image/audio files</p>
<p> MediaStore + READ_EXTERNAL_STORAGE</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Video</span>(<span class="keyword">val</span> uri: Uri, <span class="keyword">val</span> name: String, <span class="keyword">val</span> duration: <span class="built_in">Int</span>, <span class="keyword">val</span> size: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">val</span> videoList = mutableListOf&lt;Video&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> projection = arrayOf(</span><br><span class="line">    MediaStore.Video.Media._ID,</span><br><span class="line">    MediaStore.Video.Media.DISPLAY_NAME,</span><br><span class="line">    MediaStore.Video.Media.DURATION,</span><br><span class="line">    MediaStore.Video.Media.SIZE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> selection = <span class="string">&quot;Video.Media.DURATION) &gt;= ?&quot;</span></span><br><span class="line"><span class="keyword">val</span> selectionArgs = arrayOf(</span><br><span class="line">    TimeUnit.MILLISECONDS.convert(<span class="number">5</span>, TimeUnit.MINUTES).toString()</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> query = contentResolver.query(</span><br><span class="line">    MediaStore.Video.Media.EXTERNAL_CONTENT_URI,</span><br><span class="line">    projection,</span><br><span class="line">    selection,</span><br><span class="line">    selectionArgs,</span><br><span class="line">    <span class="string">&quot;<span class="subst">$&#123;MediaStore.Video.Media.DISPLAY_NAME&#125;</span> ASC&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">query?.use &#123; cursor -&gt;</span><br><span class="line">    <span class="keyword">val</span> idColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)</span><br><span class="line">    <span class="keyword">val</span> nameColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)</span><br><span class="line">    <span class="keyword">val</span> durationColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DDRATION)</span><br><span class="line">    <span class="keyword">val</span> sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="comment">// we 11 use the column indexes that we found above</span></span><br><span class="line">        <span class="keyword">val</span> id = cursor.getLong(idColumn)</span><br><span class="line">        <span class="keyword">val</span> name = cursor.getString(nameColumn)</span><br><span class="line">        <span class="keyword">val</span> duration = cursor.getInt(durationColumn)</span><br><span class="line">        <span class="keyword">val</span> size = cursor.getInt(sizeColumn)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> contentUri = ContentUris.withAppendedId(</span><br><span class="line">            MediaStore Video Media EXTERNAL_CONTENT_URI. id</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        videolist += Video(contentUri, name, duration, size)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Read non-media files</p>
<p> SAF(No Permission): ACTION_OPEN_DOCUMENT, ACTION_OPEN_DOCUMENT_TREE + takePersistableUriPermission</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">intentPickDocument</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply &#123;</span><br><span class="line">        addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">        type = <span class="string">&quot;application/pdf&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    startActivityForResult(intent, PICK_PDF_FILE)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, resultData: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, resultData)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCode == PICK_PDF_FILE &amp;&amp; resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        resultData?.<span class="keyword">data</span>?.let &#123; uri -&gt;</span><br><span class="line">            renderPdf(uri)</span><br><span class="line"></span><br><span class="line">            contentResolver.query(uri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)?.use &#123;</span><br><span class="line">                <span class="keyword">val</span> name = it.getString(cursor.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME))</span><br><span class="line">                <span class="keyword">val</span> size = it.getString(cursor.getColumnIndexOrThrow(OpenableColumns.SIZE)) <span class="comment">// May throw</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Add &amp; Edit image/video/audio files</p>
<p> MediaStore + WRITE_EXTERNAL_STORAGE(READ?) + ACCESS_MEDIA_LOCATION to access EXIF data</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectedImageUri = Uri.parser(<span class="string">&quot;content://media/external/images/media/44&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">editImage</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        contentResolver.openFileDescriptor(selectedtmageUri, <span class="string">&quot;w&quot;</span>)?.use &#123;</span><br><span class="line">            setGrayscaleFilter(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (securityException: SecurityException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSIN.SDK_INT &gt;= Build.VERSION_CDDES.Q) &#123;</span><br><span class="line">            <span class="keyword">val</span> recoverableSecurityException = securityException <span class="keyword">as</span>? RecoverableSecurityException ?: <span class="keyword">throw</span> securityException</span><br><span class="line">            <span class="keyword">val</span> intentSender = recoverableSecurityException.userAction.actionIntent.intentSender</span><br><span class="line"></span><br><span class="line">            intenSender?.let &#123;</span><br><span class="line">                startIntentSenderForResult(intentSender, EDIT_IMAGE_REQUEST, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> securityException</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>File management or Backup features need to approved in Play Console.</p>
</li>
</ol>
<h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><ol>
<li>Background Services =&gt; MediaBrowserServer(API 26)</li>
<li>WorkManager</li>
<li>Reduced use of SharedPreferences</li>
<li>Reorganized the app graph to perform less object instantiation in application’s onCreate()</li>
</ol>
<h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><p><code>AppTheme</code> =&gt; <code>Theme.MaterialComponents.Light</code> =&gt; <code>Theme.AppCompat.Light</code> =&gt; <code>Theme.Material.Light</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ColorInt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">getThemeColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@AttrRes</span> themeAttrld: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obtainStyledAttributes(</span><br><span class="line">        intArrayOf(themeAttrld)</span><br><span class="line">    ).use &#123;</span><br><span class="line">        it.getColor(<span class="number">0</span>, Color.MAGENTA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> themedContext = ContextThemeWrapper(context, R.style.ThemeOverlay_Owl_Blue)</span><br><span class="line"><span class="keyword">val</span> inflater = LayoutInflater.from(themedContext)</span><br><span class="line"><span class="keyword">val</span> view = inflater.inflate(...)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Use literal names, relavant to the value(brand_blue &gt; color_primary)</p>
</li>
<li><p>Name</p>
<p>  Theme.AppTheme.Blue</p>
<p>  Widget.AppTheme.Toolbar.Green</p>
<p>  StyleType.GroupName.SubGroupName.VariantName</p>
</li>
<li><p><del><code>&lt;View style=&quot;@style/Theme.AppTheme.Foo&quot; /&gt;</code></del></p>
</li>
<li><p>Files</p>
<ul>
<li>themes.xml: Themes and ThemeOverlays</li>
<li>types.xml: TextApperances, Text size dimens</li>
<li>styles.xml: Widget styles</li>
<li>dimens.xml, colors.xml, strings.xml</li>
</ul>
</li>
<li><p><code>?textApperanceHeandline1</code> &gt; <code>@style/TextApperance.MaterialComponts.Headline1</code></p>
</li>
</ul>
<h3 id="Permissions"><a href="#Permissions" class="headerlink" title="Permissions"></a>Permissions</h3><ul>
<li>Mimimum permissions</li>
<li>Request in context</li>
<li>Libraries</li>
<li>Mimimize localtion and background location</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>Android动态主题</title>
    <url>/2018/09/14/android-dynamic-theme/</url>
    <content><![CDATA[<p>2018年12月1日 更新Cyanea</p>
<p>不是给用户几个主题选择的多主题，而是可以让用户选择任意颜色，这让难度上了一档次，尤其是想用一种不那么侵入的方法实现的话。</p>
<p>从主题的实现来分，主要分依赖Android和自己动手。但这里按实现难度排序。</p>
<span id="more"></span>

<p>2018年12月1日 更新Cyanea</p>
<p>发现了<a href="https://github.com/jaredrummler/Cyanea">Cyanea</a>，也是可以动态颜色，黑科技，效果极佳，除了不仅需要代码还需要很多styles。</p>
<p>初步看了一下代码，它不像Aesthetic一样拦截View创建过程，而是拦截Resources的getColor和getColorStateLlist返回自定义颜色，并使用自定义的LayoutInflater，在View创建之后，使用反射给View的ColorStateList修改颜色。这样，一些直接着色很困难的View（说的就是TimePicker）也可以一并被着色。</p>
<p>好强啊。</p>
<p>【完】2018年12月1日 更新Cyanea</p>
<h2 id="幼儿园难度-着色次数少的动态主题"><a href="#幼儿园难度-着色次数少的动态主题" class="headerlink" title="幼儿园难度 - 着色次数少的动态主题"></a>幼儿园难度 - 着色次数少的动态主题</h2><p>像<code>网易云音乐</code>这种，除了标题栏有主题色外，用到主题色的地方基本没有。只需要判断一下颜色亮暗，修改一下标题栏图标色和背景色就可以啦。</p>
<p>优点：简单到做这种应用的开发者都用不着找资料</p>
<p>缺点：使用体验很一般</p>
<h2 id="简单难度-预设的多主题"><a href="#简单难度-预设的多主题" class="headerlink" title="简单难度 - 预设的多主题"></a>简单难度 - 预设的多主题</h2><p>这个也很容易，只需要把预设的主题放到<code>styles.xml</code>中，然后在<code>onCreate</code>的<code>super</code>前调用<code>setTheme</code>，让Android框架自己处理各种主题颜色即可。<a href="https://github.com/garretyoder/Colorful"><code>Colorful</code></a>就是这么做的，它的<code>styles.xml</code>中存放了很多很多预设颜色和它们的组合。</p>
<p>优点：</p>
<ul>
<li>简简单单</li>
<li>所有用到的地方都能着色（跟下一方案相比尤其重要）</li>
</ul>
<p>缺点：除了不能让用户随便选，没有缺点</p>
<h2 id="正常难度-手动着色的动态主题"><a href="#正常难度-手动着色的动态主题" class="headerlink" title="正常难度 - 手动着色的动态主题"></a>正常难度 - 手动着色的动态主题</h2><p>像<code>酷安</code>这种，对每个用到主题色的地方进行着色。</p>
<p>这里可以对需要用的主题色的<code>View</code>新建一个子类，创建时着色。<a href="https://github.com/afollestad/aesthetic"><code>Aesthetic</code></a>就是这么做的，而且它机智地使用了<code>LayoutInflaterCompat.setFactory2</code>来偷梁换柱，把每个<code>View</code>都换成可着色的子类。</p>
<p>优点：用户体验++<br>缺点</p>
<ul>
<li>实现复杂，现有的Library(<code>Aesthetic</code>)都有点问题。</li>
<li>有的<code>View</code>不能被正常着色，比如<code>CoordinatorLayout</code>跟它的子子孙孙们，有不少坑，有的还得反射才行。</li>
</ul>
<h2 id="老手难度-动态主题-主题包"><a href="#老手难度-动态主题-主题包" class="headerlink" title="老手难度 - 动态主题 + 主题包"></a>老手难度 - 动态主题 + 主题包</h2><p><code>Telegram</code>啦。它是自己动手，丰衣足食。</p>
<p>这种方案不仅可以自定义颜色，还可以使用别人的主题包。</p>
<p>有个现成的框架<code>Android-skin-support</code>，也是用<code>setFactory</code>实现的，不过没有用过，使用体验不知如何。</p>
<p>优点：用户体验#</p>
<p>缺点：</p>
<ul>
<li>主题包主要是给社交软件用的，而且不是必备功能，因此使用面较窄</li>
<li>实现起来很繁琐</li>
</ul>
<h2 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h2><p>要么应用很简单，要么只提供预设主题，否则想要实现动态主题，此时此刻并不轻松。没有现成的壮硕的Library能用，意味着自己的造轮子。比如<code>Aesthetic</code>现在还有一大堆Bug。</p>
<h2 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h2><p>我倾向于将夜间模式和主题分开，两者互不影响。</p>
<p>夜间模式也有两种实现方式：</p>
<ol>
<li>同样使用<code>setTheme</code>，把什么<code>windowBackground</code>都手动设置。</li>
<li>推荐的是技能<code>DayNight</code>style，并使用<code>AppCompatDelegate.setDefaultNightMode</code>调用<code>res-night</code>下的资源，基本上属于support library白给的夜间主题。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android切换RecyclerView的Item布局(Expandable RecyclerView?)</title>
    <url>/2018/10/26/android-expandable-recyclerview/</url>
    <content><![CDATA[<p>让一个RecyclerView中的一个Item有两种不同的布局，可以用来给Item赋予多个状态，当然也可以实现类似Expandable RecyclerView的效果。</p>
<span id="more"></span>

<p>诀窍在于<code>notifyItemChanged</code>的时候，如果<code>getItemViewType</code>返回了不同的值，<code>onCreateViewHolder</code>就会被再次调用，这时新建一个新的ViewHolder就可以啦。</p>
<p>用实现一个Expandable RecyclerView来举例子：</p>
<ol>
<li><p>首先要使用不同的ViewType：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemViewType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isExpanded() ? ExpandedAlarmViewHolder.VIEW_TYPE : CollapsedAlarmViewHolder.VIEW_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>要让第一种ViewHolder变成第二种，要在点击了第一种ViewHolder中的一个Button或其他，触发展开事件：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isExpanded()) &#123;</span><br><span class="line">        mExpanded = <span class="literal">true</span>;</span><br><span class="line">        notifyItemChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>onCreateViewHolder</code>中根据不同的ViewType创建不同的ViewHolder</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ItemViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ItemViewHolder.<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> mFactoriesByViewType.get(viewType);</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.createViewHolder(parent, viewType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported view type: &quot;</span> + viewType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里也可以不用factory，直接判断<code>viewType</code>。</p>
</li>
<li><p>TaDa，完成。其实这篇文章最重要的就是第二句话。</p>
</li>
</ol>
<p>来源：AOSP的DeskClock</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android上一个简单的Feature Flag实现</title>
    <url>/2020/04/21/android-feature-flags/</url>
    <content><![CDATA[<p>起因是看了Jeroen Mols大佬的<a href="https://jeroenmols.com/blog/2019/08/13/featureflags/">Feature Flags</a>系列，深受启发。在看了代码后，萌生了写一个适合自己的Feature Flag框架。现在整出来了，但发现使用场景有点局限😂，所以把代码丢在这里以备不时之需。</p>
<span id="more"></span>

<p>我个人的需求没原文中那么复杂，只需要一个可以在代码里手动调整的开关，一个可以在运行时进行修改的面板，同时要让R8把未使用的所有代码剔除。</p>
<p>首先是可以在代码里手动调整的开关，用<code>buildConfigField</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            buildConfigField &quot;boolean&quot;, &quot;FEATURE_FLAG&quot;, &quot;Boolean.parseBoolean(\&quot;true\&quot;)&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField &quot;boolean&quot;, &quot;FEATURE_FLAG&quot;, &quot;false&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&quot;Boolean.parseBoolean(\&quot;true\&quot;)&quot;</code>确保IDE不会警告，就像<code>BuildConfig.DEBUG</code>一样。</li>
</ul>
<p>整个框架，抄了就走：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Feature</span>(</span><br><span class="line">    <span class="keyword">val</span> key: String,</span><br><span class="line">    <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">val</span> description: String,</span><br><span class="line">    <span class="keyword">val</span> default: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">) &#123;</span><br><span class="line">    Log(</span><br><span class="line">        key = <span class="string">&quot;feature_log&quot;</span>,</span><br><span class="line">        title = <span class="string">&quot;Log&quot;</span>,</span><br><span class="line">        description = <span class="string">&quot;All log to console&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    Network(</span><br><span class="line">        key = <span class="string">&quot;feature_network&quot;</span>,</span><br><span class="line">        title = <span class="string">&quot;Network&quot;</span>,</span><br><span class="line">        description = <span class="string">&quot;Inspect network requests&quot;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> FeatureFlagManager &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sharedPreferences: SharedPreferences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BuildConfig.FEATURE_FLAG) <span class="keyword">return</span></span><br><span class="line">        sharedPreferences = context.safeSharedPreference</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If we pass a value directly, this method won&#x27;t get removed by R8.</span></span><br><span class="line"><span class="comment">     * Passing a lambda does the job.</span></span><br><span class="line"><span class="comment">     * I learn this at https://youtu.be/MYQWtNG2so8?t=362</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isFeatureEnabled</span><span class="params">(f: () -&gt; <span class="type">Feature</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BuildConfig.FEATURE_FLAG) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> f.invoke().enabled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">manageFeatures</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BuildConfig.FEATURE_FLAG) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> features = Feature.values()</span><br><span class="line">        MaterialAlertDialogBuilder(context)</span><br><span class="line">            .setCancelable(<span class="literal">false</span>)</span><br><span class="line">            .setTitle(<span class="string">&quot;Feature Flag Manager&quot;</span>)</span><br><span class="line">            .setAdapter(</span><br><span class="line">                <span class="keyword">object</span> : BaseAdapter() &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = features.size</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(position: <span class="type">Int</span>)</span></span>: Any = features[position]</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemId</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Long</span> =</span><br><span class="line">                        features[position].ordinal.toLong()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                        position: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        convertView: <span class="type">View</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">                        parent: <span class="type">ViewGroup</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    )</span></span>: View &#123;</span><br><span class="line">                        <span class="keyword">val</span> view = convertView ?: LayoutInflater.from(context)</span><br><span class="line">                            .inflate(R.layout.list_item_feature_flag, parent, <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">val</span> layout = view.findViewById&lt;ListItemWithLayout&gt;(R.id.listItemFeatureFlag)</span><br><span class="line">                        <span class="keyword">val</span> feature = features[position]</span><br><span class="line">                        layout.listItem.run &#123;</span><br><span class="line">                            setPrimaryText(feature.title)</span><br><span class="line">                            setSecondaryText(feature.description)</span><br><span class="line">                        &#125;</span><br><span class="line">                        layout.getLayoutView&lt;CompoundButton&gt;().run &#123;</span><br><span class="line">                            setOnCheckedChangeListener(<span class="literal">null</span>)</span><br><span class="line">                            isChecked = feature.enabled</span><br><span class="line">                            setOnCheckedChangeListener &#123; buttonView, isChecked -&gt;</span><br><span class="line">                                feature.enabled = isChecked</span><br><span class="line">                                buttonView.indefiniteSnackbar(</span><br><span class="line">                                    message = <span class="string">&quot;Restart the app&quot;</span>,</span><br><span class="line">                                    actionText = <span class="string">&quot;Now&quot;</span>,</span><br><span class="line">                                    action = &#123;</span><br><span class="line">                                        ProcessPhoenix.triggerRebirth(context)</span><br><span class="line">                                    &#125;</span><br><span class="line">                                )</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> view</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">null</span></span><br><span class="line">            )</span><br><span class="line">            .setPositiveButton(android.R.string.ok, <span class="literal">null</span>)</span><br><span class="line">            .setNegativeButton(android.R.string.cancel, <span class="literal">null</span>)</span><br><span class="line">            .show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> Feature.enabled</span><br><span class="line">        <span class="keyword">get</span>() = sharedPreferences.getBoolean(key, default)</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            sharedPreferences.storeBoolean(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">FeatureFlagManager.<span class="keyword">init</span>(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">if</span> (FeatureFlagManager.isFeatureEnabled &#123; Feature.Log &#125;) &#123;</span><br><span class="line">    Timber.plant(Timber.DebugTree())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运作原理：</p>
<ul>
<li><p><code>isFeatureEnabled</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * If we pass a value directly, this method won&#x27;t get removed by R8.</span></span><br><span class="line"><span class="comment">    * Passing a lambda does the job.</span></span><br><span class="line"><span class="comment">    * I learn this at https://youtu.be/MYQWtNG2so8?t=362</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isFeatureEnabled</span><span class="params">(f: () -&gt; <span class="type">Feature</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!BuildConfig.FEATURE_FLAG) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> f.invoke().enabled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义，传Lambda而不是直接传Feature确保R8可以在这段代码没被使用时移除掉它，不然Feature会留在最终的APK里。</p>
<p>担心性能问题？</p>
<ul>
<li>我没做Benchkmark，所以不考虑优化。</li>
<li>我寻思以大部分应用的水平，这个Lambda根本不在瓶颈上。</li>
<li>请信任智能的R8，人家比咱上心，也比咱厉害，也许人家已经搞定了。</li>
<li>Romain Guy大佬怎么做，我就怎么做！</li>
</ul>
</li>
<li><p><code>setAdapter</code></p>
<p>之所以使用<code>AlertDialog</code>的<code>setAdapter</code>而不是自定义<code>View</code>，是因为这样可以让列表滚动时在顶端和底端有一个分割线，我挺喜欢这个设计，但缺点就是要处理<code>ListView</code>😢</p>
</li>
<li><p><code>ListView</code>的每个条目的命名<code>R.layout.list_item_feature_flag</code></p>
<p>我之前用的是<code>R.layout.item_feature_flag</code>，但发现R8在把整个<code>Feature</code>移除后死活不把这个文件处理掉，查看<code>resources.txt</code>并研究后才发现，所有以<code>item</code>开头的资源，都不会被处理（当然还有其它各种开头，<a href="https://android.googlesource.com/platform/tools/base/+/master/build-system/gradle-core/src/main/groovy/com/android/build/gradle/tasks/ResourceUsageAnalyzer.java#827">具体在这里</a>）。修改为<code>list</code>开头后就好了，虽然文件还在，但里面的内容已经没了。</p>
<p>另一种方法是根据<a href="https://developer.android.com/studio/build/shrink-code.html#troubleshoot-resource-shrink">官方文档底部的方法</a>来确保这些文件被移除。我懒，所以没试这种方法。</p>
</li>
<li><p><code>getView</code>绑定</p>
<p> <code>ListItemWithLayout</code>就是一个<code>CompoundButton</code>配一个<code>TextView</code>，不稀奇。包括其他的一些方法，都是简单包装了一下，顾名思义。</p>
</li>
<li><p><code>ProcessPhoenix.triggerRebirth(context)</code></p>
<p> 我这里用<a href="https://github.com/JakeWharton/ProcessPhoenix">ProcessPhoenix</a>来强制重启，但它有点Bug，需要你在启动的<code>Activity</code>加一个category：<code>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</code>。</p>
<p> 我也找了一下<code>chromium</code>是怎么重启的，发现人家使用JNI重启进程，我寻思有没有谁来打包成一个库呀？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android故障艺术</title>
    <url>/2019/06/05/android-glitch/</url>
    <content><![CDATA[<p><strong>2020年10月16日更新：增加了更多资料</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Glitch_art">Glitch art (故障艺术)</a>，第一见的时候被吓到了，但之后越看越上瘾。</p>
<p>这篇笔记记录怎么在Andorid上用代码实现这玩意儿。</p>
<span id="more"></span>

<h2 id="不停抖动View"><a href="#不停抖动View" class="headerlink" title="不停抖动View"></a>不停抖动View</h2><p>最简单的方案，通过叠加很多View，然后让它们各自向各个方向一直移动，就可以创建出类似于某音Logo的效果。</p>
<p>现成的：<a href="https://github.com/irshuLx/Android-Glitch-Text-Effect">Android-Glitch-Text-Effect</a>。</p>
<h2 id="随机修改JPEG"><a href="#随机修改JPEG" class="headerlink" title="随机修改JPEG"></a>随机修改JPEG</h2><p>这个也简单。<a href="https://github.com/BoD/aLibGlitch">aLibGlitch</a>就是这么做的。因为JPEG的压缩算法，只需要简单地替换一些bit，就可以让图片崩坏地很厉害。</p>
<p><a href="https://github.com/shubhamvernekar/SlideToGlitch">SlideToGlitch</a>是另外一个有类似算法的项目。受到了<a href="https://github.com/snorpey/jpg-glitch">jpg-glitch</a>这个web项目的启发。</p>
<p>这个可以作为应用内的一个转场动画，如果不担心被吓到的用户打差评的话。</p>
<h2 id="对画布进行各种变换"><a href="#对画布进行各种变换" class="headerlink" title="对画布进行各种变换"></a>对画布进行各种变换</h2><p>在 <a href="https://github.com/chemickypes/Glitchy/blob/master/glitch/src/main/java/me/bemind/glitch/Glitcher.kt">https://github.com/chemickypes/Glitchy/blob/master/glitch/src/main/java/me/bemind/glitch/Glitcher.kt</a> 考古到了几个变换Canvas的方法。没什么特殊的地方，就是发挥奇思妙想对Canvas进行各种修改。</p>
<details>
  <summary></summary>
  <p>这个项目的代码是真的看得我头大。</p>
</details>

<h2 id="对像素点进行各种变化"><a href="#对像素点进行各种变化" class="headerlink" title="对像素点进行各种变化"></a>对像素点进行各种变化</h2><p>在 <a href="https://github.com/g-whiz/pxSort">https://github.com/g-whiz/pxSort</a> 考古到了一些操作像素点的方法。应该是有数学公式之类在背后支撑的，但无奈它产出的效果不合我意，就懒得找了。注意各个效果的参数是在assets里的数据库里的。</p>
<h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p>最近发现了<a href="https://zhuanlan.zhihu.com/p/148256756">高品质后处理：十种故障艺术(Glitch Art)算法的总结与实现</a>，是针对Unity的各种故障效果，是通过OpenGL实现的。Android也支持OpenGL，懂OpenGL的可以手动把代码复制修改后使用。拿最简单的RGB Split Glitch来说，在搭配<a href="https://github.com/cats-oss/android-gpuimage">android-gpuimage</a>后，只需要改几个名称就可以放到应用里了。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>Android Internal 笔记</title>
    <url>/2018/05/12/android-internal/</url>
    <content><![CDATA[<p>之前不知在哪里看到Android开发者都应该了解一下Android Internal，就截了图记了下来。现在有时间了，就找了一些Android Internal的内容，记了些笔记。相应的资料也列在了各个章节末尾。</p>
<p><strong>不是很全，不保证全对，不保证维护</strong></p>
<h2 id="基于Linux内核的Android"><a href="#基于Linux内核的Android" class="headerlink" title="基于Linux内核的Android"></a>基于Linux内核的Android</h2><p>Android之所以享誉盛名，是因为在Linux内核基础上已改的面目全非。。就是为了适应手机那小内存、差CPU、续航是问题等的特点。Android不是一个Linux的发行版。</p>
<span id="more"></span>

<ul>
<li><p>优化后的OOM(Out of Memory) Killer</p>
<p>  给每个进程加了<code>oom_adj</code>的优先值，把不同进程分到不同的级别中(Foreground Processes, Visible Processes, Service Process, Background Process)，内存不够时先杀值大（优先级低）的进程。</p>
</li>
<li><p>WakeLocks</p>
<p>  保活CPU(+ 屏幕)的工具。本来是让应用更好地工作，结果成了流氓应用的工具。现在这玩意儿很多时候也不好使了。</p>
</li>
<li><p><code>init</code>和<code>zygote</code></p>
<p>  用来启动各种<code>deamon</code>，比如<code>adbd</code>, <code>logd</code>, <code>zygote</code>。</p>
<p>  <code>zygote</code>会经常在日志底部中出现。默认的<code>fork()</code>速度慢，所以它是一个快捷进程+<code>deamon</code>，用于快速启动应用。</p>
</li>
<li><p>Binder IPC</p>
<p>  处于安全考虑，每个应用被对待成Linux不同不用户，拥有不同的<code>uid</code>。</p>
<p>  IPC(Inter-Process Communication)：跨进程通信。</p>
<p>  例如<code>Intent</code>通信，可以在不同组件中异步交换数据；又如<code>ContentProvider</code>，可以在不同应用中交换数据。它们都默认在<code>MainThread</code>的<code>Looper</code>中运行。</p>
</li>
<li><p>Managers</p>
<p>  系统服务，管理系统资源</p>
<ul>
<li><code>WindowManager</code>：负责窗口、动画等。</li>
<li><code>PackageManager</code>：查询<code>Manifest.xml</code>，解析包名。</li>
<li><code>ActivityManager</code>：负责<code>lifecycle</code>、各种组件、电量、<code>configuration changes</code>。（根据个人经验，冻结应用也涉及它）<br>创建<code>Stack</code>，里面放<code>Task</code>，里面放<code>Activity</code>的索引。每个应用在单独的线程中。</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ol>
<li><a href="https://android.jlelse.eu/android-internals-for-developers-part-i-982a4409f4b5">Android Internals For Developers : Part I</a></li>
<li><a href="https://android.jlelse.eu/android-internals-for-developers-part-ii-c6ca94243efa">Android Internals for Developers: Part II</a></li>
<li><a href="https://academy.realm.io/posts/360-andev-2017-effie-barak-android-internals/">Android Internals</a></li>
</ol>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>这是Android自己的消息传递机制。不同线程通过和Handler交流、传递信息。日常开发中主要用于异步。使用不当会造成严重的内存泄漏。</p>
<p>每一个Handler都一个Looper和Message Queue。在创建Handler是有两个构造函数，无参的是新建一个在当前线程的Handler，有参的指定一个Looper。而Looper可以操作Message Queue，因此是必须的。不同Handler可以共享一个Looper，它们的Message Queue跟随Looper，也共享一个。</p>
<ul>
<li><p>Message</p>
<p>  数据的包装类，被发送给Message Queue。Message从消息池（最大有50个）中取出再使用，所以就会有</p>
<p>  <code>mHandler.obtainMessage(MSG_SHOW_IMAGE, mBitmap).sendToTarget();</code></p>
<p>  每一个Message都有一个<code>target</code>，类型是Handler。上面一行默认把会把<code>target</code>设置为自己。</p>
</li>
<li><p>Message Queue</p>
<p>  链表，存放需要实现的Message。根据<code>SystemClock.uptimeMillis()</code>和时间戳来判断该执行什么。</p>
<p>  Android也用几个自用的Handler，也是使用了Main Looper:</p>
<ul>
<li>Choreographer：处理垂直同步和帧刷新。好像有个Library就是用这个显示当前屏幕的帧数。</li>
<li>ViewRoot: 处理输入、窗口事件、Configuration Changes等</li>
<li>InputMethodManager: 处理键盘输入。LeakCanary经常提示我它泄露了。。</li>
<li>等等等等</li>
</ul>
</li>
<li><p>Looper</p>
<p>  <code>Thread</code>默认运行完就结束，想要让线程一直留着，等着以后接着用，就需要Looper来“保活”。<br>  它也负责从Message Queue中取消息，指派给Handler。一个线程一个Looper一个Message Queue若干Handler。</p>
<p>  <code>Looper.prepare()</code>: 确保当前线程和Looper已配对。</p>
<p>  <code>Looper.loop()</code>: 开始处理Message Queue中的Message。实现里有个<code>for (;;) &#123;</code>的无限循环。稍微研究了一下，没有消息时，非常粗暴地使用CPU一直等待。</p>
<p>  为了方便，异步时不手动Looper + 线程，而用更方便的<code>HandlerThread</code>，继承自<code>Thread</code>，处理了<code>Looper</code>的工作。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerThread handlerThread;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate();</span><br><span class="line">    handlerThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;HandlerDemo&quot;</span>);</span><br><span class="line">    handlerThread.start();</span><br><span class="line">    handler = <span class="keyword">new</span> <span class="title class_">CustomHandler</span>(handlerThread.getLooper());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    handlerThread.quit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考:</p>
<ol>
<li><a href="https://medium.com/@jagsaund/android-handler-internals-b5d49eba6977">Android Handler Internals</a></li>
<li><a href="https://medium.com/@yossisegev/understanding-activity-runonuithread-e102d388fe93">Understanding Activity.runOnUiThread()</a></li>
</ol>
<h2 id="Storage储存"><a href="#Storage储存" class="headerlink" title="Storage储存"></a>Storage储存</h2><h3 id="Internal-Storage-内部储存"><a href="#Internal-Storage-内部储存" class="headerlink" title="Internal Storage 内部储存"></a>Internal Storage 内部储存</h3><p>是在应用私有的一个储存空间，存放了<code>SharedPreferences</code>、数据库等文件。其他应用和用户在没有root和找到漏洞前无法访问。在实现上，就是分配各每个应用的一个文件夹。</p>
<p>位置在<code>/data/data/package-name/</code>(不一定总是这个路径，经常变)。</p>
<p><code>files</code>文件夹：通过<code>Context.getFilesDir()</code>来获取路径，所以创建文件时的姿势应为<code>val f = File(getFilesDir(), &quot;foo.txt&quot;)</code></p>
<p>Android 3.0及以后，内部储存的空间大大增加。几乎所有不需要让用户和其他应用使用的数据，都应该放在内部储存中。</p>
<p>要想共享内部储存中的数据，使用<code>FileProvider</code>和<code>ContentProvider</code>，给每个<code>Uri</code>都赋予权限，安全且统一。</p>
<h3 id="External-Storage-外部储存"><a href="#External-Storage-外部储存" class="headerlink" title="External Storage 外部储存"></a>External Storage 外部储存</h3><p>位于<code>/sdcard/</code>(不一定总是这个路径，经常变)下的内容，文件浏览中看到的东西。也包括SD卡中的内容。但现在很多手机都不支持SD卡了，自带的管够。</p>
<p>读写需要权限。<br>正常情况下用<code>Environment.getExternalStorageDirectory()</code>访问。但多数情况下应使用<code>Context.getExternalFilesDir()</code>来获取<code>/sdcard/Android/data/package-name/files/</code>下应用各自的位置。</p>
<p>参考</p>
<ol>
<li><a href="https://commonsware.com/blog/2017/11/13/storage-situation-internal-storage.html">The Storage Situation: Internal Storage</a></li>
<li><a href="https://commonsware.com/blog/2017/11/14/storage-situation-external-storage.html">The Storage Situation: External Storage</a></li>
</ol>
<h2 id="Proguard"><a href="#Proguard" class="headerlink" title="Proguard"></a>Proguard</h2><p>流程：</p>
<ol>
<li>Read config(proguard-rules.pro)</li>
<li>Finding Seeds =&gt; seeds.txt =&gt; Entry points</li>
<li>Shrinking =&gt; usage.txt =&gt; Removed codes</li>
<li>Obfuscation =&gt; mapping.txt</li>
<li>Dump =&gt; dump.txt</li>
<li>Write Classes =&gt; .class</li>
</ol>
<p>aapt会根据Manifest给应用项目自动生成各种各样的keep rules。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.youtube.com/watch?v=F9ymcWoDEtc">How Proguard Works</a></li>
<li><a href="https://www.youtube.com/watch?v=x9T5EYE-QWQ">Effective ProGuard keep rules for smaller applications (Google I/O ‘18)</a></li>
</ol>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>分割为Pages，每页4KB。类型有Used Pages, Cached Pages, Free Pages.</p>
<p>减小内存使用的方法：</p>
<ol>
<li>使用Memory Profile, 查看java heap, app heap</li>
<li>减小APK大小</li>
</ol>
<p>参考：</p>
<ol>
<li><a href="https://www.youtube.com/watch?v=w7K0jio8afM">Understanding Android memory usage (Google I/O ‘18)</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>一些Android开发死局</title>
    <url>/2022/06/26/android-forbidden-topics/</url>
    <content><![CDATA[<p>有些东西就是做不到，除非，加很多很多钱和时间。</p>
<p>一些V2EX帖子整理。</p>
<span id="more"></span>

<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><ul>
<li><a href="https://www.v2ex.com/t/802359">问下安卓如何防止 root 下抓包， app 接口请求并没有做加密措施</a></li>
<li><a href="https://www.v2ex.com/t/806211">怎么防止用户自己调用网站 API 发送 POST 请求篡改数据</a></li>
<li><a href="https://www.v2ex.com/t/842130">如何对 Android APP 抓取 HTTPS 包？</a></li>
<li><a href="https://lxnchan.cn/app-package-grab.html">APP抓包研究</a></li>
</ul>
<p>TL;DR: 功夫不负有心人。没有彻底的办法。最好的办法永远是在服务端控制数据。</p>
<p>如果能用Firebase的话，可以第三方接入AppCheck来防止中间人。</p>
<p>一些精彩发言：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kings0527</span><br><span class="line"></span><br><span class="line">永远无法防止</span><br><span class="line">只能提高门槛</span><br><span class="line">https 仅仅防止中间人</span><br><span class="line">证书信任 仅仅防止不会过 ssl pinning 的人</span><br><span class="line">证书校验 仅仅防止没有逆向能力的人</span><br><span class="line">参数加密 仅仅防止逆向能力很低的人</span><br><span class="line">自写协议 仅仅防止逆向能力不高的人</span><br><span class="line"></span><br><span class="line">所以 看情况 看成本 加策略</span><br><span class="line">不要为了防止抓包而防止抓包</span><br><span class="line">应该是 你为什么要防止抓包？？？</span><br><span class="line"></span><br><span class="line">防爬虫？？？那可以加请求频率限制 可以加风险等级评估</span><br><span class="line">比如是不是正常用户？？？？是不是正常手机？？？是不是正常操作流程？？？</span><br><span class="line"></span><br><span class="line">防攻击？？？</span><br><span class="line">那可以加 web 防火墙 可以提高自己 router 容错率</span><br><span class="line"></span><br><span class="line">防刷推广安装量？？？</span><br><span class="line">加溯源 加留存 加异常打点 建数据模型观察</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">icyalala</span><br><span class="line"></span><br><span class="line">ssl pinning (也就是客户端内置证书) 来防止初级的抓包</span><br><span class="line">参数签名+客户端防逆向</span><br><span class="line">服务端风控，这是最主要的</span><br><span class="line">根据我待过的几个公司的经验，就算大厂也基本就是这些了</span><br><span class="line">整体来说就是增加成本降低风险，完全避免是不可能</span><br></pre></td></tr></table></figure>

<h3 id="客户端的挣扎"><a href="#客户端的挣扎" class="headerlink" title="客户端的挣扎"></a>客户端的挣扎</h3><p>有证书就可以抓包。</p>
<p>Root后在任何API版本都可以装任何证书。</p>
<p>Android N（API 24）及之后，应用才可以强制只信任系统证书。之前可以不Root装用户证书。</p>
<p>据说iPhone装证书很容易。</p>
<p>搬起石头砸自己的脚的办法：</p>
<ul>
<li><p>禁止代理 <code>connection = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY)</code></p>
<ul>
<li>容易绕过（路由器抓包、开热点抓包）</li>
<li>谁还用<code>HttpURLConnection</code>呀，不适合现代应用</li>
</ul>
</li>
<li><p>检测Root</p>
<ul>
<li>容易绕过</li>
<li>可能检测错误</li>
<li>牺牲无辜的Root用户的体验</li>
</ul>
</li>
<li><p>自定义证书、SSL Pinning</p>
<ul>
<li>Android N及之后才可以强制证书</li>
<li>复杂</li>
</ul>
</li>
</ul>
<h2 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h2><ul>
<li><a href="https://www.v2ex.com/t/861328">安卓 MQTT 客户端如何保证 Service 一直运行在后台？</a></li>
</ul>
<p>终极方案：</p>
<ul>
<li>成为系统应用</li>
<li>成为国民应用，厂商会主动增加白名单</li>
<li>使用FCM（不适用于中国大陆）</li>
</ul>
<p>现在已经没有更多奇技淫巧了。虽然一直有人声称有黑科技，但从未亲眼见过。</p>
<p>Foreground Service + Wake Lock是普通应用唯二能做的。此外可以多接入一些推送。</p>
<p>最后，也是最重要的一步，引导用户设置应用白名单，这样基本可以确保正常使用。</p>
<h2 id="个人开发者-海外收款"><a href="#个人开发者-海外收款" class="headerlink" title="个人开发者 海外收款"></a>个人开发者 海外收款</h2><ul>
<li><a href="https://www.v2ex.com/t/801035">个人开发者如何进行海外收款？</a></li>
<li><a href="https://www.v2ex.com/t/847307">人在国内，钱在国外，如何消费？</a></li>
</ul>
<p>TL;DR: 需要八仙过海各自踩坑</p>
<p>有公司专人来解决这个问题最好了：</p>
<ul>
<li><a href="https://www.v2ex.com/t/859166">深圳注册公司的坑，一些经验分享（视频和文档）</a></li>
<li><a href="https://www.v2ex.com/t/747843">公司注册下来了，分享一下费用、流程以及遇到的坑</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android依赖笔记</title>
    <url>/2022/06/02/android-library-dependency/</url>
    <content><![CDATA[<p>整理自<a href="https://www.youtube.com/watch?v=lq3PL8bHIn4">The definitive guide to Android library development by Jeroen Mols, Plaid EN</a></p>
<span id="more"></span>

<ul>
<li><p>相比JAR（代码压缩包？），AAR还有Resources和Manifest，但二者都没有签名且不包括依赖。它们各自所需的依赖定义于pom文件中。</p>
</li>
<li><p>如果所需的依赖是本地文件，则需要方法来绕过限制：</p>
<ol>
<li>把依赖发布到Maven</li>
<li>FAR AAR插件</li>
<li>把依赖内容复制到Library中</li>
</ol>
</li>
<li><p>限制多个依赖间的内部类</p>
<ol>
<li><code>package com.example.internal.database</code></li>
<li>混淆为<code>package com.example.internal.a</code></li>
<li>把依赖内容复制到Library中</li>
</ol>
</li>
<li><p>Transitive Dependency及在pom文件中定义的依赖</p>
<p>  Grdle会默认选择所有版本最高的依赖。调整方法有</p>
<ol>
<li><p>忽略依赖的Transitive Dependency</p>
 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation (<span class="string">&#x27;com.example:library:1.0.0&#x27;</span>) &#123;</span><br><span class="line">    exclude <span class="attr">group:</span> <span class="string">&#x27;com.squareup.okhttp3&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;okhttp&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>全局指定依赖版本</p>
 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123;</span><br><span class="line">        force <span class="string">&#x27;com.squareup.okhttp3:okhttp:3.12.0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  这些方法可能会造成编译或运行时失败，尽量避免它们。</p>
</li>
<li><p>开发Library时，使用稳定版本（几个月到一两年）的依赖，最好不要更新。</p>
</li>
<li><p>在<code>res/values/public.xml</code>声明后，只是Android Studio不再自动补全了。</p>
<p>  要用：</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    resourcePrefix <span class="string">&#x27;mylib_&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  来限定名称空间。不过只是让Android Studio警告一下。</p>
</li>
<li><p>设置为必须声明Class Visibility</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs += <span class="string">&#x27;-Xexplicit-api=strict&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack Compose Stability白话版</title>
    <url>/2024/06/24/android-jetpack-compose-stability/</url>
    <content><![CDATA[<p>官方文档一边说不要过度优化，一边花了长长长的篇幅讲性能优化。</p>
<p>但优秀的开发者在点点滴滴中优化性能，而不是等到性能真出问题时再挠头。本文记录如何写Composable来得到最好的Stability。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>书写Composable或用于Composable参数的类时，优先考虑Primitive类型</li>
<li>把Android SDK、第三方依赖、其他Module的类放到<a href="https://developer.android.com/develop/ui/compose/performance/stability/fix#configuration-file">Stability configuration file</a>中</li>
</ul>
<span id="more"></span>

<h2 id="总是优先考虑Primitive类型"><a href="#总是优先考虑Primitive类型" class="headerlink" title="总是优先考虑Primitive类型"></a>总是优先考虑Primitive类型</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Tab</span> &#123; Home, Profile &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ScreenPrimitive</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    int: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    float: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    string: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    tab: <span class="type">Tab</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    lambda: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = <span class="string">&quot;<span class="variable">$int</span> <span class="variable">$float</span> <span class="variable">$string</span> <span class="variable">$tab</span>&quot;</span>,</span><br><span class="line">        modifier = modifier.clickable(onClick = lambda),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">restartable skippable scheme(&quot;[androidx.compose.ui.UiComposable]&quot;) fun ScreenPrimitive(</span><br><span class="line">  stable int: Int</span><br><span class="line">  stable float: Float</span><br><span class="line">  stable string: String</span><br><span class="line">  stable tab: Tab</span><br><span class="line">  stable lambda: Function0&lt;Unit&gt;</span><br><span class="line">  stable modifier: Modifier? = @static Companion</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>除了Primitive类型，字符串、枚举和Lambda也是没问题的，因为<strong>Jetpack Compose Compiler确定在创建它们后，内容无法变化</strong>。这一句话也是Stability的核心，并将在之后得到更多解释。</p>
<p>如果能用一些Primitive类型书写Composable是最好的，因为不仅Stable，还提高了复用度，但有时我们需要一个类，比如参数太多、需要特定功能、要一定抽象等，那么情况就不一样了。</p>
<h2 id="同一Module的类"><a href="#同一Module的类" class="headerlink" title="同一Module的类"></a>同一Module的类</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Screen</span>(</span><br><span class="line">    <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">val</span> time: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> tab: Tab,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ScreenInternalClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    screen: <span class="type">Screen</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = screen.run &#123; <span class="string">&quot;<span class="variable">$title</span> <span class="variable">$time</span> <span class="variable">$tab</span>&quot;</span> &#125;,</span><br><span class="line">        modifier = modifier,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">stable class Screen &#123;</span><br><span class="line">  stable val title: String</span><br><span class="line">  stable val time: Long</span><br><span class="line">  stable val tab: Tab</span><br><span class="line">  &lt;runtime stability&gt; = Stable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restartable skippable scheme(&quot;[androidx.compose.ui.UiComposable]&quot;) fun ScreenInternalClass(</span><br><span class="line">  stable screen: Screen</span><br><span class="line">  stable modifier: Modifier? = @static Companion</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果用到的类和Composable在同一个Module，且这个类的内容符合上述的全是Primitive类型，它也是没问题的。</p>
<p>Jetpack Compose之所以能得出这个结论，是<strong>因为<code>Screen</code>所在Module启用了Jetpack Compose Compiler</strong>。因为当前Module要用Jetpack Compose，所以Compiler早已启用了，于是从结果上来看，同一Module的只带Primitive类型的类是没问题的。这一点在下一点更为重要。</p>
<h2 id="不同Module的类"><a href="#不同Module的类" class="headerlink" title="不同Module的类"></a>不同Module的类</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个新建的Module中</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">ScreenFromLibrary</span>(</span><br><span class="line">    <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">val</span> time: <span class="built_in">Long</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个另外的Module中</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ScreenExternalClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    screen: <span class="type">ScreenFromLibrary</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = screen.run &#123; <span class="string">&quot;<span class="variable">$title</span> <span class="variable">$time</span>&quot;</span> &#125;,</span><br><span class="line">        modifier = modifier,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">restartable scheme(&quot;[androidx.compose.ui.UiComposable]&quot;) fun ScreenExternalClass(</span><br><span class="line">  unstable screen: ScreenFromLibrary</span><br><span class="line">  stable modifier: Modifier? = @static Companion</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这时有问题了。因为Jetpack Compose依赖于Jetpack Compose Compiler来推测一个类的Stability，而新建的Module没有启用Compiler，于是就<code>unstable</code>了。</p>
<p>解决方法有几个：</p>
<ul>
<li>使用<a href="https://developer.android.com/develop/ui/compose/performance/stability/fix#configuration-file">Stability configuration file</a></li>
<li>在新建的Module中配置好Jetpack Compose及其依赖，让其检测各种类型。缺点是要污染新建的Module的依赖。<ul>
<li>虽然也有第三方库来只引入少量依赖，但1. 第三方依赖越少越好。2. 大依赖小依赖都是污染。</li>
</ul>
</li>
</ul>
<h2 id="依赖中的类"><a href="#依赖中的类" class="headerlink" title="依赖中的类"></a>依赖中的类</h2><p>当参数来自于Android SDK或某个依赖时，又出问题了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ScreenSharedPreferences</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    sharedPreferences: <span class="type">SharedPreferences</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = sharedPreferences.getInt(<span class="string">&quot;key&quot;</span>, -<span class="number">1</span>).toString(),</span><br><span class="line">        modifier = modifier,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">restartable scheme(&quot;[androidx.compose.ui.UiComposable]&quot;) fun ScreenSharedPreferences(</span><br><span class="line">  unstable sharedPreferences: SharedPreferences</span><br><span class="line">  stable modifier: Modifier? = @static Companion</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>因为Jetpack Compose Compiler无法触及<code>SharedPreferences</code>所处的位置，Android SDK，所以其无法确定Stability。解决方法有三个：</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>和上文一样的使用<a href="https://developer.android.com/develop/ui/compose/performance/stability/fix#configuration-file">Stability configuration file</a>。</p>
<h3 id="二次包装"><a href="#二次包装" class="headerlink" title="二次包装"></a>二次包装</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">SharedPreferencesWrapper</span>(</span><br><span class="line">    <span class="keyword">val</span> sharedPreferences: SharedPreferences,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ScreenSharedPreferencesWrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    sharedPreferencesWrapper: <span class="type">SharedPreferencesWrapper</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = sharedPreferencesWrapper.sharedPreferences.getInt(<span class="string">&quot;key&quot;</span>, -<span class="number">1</span>).toString(),</span><br><span class="line">        modifier = modifier,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">stable class SharedPreferencesWrapper &#123;</span><br><span class="line">  unstable val sharedPreferences: SharedPreferences</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restartable skippable scheme(&quot;[androidx.compose.ui.UiComposable]&quot;) fun ScreenSharedPreferencesWrapper(</span><br><span class="line">  stable sharedPreferencesWrapper: SharedPreferencesWrapper</span><br><span class="line">  stable modifier: Modifier? = @static Companion</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>@Immutable</code>告诉Compiler：凡是跟我混的，都别管，懂了没！</p>
<h3 id="打开Strong-Skipping-Mode"><a href="#打开Strong-Skipping-Mode" class="headerlink" title="打开Strong Skipping Mode"></a>打开Strong Skipping Mode</h3><p>Jetpack Compose面对Stable类型，通过<code>==</code>来决定是否触发Recomposition，面对Unstable类型，总是触发Recomposition。打开<a href="https://developer.android.com/develop/ui/compose/performance/stability/strongskipping">Strong skipping mode</a>后，面对Unstable类型，使用<code>===</code>来决定是否触发Recomposition。因为<code>SharedPreferences</code>通常是Singleton，那么这个方法可以避免多余的Recomposition。</p>
<p>但是1. 这并不会让开发者理解性能优化。2. 该选项会在未来默认打开。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ScreenList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = list.size.toString(),</span><br><span class="line">        modifier = modifier,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">restartable scheme(&quot;[androidx.compose.ui.UiComposable]&quot;) fun ScreenList(</span><br><span class="line">  unstable list: List&lt;Int&gt;</span><br><span class="line">  stable modifier: Modifier? = @static Companion</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>您猜怎么着，Unstable！原因是<code>List</code>的本质上可能是个<code>MutableList</code>（<code>val list: List&lt;Int&gt; = mutableListOf()</code>），属于创建后内容可以变化的类型。</p>
<p>解决方法有三个：</p>
<h3 id="又是配置文件"><a href="#又是配置文件" class="headerlink" title="又是配置文件"></a>又是配置文件</h3><p>同上。</p>
<h3 id="又是二次包装"><a href="#又是二次包装" class="headerlink" title="又是二次包装"></a>又是二次包装</h3><p>同上。</p>
<h3 id="Immutable-collections"><a href="#Immutable-collections" class="headerlink" title="Immutable collections"></a>Immutable collections</h3><p>Jetpack Compose Compiler给 <a href="https://developer.android.com/develop/ui/compose/performance/stability/fix#immutable-collections">Immutable collections</a> 偷偷开了绿灯。</p>
<p>但要注意<strong>列表中的类<code>ImmutableList&lt;StableClass&gt;</code>也要Stable</strong>。</p>
<h2 id="Stable"><a href="#Stable" class="headerlink" title="@Stable"></a>@Stable</h2><p>虽然是很重要的注释，会在类或接口中包含<code>mutableStateOf</code>时用到，但是我倾向于让Jetpack Compose只完成将数据转换为界面的任务。当不得不使用这个注释时，通常意味着UI代码职责不清晰，这才是更紧急的问题。</p>
<p>因此出于个人偏好，会避免使用该注释，同时这里也将不再讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>见开头。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>使用json-server模拟后台</title>
    <url>/2019/10/02/android-mock-server/</url>
    <content><![CDATA[<p>笔记。</p>
<span id="more"></span>

<p><a href="https://github.com/typicode/json-server">json-server</a></p>
<ol>
<li><p><code>yarn global add json-server</code></p>
</li>
<li><p><code>json-server --watch db.json --port 80 --host $ip --routes routes.json</code></p>
<p> <code>db.json</code>: 数据文件</p>
<p> <code>$ip</code>: 本地IP，好让手机连接。一般是机器的IP。</p>
<p> <code>routes.json</code>: 似乎默认只能单路径，使用这个支持子路径</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>Android多进程开发笔记</title>
    <url>/2024/06/23/android-multiprocessing/</url>
    <content><![CDATA[<p>RT</p>
<span id="more"></span>

<ul>
<li><p><a href="https://x.com/oasisfeng/status/1633822931523612676">把需要长期后台运行的服务放到单独的进程中来降低被杀几率</a></p>
</li>
<li><p>通过<a href="https://developer.android.com/guide/topics/manifest/service-element#proc"><code>android:process=&quot;:process&quot;</code></a>指定运行于新的进程</p>
</li>
<li><p>自定义的<code>Application</code>（<code>android:name=&quot;.App&quot;</code>）会被每个进程运行一次</p>
<p>应在自定义的<code>Application</code>中提前考虑多进程使用：</p>
<ol>
<li>在<code>Application</code>判断进程名，按需初始化组件<ul>
<li><a href="https://stackoverflow.com/a/55842542/5507158">Is there a way to get current process name in Android</a></li>
</ul>
</li>
<li>将组件放到<code>androidx.startup</code>中并手动初始化</li>
</ol>
</li>
<li><p><code>SharedPreference</code>无法跨进程使用，因此<a href="https://developer.android.com/topic/libraries/architecture/datastore#multiprocess">Use DataStore in multi-process code</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>简单的Android软键盘动画</title>
    <url>/2021/05/28/android-naive-keyboard-animation/</url>
    <content><![CDATA[<p>随着<code>androidx.core</code>1.5.0的发布，我终于搞明白全屏、WindowInsets这些问题了。</p>
<p><strong>2021年7月7日 更新收起键盘时闪烁问题的临时解决办法</strong></p>
<span id="more"></span>

<ol>
<li><p>设置<code>windowSoftInputMode</code></p>
<p> 给Activity增加 <code>android:windowSoftInputMode=&quot;adjustResize&quot;</code></p>
<p> 根据<a href="https://developer.android.com/training/keyboard-input/visibility#Respond">官方文档</a>：</p>
<blockquote>
<p>To ensure the best behavior for your app, you should specify how you’d like the system to display your UI in the remaining space.</p>
</blockquote>
<p> 而且不同的系统版本，默认的行为不同，所以这里加一个确保行为一致。</p>
<p> 根据<a href="https://developer.android.com/training/keyboard-input/visibility#ShowOnStart">官方文档</a>，还可以加一个<code>stateHidden</code>来避免在一些系统版本上一打开Activity，软键盘就弹出的问题。</p>
</li>
<li><p>全屏/让内容显示在系统界面之后</p>
<p> <code>WindowCompat.setDecorFitsSystemWindows(window, false)</code></p>
</li>
<li><p>透明状态栏和导航栏</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">window.run &#123;</span><br><span class="line">    statusBarColor = Color.TRANSPARENT</span><br><span class="line">    navigationBarColor = Color.TRANSPARENT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 更完美的颜色参照<a href="https://medium.com/androiddevelopers/gesture-navigation-going-edge-to-edge-812f62e4e83e">Gesture Navigation: going edge-to-edge (I)</a>。</p>
</li>
<li><p>避免View和系统界面重叠</p>
<p> 如果顶部是<code>AppBarLayout</code>，就增加一个<code>android:fitsSystemWindows=&quot;true&quot;</code>来让它自己处理顶部。底部也可以用默认处理，但通常效果不理想。</p>
<p> 如果是普通View：</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ViewCompat.setOnApplyWindowInsetsListener(binding.root) &#123; v, insets -&gt;</span><br><span class="line">    <span class="keyword">val</span> bottomInsets = insets.getInsets(</span><br><span class="line">        WindowInsetsCompat.Type.systemBars() or WindowInsetsCompat.Type.ime()</span><br><span class="line">    )</span><br><span class="line">    v.updatePadding(bottom = bottomInsets.bottom)</span><br><span class="line">    <span class="keyword">val</span> keyboardShown = insets.isVisible(WindowInsetsCompat.Type.ime())</span><br><span class="line">    insets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里也是检测键盘是否弹出的地方。</li>
<li>在键盘弹出时，导航栏高度算在软键盘高度的一部分中的。</li>
<li>在下一步增加动画前，在这里先确保应用可以正常显示。</li>
</ul>
</li>
<li><p>增加动画</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ViewCompat.setWindowInsetsAnimationCallback(</span><br><span class="line">    binding.root,</span><br><span class="line">    <span class="keyword">object</span> : WindowInsetsAnimationCompat.Callback(DISPATCH_MODE_STOP) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            insets: <span class="type">WindowInsetsCompat</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            runningAnimations: <span class="type">MutableList</span>&lt;<span class="type">WindowInsetsAnimationCompat</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: WindowInsetsCompat &#123;</span><br><span class="line">            <span class="keyword">val</span> bottomInsets = insets.getInsets(</span><br><span class="line">                WindowInsetsCompat.Type.ime() or</span><br><span class="line">                    WindowInsetsCompat.Type.systemBars()</span><br><span class="line">            )</span><br><span class="line">            binding.root.updatePadding(bottom = bottomInsets.bottom)</span><br><span class="line">            <span class="keyword">return</span> insets</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 上述方法有一个问题，在收起键盘时，会闪烁一下。原因似乎是在<code>onPrepare</code>和<code>onStart</code>之间的，使用动画结束状态调用<code>OnApplyWindowInsetsListener</code>出了问题，但官方文档中提到了这之间是不会发生Layout的。另外根据官方示例使用<code>translationY</code>的话，是没有问题的。因此原因尚不明了。</p>
<p> 现在的一个临时解决方案是在，<code>onPrepare</code>中开启一个Flag，在<code>onEnd</code>中关闭，然后在<code>OnApplyWindowInsetsListener</code>中，如果Flag开启，就不应用Padding。</p>
</li>
<li><p>其他考虑</p>
<ul>
<li>如果要显示Snackbar，需要额外测试。Padding可能不是最好的方法，可能需要Margin或额外的<code>Space</code> View。</li>
<li>显示软键盘，似乎<a href="https://developer.squareup.com/blog/showing-the-android-keyboard-reliably/">Showing the Android Keyboard Reliably</a>比<code>WindowInsetsController</code>处理的情况更多且更好用。关闭的话，<code>WindowInsetsController</code>就可以。</li>
<li>去开发者选项中把动画速度调成10倍，不然根本看不清楚效果。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>一些关于Dagger2及其未来的思考</title>
    <url>/2020/01/01/android-oh-my-dagger/</url>
    <content><![CDATA[<p>一切都始于<a href="https://www.youtube.com/watch?v=o-ins1nvbDg">An Opinionated Guide to Dependency Injection on Android (Android Dev Summit ‘19)</a>。好消息是Google终于提供了官方的DI教程，而且质量颇高。坏消息是dagger-android要亡了。</p>
<span id="more"></span>

<p>首先是<a href="https://developer.android.com/training/dependency-injection">官方教程</a>，是我见过最通俗易懂、深入浅出的教程了，没啥问题。但它配套的<a href="https://codelabs.developers.google.com/codelabs/android-dagger/">Codelab</a>手动管理了一个Scope和Component，以此来在多个Activity中注入相同的对象。这种做法一开始理解起来有点复杂，但用Dagger解决此类问题的方法也都与此大同小异吧。</p>
<p>我个人没遇到过此类问题。因为像是用户状态这类东西，一直都是放到一个Singleton里，也不需要担心是不是多个Activity。其他地方能用Navigation就用，配合ViewModel自带的Lifecycle管理，通常不需要专门用Scope来管理对象。</p>
<p>这个问题其实还有一个解决方法，就是用自定义ViewModel：<a href="https://github.com/FarshadTahmasbi/Vita">Vita</a>。它的代码可能要改一改才能适合自己用，但原理就是根据Activity的Lifecycle Events来生成ViewModel。</p>
<p>但这暴露了一个问题，<del>我用Dagger经验不丰富，</del> Dagger依然学起来难，用起来繁琐，这也跟视频后半部分提到的一样。为此Dagger团队正在发明新的API来简化Android上依赖注入，他们画的那些饼看起来也挺香的。<strong>但是</strong>，一想到现有的dagger代码和近期新项目不得不用dagger写，而这些代码在未来都要重构，我就头大。<del>其实完全可以不动它们</del></p>
<p><a href="https://youtu.be/o-ins1nvbDg?t=537">这里给dagger-android判了死刑</a>: <code>We are stopping its development. We are not adding any more features to do that.</code>。不过继续用也没啥问题，现在的又没有deprected。但dagger-android的局限也的确比较大，而它现在也只做到了能让大伙儿少写些类似于Subcomponent的胶水代码。</p>
<p>前几天在V2EX上看大伙儿讨论为啥程序员容易被淘汰，其中一个原因就是自己会的技术很快就过时了。想想也是，要是新的dagger-android一出，也没人关心你曾用dagger用得多么厉害吧。这让我想起了我曾经不知道Dagger需要Build Project来生成代码，结果死活找不到DaggerAppComponent，而现在的官方文档里把Make Project专门用框框标出来，新手一眼就明白了。</p>
<p>死鱼安乐啊死鱼安乐。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android OpenGL学习笔记</title>
    <url>/2023/01/02/android-opengl-basics/</url>
    <content><![CDATA[<p><a href="https://www.amazon.com/OpenGL-Android-Quick-Start-Pragmatic-Programmers/dp/1937785343">OpenGL ES 2.0 for Android</a> 学习笔记。</p>
<p>不过发现OpenGL不靠笔记，全靠内力，所以后期复杂的内容就记不过来了。</p>
<span id="more"></span>

<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>现代GPU更新了算法，<strong>每帧清屏重新绘制</strong>比在上一帧基础上修改要更效率、更可靠。</p>
<p><code>SurfaceView</code>是个<code>Surface</code>，屏幕上单独挖了个洞来高效率显示；<code>TextureView</code>是个<code>View</code>，继承了<code>SurfaceView</code>的功能且可以当成<code>View</code>来操作，代价是性能牺牲。</p>
<p><code>GLSurfaceView.Renderer</code>中的代码会<strong>在子线程执行</strong>。主线程到子线程：<code>GLSurfaceView.queueEvent</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">glSurfaceView.setEGLContextClientVersion(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sometimes necessary</span></span><br><span class="line"><span class="comment">// glSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0)</span></span><br><span class="line"></span><br><span class="line">glSurfaceView.setRenderer(AirHockeyRenderer(<span class="keyword">this</span>))</span><br><span class="line">glSurfaceView.withLifecycleOwner(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceCreated</span><span class="params">(gl: <span class="type">GL10</span>?, config: <span class="type">EGLConfig</span>?)</span></span> &#123;</span><br><span class="line">    GLES20.glClearColor(<span class="number">1f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>) <span class="comment">// Alpha is disabled by default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceChanged</span><span class="params">(gl: <span class="type">GL10</span>?, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawFrame</span><span class="params">(gl: <span class="type">GL10</span>?)</span></span> &#123;</span><br><span class="line">    <span class="comment">// We must draw something, even if it’s only to clear the screen.</span></span><br><span class="line">    <span class="comment">// If we don’t draw anything, we’ll probably get a bad flickering effect.</span></span><br><span class="line">    <span class="comment">// This will wipe out all colors on the screen and fill the screen with the color</span></span><br><span class="line">    <span class="comment">// previously defined by our call to glClearColor().</span></span><br><span class="line">    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Defining-Vertices-and-Shaders"><a href="#Defining-Vertices-and-Shaders" class="headerlink" title="Defining Vertices and Shaders"></a>Defining Vertices and Shaders</h2><p>Vertex, Vertices: 点。包含位置、颜色等信息。</p>
<p>用多个三角形去近似任意图形。描述时使用<strong>逆时针（倒带）方向可以优化性能</strong>。</p>
<p>使用<code>ByteBuffer.allocateDirect</code>定义不被垃圾回收影响的Native Memory。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> vertexData: FloatBuffer = ByteBuffer</span><br><span class="line">    .allocateDirect(tableVerticesWithTriangles.size * BYTES_PER_FLOAT)</span><br><span class="line">    .order(ByteOrder.nativeOrder())</span><br><span class="line">    .asFloatBuffer()</span><br><span class="line">    .put(floatArray)</span><br></pre></td></tr></table></figure>

<p>Shader: 渲染管线单元。</p>
<p>Shader使用GLSL（OpenGL’s shading language）</p>
<h3 id="Vertex-Shader"><a href="#Vertex-Shader" class="headerlink" title="Vertex Shader"></a>Vertex Shader</h3><p>每个点运行一次，得到最后的点。OpenGL生成点、线和三角形。</p>
<p>坐标为(-1, 1), (-1, 1)。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple Vertex Shader</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Position;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = a_Position;</span><br><span class="line">    <span class="comment">// gl_PointSize = 10.0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vec4</code>: x, y, z, w 坐标</p>
<p><code>attribute</code>: 添加颜色信息，自带默认值（0, 0, 0, 1）。</p>
<p>默认有着最高精度<code>highp</code>（见Fragment Shader精度介绍）。</p>
<h3 id="Fragment-Shader"><a href="#Fragment-Shader" class="headerlink" title="Fragment Shader"></a>Fragment Shader</h3><p>计算得到上述生成的点、线和三角形中每个像素点的颜色。Fragment相当于Pixel。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple Fragment Shader</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_Color;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = u_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>precision mediump float;</code>: 定义所有浮点数的精度。在<code>lowp</code>, <code>mediump</code>, <code>highp</code>中选择。</p>
<p>无默认精度（未定义的行为？），必须手动定义。</p>
<p>2023年1月13日更新：如果FragmentShader不定义精度，有的手机上会无法显示。</p>
<p>最高精度旨<strong>在某些实现中未支持</strong>。</p>
<p><code>int</code>的默认精度是<code>mediump</code>。</p>
<p><code>uniform</code>: 保持不变直至手动修改。无默认值，需要手动指定。</p>
<p><code>vec4</code>: 这里是颜色<code>RGBA</code>。</p>
<h2 id="Compiling-Shaders-and-Drawing-to-the-Screen"><a href="#Compiling-Shaders-and-Drawing-to-the-Screen" class="headerlink" title="Compiling Shaders and Drawing to the Screen"></a>Compiling Shaders and Drawing to the Screen</h2><ol>
<li><p>在<code>onSurfaceCreated</code>中获得两种Shader的String。</p>
</li>
<li><p>编译两种Shader，得到对应的shaderObjectId(int)。</p>
<ul>
<li>OpenGL内部并不抛异常，只是返回特定的值或通过<code>glGetError</code>读取。</li>
</ul>
</li>
<li><p>把Shaders合成为Program，得到programObjectId。</p>
</li>
<li><p>检测Program状态。</p>
</li>
<li><p>使用Program。</p>
</li>
<li><p>获取变量Attribute和Uniform的Location值。</p>
</li>
<li><p>设置变量值</p>
<p> 方法有很多，一些是：</p>
<ul>
<li><code>glVertexAttribPointer</code> + <code>glEnableVertexAttribArray</code>设置Attribute值。</li>
<li><code>glUniform4f</code>设置Uniform值。</li>
</ul>
</li>
<li><p>绘制</p>
<ul>
<li><code>glDrawArrays</code></li>
</ul>
</li>
</ol>
<h2 id="Adding-Color-and-Shade"><a href="#Adding-Color-and-Shade" class="headerlink" title="Adding Color and Shade"></a>Adding Color and Shade</h2><p><code>GL_TRIANGLE_FAN</code>: 一次画四个三角形。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New Vertex Shader</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Position;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Color;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    v_Color = a_Color;</span><br><span class="line">    <span class="built_in">gl_Position</span> = a_Position;</span><br><span class="line">    <span class="built_in">gl_PointSize</span> = <span class="number">10.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>varying</code>: 在一条线或三角形中，渐变颜色后，交给Fragment Shader。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New Fragment Shader</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = v_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不用手动设置Fragment Shader颜色了。</p>
<h2 id="Adjusting-to-the-Screen’s-Aspect-Ratio"><a href="#Adjusting-to-the-Screen’s-Aspect-Ratio" class="headerlink" title="Adjusting to the Screen’s Aspect Ratio"></a>Adjusting to the Screen’s Aspect Ratio</h2><p>线性代数、矩阵相乘！</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 0 0 translateX     x     x + translateX</span><br><span class="line">0 1 0 translateY  x  y  =  y + translateY</span><br><span class="line">0 0 1 translateZ     z     z + translateZ</span><br><span class="line">0 0 0 1              1     1</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New Vertex Shader</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_Matrix;</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">gl_Position</span> = u_Matrix * a_Position;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Matrix.orthoM</code>根据屏幕比例，缩放长边，使内容显示在中心的正方形中。</p>
<h2 id="Entering-the-Third-Dimension"><a href="#Entering-the-Third-Dimension" class="headerlink" title="Entering the Third Dimension"></a>Entering the Third Dimension</h2><p>坐标处理流程：</p>
<ol>
<li><p>Clip Space</p>
<p> 在<code>Vertex Shader</code>中的<code>gl_Position</code>首先被裁剪到[-w, w]的范围中。</p>
<p> 此时的坐标也被称为Homogenous Coordinates。</p>
</li>
<li><p>Perspective Division</p>
<p> x, y, z = x / w, y / w, z / w</p>
<p> w代表距离。距离越大，结果越小，结果越靠近原点，越像消失点。</p>
<p> 此阶段结束后，所有坐标都在[-1, 1]。多个Homogenous Coordinates会对应一个Normalized device coordinates。</p>
<p> w不为1时，(x, y, z)并不是实际坐标，(x / w, y / w, z / w)才是。</p>
</li>
<li><p>Viewport Transformation</p>
<p> 和显示区域长宽相乘得到最终坐标Window coordinates。</p>
</li>
</ol>
<p>给坐标增加各种矩阵，实现3D模拟。</p>
<h2 id="Adding-Detail-with-Textures"><a href="#Adding-Detail-with-Textures" class="headerlink" title="Adding Detail with Textures"></a>Adding Detail with Textures</h2><p>之后书中的内容就复杂起来，记笔记也变得难了起来。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android OpenGL Texture 坐标原点问题</title>
    <url>/2023/08/23/android-opengl-coordinates/</url>
    <content><![CDATA[<p>在学习<a href="https://www.amazon.com/OpenGL-Android-Quick-Start-Pragmatic-Programmers/dp/1937785343">OpenGL ES 2.0 for Android</a>时，其提到了OpenGL使用了传统的数学坐标系来定位位置，而在Texture的坐标时则含糊不清。而出来混，终于得还了。</p>
<p>TL;DR: <code>GLUtils.texImage2D</code>会把传入的<code>Bitmap</code>上下翻转，让可以开发者可以使用左上角为原点的坐标。但实际上，OpenGL总是以左下角为原点的。</p>
<span id="more"></span>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1----2</span><br><span class="line">-    -</span><br><span class="line">-    -</span><br><span class="line">3----4</span><br></pre></td></tr></table></figure>

<p>当上图为屏幕时，那么画满全屏Vertex的位置将为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1: (-1,  1)</span><br><span class="line">2: ( 1,  1)</span><br><span class="line">3: (-1, -1)</span><br><span class="line">4: ( 1, -1)</span><br></pre></td></tr></table></figure>

<p>但当上图为Texture时，坐标该是如何呢？根据书中所言，原点为左上角，也就是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1: ( 0,  0)</span><br><span class="line">2: ( 1,  0)</span><br><span class="line">3: ( 0,  1)</span><br><span class="line">4: ( 1,  1)</span><br></pre></td></tr></table></figure>

<p>和Android的绘制方向是一致的。在实际运行中，结果也是正确的。所以一直以来，我也以为Texture的坐标是从左上角开始的。</p>
<p>在学习OpenGL后，我开始尝试<a href="https://github.com/cats-oss/android-gpuimage">android-gpuimage</a>，但发现在使用<code>GPUImageFilterGroup</code>时，会随机出现上下颠倒的问题。为了找到该问题的原因，我是上下求索。翻遍了Issue区、认真阅读代码、问了很多遍ChatGPT、在搜索引擎中搜了很多关键字、根据滤镜数量找规律……都没能找到问题根源。</p>
<p>在Issue区中找到一个Pull Request：<a href="https://github.com/cats-oss/android-gpuimage/pull/231/">Re-fix: Grouped filters with filterCount%2==0 are flipped</a>，虽然在之后起到了大作用，但此时的我不仅看不明白其中的逻辑，也没能解决问题。</p>
<p>最后，我终于想起了走投无路之计策：用中文搜索问题！因为中文互联网几乎已等于只能吃老本的内容农场，所以我很少考虑这个方法。虽然在过去的确帮到我几次，但由于在其中找资料非常困难，这个方法几乎被遗忘了。</p>
<p>但是这次！我发现了<a href="https://www.jianshu.com/p/6c4c7426eef3">Android OpenGL 纹理坐标原点位置</a>！虽然实话实话说这篇文章还是有点难懂，但我找到了最关键的一句：</p>
<blockquote>
<p>在Android平台中，Bitmap绑定的2D纹理，是上下颠倒的， 可以按照在左上角处理</p>
</blockquote>
<p>经过几天或在清醒时或在睡梦中的思考后，我终于想明白了这个问题。</p>
<p><code>android-gpuimage</code>使用的是左上角坐标，这依赖于<code>GLUtils.texImage2D</code>的默认翻转。OpenGL总是使用左下角为原点，所以在默认翻转后，在FragmentShader中，Texture已经是上下颠倒的，这时再使用从左下角翻转到左上角的坐标绘制，又翻转了一次。一共了翻转了两次，等于没翻转，因此单个滤镜不会出错。</p>
<p>但是这个逻辑依赖于Texture是翻转的这一假设。</p>
<p>但<code>GPUImageFilterGroup</code>使用FrameBuffer实现，上一层的结果会作为下一层的Texture绘制到屏幕上，但是上一层的结果并不是翻转的，这与上述假设相矛盾，于是就在复杂处理中出现上下颠倒的奇怪问题。</p>
<p>相比于不停地使用坐标来解决上下颠倒问题，不如取消<code>GLUtils.texImage2D</code>的默认翻转（把Bitmap传给它前翻转一下），总是使用左下角为原点的坐标来得实在。于是在使用之前的Pull Request<a href="https://github.com/cats-oss/android-gpuimage/pull/231/">Re-fix: Grouped filters with filterCount%2==0 are flipped</a>及其评论区的修改后，翻转解决了。</p>
<p>但是<code>GPUImageLookupFilter</code>出错了。不过这个好解决，因为这个滤镜的原理是根据图片中某个像素点的颜色，一通计算后得到一个新的坐标，然后到LUT图中找颜色。这其中的那通计算是以左上角为原点的，也就是假设了LUT图是颠倒的。那么我们不取消LUT图Texture的<code>GLUtils.texImage2D</code>的默认翻转就可以了。</p>
<h2 id="关于中文搜索的沉思"><a href="#关于中文搜索的沉思" class="headerlink" title="关于中文搜索的沉思"></a>关于中文搜索的沉思</h2><p>在这次的问题中，我没能用英文搜索找到任何<code>GLUtils.texImage2D</code>默认翻转的资料。反而是再一次被中文内容拯救了，这说明之后还是应该给中文搜索多一些机会。</p>
<p>但中文搜索结果的处境依然不容乐观。对我来说，其更像是上午十点的古玩市场：剩下都大多是垃圾，而真正的宝贝需要高度的鉴别力。</p>
<p>就拿那篇文章来说，在开发文章聚集地转型为地摊文学编辑部的简书上，只有可怜的四个赞。从文章底部划过数十篇编乎一般的小说后，有几条评论。第一条是一位读者以很不客气的语气指责文章有错。第二条是作者耐心地重复解释了文章的内容。第三条则是另一位读者同样很不客气地在没有给出任何原因的情况下批评文章造成了误解。</p>
<p>虽说这篇文章的确有些难懂，但其中的道理是无误的。</p>
<p>我也由此想到了我之所以几乎从不在中文社区解答问题，很大一部分也是因为不仅得不到正反馈，很多情况下还会得到负反馈吧。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android OpenGL ES 2.0 的矩阵和坐标到底是怎么一回事儿？</title>
    <url>/2023/06/08/android-opengl-matrix/</url>
    <content><![CDATA[<p>最近依然在研读<a href="https://www.amazon.com/OpenGL-Android-Quick-Start-Pragmatic-Programmers/dp/1937785343">OpenGL ES 2.0 for Android</a>。在此记录有关Orthographic Matrix、Perspective Matrix、Perspective Divide、Homogeneous Coordinates等各种问答。</p>
<p>理解粗浅，若有错误，还望指正。不过估计没人看这个网站吧。</p>
<span id="more"></span>

<hr>
<p>Q: 为什么OpenGL中的坐标在x、y、z之外还有一个w？</p>
<p>A: 一个原因是3x3矩阵无法完成矩阵三维坐标的位移（同理，2x2矩阵无法完成二维坐标位移），所以给矩阵增加一维，右下角设置为1，其余增加的位置设置为0。这样完成位移后，再把增加的维度去掉，位移完成。在这里w总是1。即使不是1，也会用除法把它变为1，好让最后去掉它（这一步除法叫做Perspective Divide）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[x 0 0 0]</span><br><span class="line">[0 y 0 0]</span><br><span class="line">[0 0 z 0]</span><br><span class="line">[0 0 0 w]</span><br></pre></td></tr></table></figure>

<p>增加维度的这种方法就是Homogeneous Coordinates。</p>
<p>参考了<a href="https://youtu.be/vQ60rFwh2ig">The True Power of the Matrix (Transformations in Graphics) - Computerphile</a>。</p>
<p>另外一个原因涉及了三维空间在二维的投影，w会出现不为1的情况。之后讨论。</p>
<hr>
<p>Q: 为什么<code>android.graphics.Matrix</code>用9个<code>Float</code>，而不是和OpenGL一样用16个？</p>
<p>A: <code>android.graphics.Matrix</code>主要处理2D图像，所以增加了新维度后，矩阵成为了3x3=9个<code>Float</code>。</p>
<hr>
<p>Q: 为什么<code>andnroid.graphics.Camera</code>可以用<code>android.graphics.Matrix</code>模拟3D效果？</p>
<p>A: Skia的C++看到头疼。注意到其实现中使用了4x4矩阵，所以我猜测<code>andnroid.graphics.Camera</code>替开发者进行了2D-&gt;3D-&gt;2D的转换。</p>
<hr>
<p>Q: Orthographic Projection是个啥？</p>
<p>A: 是一个坐标变换矩阵，一次位移 + 一次缩放。</p>
<p>OpenGL需要每个顶点的坐标都在[-1, 1]中，也就是3D空间中位于原点的，边长为2的正方体。</p>
<p>但在设计3D场景（或使用3D设计2D场景）时，如果事先就用正方体中的小数坐标，会很繁琐。而直接用最直观的坐标，比如整数坐标就很方便（也可以是其他范围的坐标，比如正数总比负数好处理吧），但代价是要把这些坐标变换到正方体中。</p>
<p>Orthographic Projection就是这个变换。通过指定我们方便使用的坐标的范围，生成这个矩阵。之后我们把方便使用的坐标和该矩阵相乘，计算机会得出该坐标在正方体中的小数坐标。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Axonometric_projection.svg/225px-Axonometric_projection.svg.png" alt="别看字母，看线"></p>
<p>Source: <a href="https://en.wikipedia.org/wiki/Orthographic_projection">https://en.wikipedia.org/wiki/Orthographic_projection</a></p>
<p>简单地说，矩阵帮我们把设计中的坐标移动到了正方体中，可以让OpenGL显示。</p>
<p>OpenGL ES 2.0 for Android是在解决屏幕长宽的过程中引入了这个概念，有些混乱。这里再解释一下。</p>
<p>用书中的例子，我们要在各种比例的屏幕中放一个圆。如果把横竖位置都设置为[-1, 1]，就会挤满整个屏幕，成为了椭圆。这里其实有两个解决方案：</p>
<ol>
<li>根据屏幕修改坐标。这是最直观的想法。在例子中1:1.78的屏幕上，把顶部和底部坐标减小。横屏同理。</li>
<li>根据屏幕修改范围。这是书中的思路。坐标依然是[-1, 1]，但坐标范围变为了[-1.78, 1.78]。横屏同理。这里我们就可以用Orthographic Projection来把[-1.78, 1.78]范围内的坐标换到正方体中的[-1, 1]中。</li>
</ol>
<p>参考了<a href="https://youtu.be/U0_ONQQ5ZNM">The Math behind (most) 3D games - Perspective Projection</a>。之后的内容也会参考这个视频。</p>
<hr>
<p>Q: Perspective Matrix和Homogeneous Coordinates是个啥？</p>
<p>A: 突出一个抽象。上文的提到的视频很有用。</p>
<p>这里有一个没人跟我说的小秘密。</p>
<p>人眼看到的图像总是二维的，而人眼观察3D世界的视角是砍去一部分顶部的金字塔形状（Frustum，平截头体，截头锥体）。</p>
<p>我站在三维坐标的原点向一个轴看，看到的并不是轴的一个截面，而是把那个金字塔形状戴在头上😳，看到的那个截面。这样才符合现实规则。</p>
<p><img src="https://learnopengl.com/img/guest/2021/Frustum_culling/VisualCameraFrustum.png" alt="人眼是这么看东西的"></p>
<p>Source: <a href="https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling">https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling</a></p>
<p>人眼看到的是near plane大小的图像，其内容是3D空间中把far plane到near plane所有物体从远到近挤到near plane（二维化）的效果。</p>
<p>相关教程中总提距离越远物体越小。实际上物体大小没变，只是在二维化后，距离越远，物体<strong>看起来</strong>越小，或者说物体是在near plane中越小。</p>
<p>这些浅显的道理放在代码和数学中就会很不直观。</p>
<p>Perspective Matrix的作用是把3D中排好的物体，变化为near plane上的2D坐标。</p>
<p>虽然2D坐标没有z坐标（或者说都相等），但我们需要保留z坐标的相对关系，来确定2D图像中，谁挡住谁。</p>
<p>而在Perspective Matrix的计算中，会出现w不为1的情况。</p>
<p>到这一步，从实用角度来说，我们完全可以忽略工具数儿w了。</p>
<p>编不下去了，到现在我也无法直观地想象出w在3D空间中的样子。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>个人偏爱的Android应用架构</title>
    <url>/2021/04/18/android-opinoinated-arch/</url>
    <content><![CDATA[<p>根据几年来的开发经验和阅读过的代码，总结出了个人觉得还算稳定可持续的Android应用架构。它以MVVM为基础，融合了Clean Architecture，参考了<a href="https://github.com/google/iosched">iosched</a>（新的<a href="https://github.com/android/nowinandroid">nowinandroid</a>大同小异），尽可能地照顾到测试和扩展。</p>
<p>不定期更新新的想法。</p>
<span id="more"></span>

<p>应用细分了许多Gradle Module，且除顶层app外，每个Module都是Android Library（<code>com.android.library</code>）。</p>
<p>应用的调用逻辑为Activity -&gt; Fragment -&gt; ViewModel -&gt; UseCase -&gt; Repository。我们按照Moule依赖顺序，从UseCase开始。</p>
<p><strong>这里重度使用依赖注入，并尽可能使用了<code>@Reusable</code>。</strong></p>
<h2 id="domain"><a href="#domain" class="headerlink" title="domain"></a><code>domain</code></h2><p>最底层的基础Module，之后的所有Module都会隐式地依赖它。定义了：</p>
<ul>
<li><p>Entity：用到的所有Java Bean或者Kotlin <code>data class</code></p>
</li>
<li><p>Repository：全部为<code>interface</code>。提供各种底层操作，每个操作尽可能只完成简单的一件事，而将具体的整合留给下一位。</p>
</li>
<li><p>UseCase：一个抽象类为<a href="https://github.com/google/iosched/blob/main/shared/src/main/java/com/google/samples/apps/iosched/shared/domain/CoroutineUseCase.kt">CoroutineUseCase</a>。继承时，依赖注入<code>CoroutineDispatcher</code>和将使用到的Repository。定义了所有用到的操作（<a href="https://github.com/google/iosched/blob/main/shared/src/main/java/com/google/samples/apps/iosched/shared/domain/users/FeedbackUseCase.kt">一个简单的例子</a>）。</p>
<ul>
<li><p>为了照顾单元测试，避免使用Android专用代码（例如使用Kotlin Flow替代LiveData）。</p>
</li>
<li><p>关于在应用的哪一层捕获异常，是一个见仁见智的问题。<del>我个人偏向在UseCase中捕获异常。有异常就封装到一个<code>Result&lt;Xxx&gt;</code>（和Kotlin中的<code>Result</code>类似，为了避免烦人的警告而手动定义）中，没异常就直接返回。</del></p>
<p>2022年1月20日更新：我还是决定在Repository中捕获异常。</p>
</li>
<li><p>2022年5月28日更新：在看了<a href="https://www.reddit.com/r/androiddev/comments/uwkj2w/usecase_vs_repository/">UseCase vs Repository</a>谈论后，个人偏爱的做法是：当Repository的某个操作仅在一处使用时，不把它包装为UseCase。此外，某个操作在多处使用或需要多个Repository时，包装为UseCase。</p>
</li>
</ul>
</li>
<li><p>常量、日志、异常、Feature Flag等基础配置</p>
</li>
<li><p>统计、崩溃收集的接口</p>
</li>
</ul>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a><code>data</code></h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">api project(<span class="string">&quot;:domain&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实现了<code>domDaain</code>中的Repository，并用Dagger的<code>@Binds</code>绑定到对应的Repository。定义了并实现了数据库、网络、本地储存、WorkManager等来完成Repository的任务。</p>
<ul>
<li><p>使用Room时，数据在本Module定义为XxData（包含了数据的字段定义），而Repository中要返回XxEntity，所以在返回前要手动或定义专门的Mapper类进行转换。</p>
<p>这么做可以将具体实现和应用逻辑分割。UI层直接处理简单的<code>data class</code>，而无需担心JSON、数据库等配置。</p>
<p>2023年5月19日更新：从<a href="https://youtu.be/P125nWICYps">How to build a data layer</a>学到了可以把Mapper替换为和Data在一起的方法，比如<code>XxData.toEntity()</code>，这样可以省去专门的转换类。</p>
</li>
<li><p>得益于Hilt，绑定Repository的类可以定义为私有类。</p>
</li>
<li><p>不在本Module中存放资源。非要不可的话：</p>
<ul>
<li>依赖注入</li>
<li>在<code>res/values/ids.xml</code>定义一个同名资源来引用。</li>
<li>在更高层的Module中使用Extension functions来增加相关功能。</li>
</ul>
</li>
<li><p>因为基本全是内部实现，所以几乎都是<code>internal</code>。配合Hilt应该可以全部为<code>internal</code>。</p>
</li>
</ul>
<h2 id="presentation"><a href="#presentation" class="headerlink" title="presentation"></a><code>presentation</code></h2><p><strong>在有了Hilt之后，本Module可以被删除，而将ViewModel移动到各个功能Module中。</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">api project(<span class="string">&quot;:domain&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>定义了所有用到的ViewModel，ViewModel中被注入了各个需要的UseCase或Repository。</p>
<ul>
<li>业务逻辑应该在UseCase中，所以ViewModel中尽可能保持简单。</li>
<li>虽然Google官方建议在Kotlin-only的项目中用Flow替代LiveData，但我习惯在ViweModel中将Flow调用<code>asLiveData()</code>转换后给UI层使用，因为在UI层使用Flow坑太多。</li>
</ul>
<p>2021年11月6日更新：</p>
<p>Google官方铁了心要在UI层用Flow，而我依然和大佬（<a href="https://bladecoder.medium.com/kotlins-flow-in-viewmodels-it-s-complicated-556b472e281a">Kotlin’s Flow in ViewModels: it’s complicated</a>）站在UI层使用LiveData的队。<code>flowWithLifecycle</code>等API又把开发者需要担心Lifecycle的问题带回来了嘛。</p>
<p>2022年1月20日更新：</p>
<p>如果Repository中的一个方法可以被直接使用，套一层UseCase也只是简单包装API的话，我觉得是可以直接在ViewModel中注入Repository的。仅把多于一个操作的情况抽象为UseCase。</p>
<p>2022年8月13日：</p>
<p>根据<a href="https://developer.android.com/topic/modularization/patterns#communication">Common modularization patterns</a>，在ViewModel中使用SavedStateHandle时，后者会自带Fragment的arguements，未找到更新日志。</p>
<h2 id="app-base"><a href="#app-base" class="headerlink" title="app-base"></a><code>app-base</code></h2><p>以<code>app-</code>开头的Module将会按应用的不同功能分类，而本Module是它们的基础Module。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">api project(<span class="string">&quot;:domain&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>定义了：</p>
<ul>
<li>各种UI层（Android层）的基础UI类、通用View、通用工具类。</li>
<li>除了各个功能Module的特有资源，其他资源都放在这里。例如应用图标、通用图标、颜色、主题、翻译等。</li>
</ul>
<h2 id="app-xxx"><a href="#app-xxx" class="headerlink" title="app-xxx"></a><code>app-xxx</code></h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">api project(<span class="string">&quot;:app-base&quot;</span>)</span><br><span class="line"><span class="comment">// api project(&quot;:prentation&quot;) // Hilt之前</span></span><br></pre></td></tr></table></figure>

<p>将应用按功能分类，包含了功能的界面、Activity、Framgnet等。用了Hilt之后，也可以把ViewModel放进来。</p>
<ul>
<li>app-analytics也应该是一个单独的Module，用于替换不同实现。</li>
</ul>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a><code>app</code></h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation project(<span class="string">&quot;:domain&quot;</span>)</span><br><span class="line">implementation project(<span class="string">&quot;:data&quot;</span>)</span><br><span class="line"><span class="comment">// implementation project(&quot;:prentation&quot;) // Hilt之前</span></span><br><span class="line">implementation project(<span class="string">&quot;:app-base&quot;</span>)</span><br><span class="line">implementation project(<span class="string">&quot;:app-xxx&quot;</span>)</span><br><span class="line"></span><br><span class="line">compileOnly ... <span class="comment">// Dagger可能会抱怨找不到data中使用的一些类，所以加进来就可以。</span></span><br></pre></td></tr></table></figure>

<p>应用入口，也是仅有依赖了<code>data</code> Module的一处。这样将应用实现细节通过依赖注入抽象出来，可以达到代码不互相污染、提升编译速度、方便测试、提高逆向难度、提高可扩展性等的效果。</p>
<ul>
<li><p>Navigation Component配置如下：</p>
<ul>
<li>在<code>app-base</code>的<code>res/values/ids.xml</code>定义了一群id，代表各个目的地或操作。</li>
<li>在<code>app-xxx</code>中实现各个Fragment，并按需使用其他id。</li>
<li>在<code>app</code>的Navigation graph中，将id和Fragment或操作对应起来。</li>
</ul>
<p>这么做的缺点是：</p>
<ul>
<li>无法保证编译时安全，少配置了东西只有在运行才会崩溃，但我还没找到更好的办法。</li>
<li>不能使用生成的参数类。解决办法是乖乖<code>bundleOf</code>。</li>
</ul>
<p>2021年5月11日更新：</p>
<p>刚刚看了<a href="https://www.youtube.com/watch?v=IvFSJVTGDb4">Navigation: Navigating between modules - MAD Skills</a>，视频中是通过在子Module中定义Nested Graph，父Module中引用实现的，这样可以让子Module隐藏Nested Graph中的实现。这个方法比上述的要好。</p>
<p>但如果出现了子Module之间跳转的情况，那可能还是需要之前的方法。</p>
<p>2021年7月2日更新：</p>
<p>刚刚看了<a href="https://www.youtube.com/watch?v=4srssoBo0HU">Navigation - Live Q&amp;A - MAD Skills</a>，连同<a href="https://developer.android.com/guide/navigation/navigation-multi-module#across">刚刚更新的文档</a>，都是推荐使用DeepLink来在子Module间跳转。这个方法看起来也比一开始的方法要好。</p>
<p>Graph + DeepLink是一个不错的组合，也是我考虑未来会使用的方法。</p>
<p>2021年11月6日更新：</p>
<p>用了一段时间的Graph + DeepLink，发现体验就像一堆狗屎。它需要在<code>onDestinationChanged</code>判断Destination时，同时查询父Graph的ID，代码复杂度翻倍。DeepLink也同样不能保证编译时安全。</p>
<p>我还是用回了自定义ID的方案，同时在需要支持跳转时再用DeepLink。</p>
</li>
</ul>
<h2 id="各种使用场景"><a href="#各种使用场景" class="headerlink" title="各种使用场景"></a>各种使用场景</h2><ul>
<li><p>单元测试主要是UseCase，可以新建一个测试Module，也可以在<code>domain</code>中就地解决。</p>
</li>
<li><p>Instrumented Test可以新建一个测试Module，也可以在<code>app</code>中就地解决。</p>
</li>
<li><p>国产SDK</p>
<p>因为它们代码混乱、污染名称空间，最好把它们丢到一个专门的Module（例如<code>app-trash</code>、<code>app-third</code>）中养蛊。如果它们只提供JAR或AAR，就把文件引用为一个新Module(New -&gt; New Module -&gt; Import .JAR/.AAR Package)，然后再在我们的养蛊Module中，引用它们。之后在<code>app-base</code>中定义<code>interface</code>，<code>app-trash</code>中实现，<code>app</code>中依赖绑定，<code>app-xxx</code>注入使用。</p>
<p>上述方法看起来很麻烦，但因为国产SDK太过恶心、给人造成的麻烦太多，怎么加抽象都不为过。另外，有了Lifecycle、新的Activity Result API等，上述方法也容易了些。</p>
<p>个人经验：永远不要直接引用它们，哪怕多加几个抽象Module。</p>
</li>
<li><p>MVI</p>
<p>因为现有的MVI框架还不够成气候，所以现在还是MVVM。但MVI最重要的是思想，Jetpack Compose也是有类似的思想。在将ViewModel精简、将逻辑放到UseCase后，实现起来还是容易的。</p>
</li>
</ul>
<h2 id="其他的想法"><a href="#其他的想法" class="headerlink" title="其他的想法"></a>其他的想法</h2><h3 id="2022年9月17日"><a href="#2022年9月17日" class="headerlink" title="2022年9月17日"></a>2022年9月17日</h3><p>最近看了<a href="https://developer.android.com/topic/modularization/patterns">Common modularization patterns</a>。文中提到了多个domain和data的实现，这里提出一些类似的想法，还未亲自实现过。</p>
<ul>
<li><p>domain拆为</p>
<ul>
<li>domain-base: 存放和具体实现无关的类，例如工具类、接口类等。</li>
<li>domain-xxx: 依赖于domain-base，存放对应功能的Entity、Repository和UseCase。</li>
</ul>
</li>
<li><p>data拆为</p>
<ul>
<li>data-base: 存放一些工具类。</li>
<li>data-xxx: 依赖于data-base。似乎只能实现各自的数据库、网络、Repository实现。</li>
</ul>
</li>
<li><p>app-base</p>
<p>不再依赖于domain，依旧保留公用的资源、工具类。此外不修改。</p>
</li>
<li><p>app-xxx</p>
<p>依赖于各自对应的domain-xxx。</p>
</li>
<li><p>app</p>
<p>根据flavor依赖不同的app-xxx和其对应的data-xxx。</p>
</li>
</ul>
<h3 id="2023年12月19日"><a href="#2023年12月19日" class="headerlink" title="2023年12月19日"></a>2023年12月19日</h3><p>最近看了<a href="https://github.com/android/nowinandroid">nowinandroid</a>。从架构上来讲，并没有什么新增的地方。但我发现整个项目比较零碎，并没有之前iosched的浑然一体的感觉。大量的实验API和不少TODO都让这个项目变得对新人不是很友好。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack Paging3 从入门到入土</title>
    <url>/2022/01/31/android-paging3/</url>
    <content><![CDATA[<p>一言以蔽之：<a href="https://en.wikipedia.org/wiki/Jack_of_all_trades,_master_of_none">Jack of all trades, master of none</a>。</p>
<p>本文记录了个人实现分页的一些弯路与经验。</p>
<span id="more"></span>

<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>初始加载部分数据，然后在滑过一定距离后，自动加载更多。</li>
<li>Offline first。先显示缓存数据，本地缓存用光后再请求新数据。</li>
<li>第一次请求和后续请求时根据是否加载与成功与否显示不同的布局。</li>
</ol>
<p>人生中第一个分页方案是<a href="https://github.com/mikepenz/FastAdapter#8-infinite-endless-scrolling">FastAdapter的Endless scrolling</a>。背后的原理是<a href="https://guides.codepath.com/android/endless-scrolling-with-adapterviews-and-recyclerview">Endless Scrolling with AdapterViews and RecyclerView</a>。它们针对需求1，通过给RecyclerView增加OnScrollListener，进行了逐字逐句的实现。</p>
<p>由于业务不熟练，数据储存使用了MutableList，导致了很多多线程、缓存之类的问题。最后代码混乱，勉强能用。</p>
<p>之后在Jetpack Paging发布后，自然而然地决定迁移过去，吃Google软饭。</p>
<h2 id="缝缝补补Paging2"><a href="#缝缝补补Paging2" class="headerlink" title="缝缝补补Paging2"></a>缝缝补补Paging2</h2><p>Paging的官方Sample很复杂。可以看得出Google想要满足尽可能多的情况，但结果却是大伙儿都理解不了。</p>
<p>Sample中为了满足需求，需要<a href="https://github.com/android/architecture-components-samples/blob/paging2/PagingWithNetworkSample/app/src/main/java/androidx/paging/PagingRequestHelper.java">一个巨大的类</a>，还要给BoundaryCheck<a href="https://github.com/android/architecture-components-samples/blob/paging2/PagingWithNetworkSample/app/src/main/java/com/android/example/paging/pagingwithnetwork/reddit/util/PagingRequestHelperExt.kt">外挂LiveData来实现检测错误、实现刷新</a>。因此每一个PagedList的创建都很繁琐，为此开发者都得二次封装。加上几年前Unidirectional Data Flow的思想还未流行，从实现底层到UI层，自然处处都会见到PagedList的闪亮身影。</p>
<p>虽说代码库更乱了，但好在能用。FastAdapter的维护者也很勤奋，增加了对Paging2的支持。</p>
<h2 id="竹篮打水Paging3"><a href="#竹篮打水Paging3" class="headerlink" title="竹篮打水Paging3"></a>竹篮打水Paging3</h2><p>在Paging3公布时，看到了全程使用Kotlin Coroutines、一个Pager配置所有内容、支持分隔符、支持错误状态和重试……让人口水流了一地。</p>
<p>正式版发布后，我以为大版本不兼容，需要重构很多代码，所以在很长一段时间内都没正式使用过。</p>
<p>在某次偶然的机会，才发现Paging2到Paging3是二进制兼容的。细看之下，原来是Paging3用新API重新实现了Paging2！想到二者API差别之大，和确保行为相同所需的测试和努力，发自内心佩服维护者。</p>
<p><strong>可是</strong>，</p>
<ol>
<li><p>初始加载部分数据，然后在滑过一定距离后，自动加载更多。</p>
<p> 即使是仅创建Pager，不交给Adapter，Paging3都会触发Refresh + Append或两次Append。如果我把分页设置为一个远大于屏幕可显示内容的数值，它依然会自动加载两次。</p>
<p> 自动加载一次可以理解为确保数据尽早到位，但为什么要加载第二次呢？为什么本地数据即使够多，也要加载更多呢？多次Debug后，发现Flow会初始化两次？</p>
</li>
<li><p>Offline first。先显示缓存数据，本地缓存用光后再请求新数据。</p>
<p> 由于需求1的原因，每次新建Pager后，它总会请求新的两页，即使本地数据还有很多未浏览。</p>
</li>
<li><p>第一次请求和后续请求时根据是否加载与成功与否显示不同的布局。</p>
<p> 如果只用withLoadStateFooter，RecyclerView可能会自动滚动到第一页末尾。原因可能是为了保持没有数据时，第一项也就是Footer的位置，而在第一页数据加载完毕后，Footer可能还未清空。</p>
<p> Paging3可能需要<a href="https://developer.android.com/topic/libraries/architecture/paging/load-state#chain-operators">类似如下的肮脏代码</a>来解决问题：</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycleScope.launchWhenCreated &#123;</span><br><span class="line">    adapter.loadStateFlow</span><br><span class="line">        <span class="comment">// Only emit when REFRESH LoadState for RemoteMediator changes.</span></span><br><span class="line">        .distinctUntilChangedBy &#123; it.refresh &#125;</span><br><span class="line">        <span class="comment">// Only react to cases where REFRESH completes, such as NotLoading.</span></span><br><span class="line">        .filter &#123; it.refresh <span class="keyword">is</span> LoadState.NotLoading &#125;</span><br><span class="line">        <span class="comment">// Scroll to top is synchronous with UI updates, even if remote load was</span></span><br><span class="line">        <span class="comment">// triggered.</span></span><br><span class="line">        .collect &#123; binding.list.scrollToPosition(<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最后是在Stackoverflow发现了可以增加一个Header来避免滚动。</p>
<p> 既然有了Header，那把初始刷新状态也显示了吧。</p>
<p> 那么这时RecyclerView的动画会在一瞬间同时显示Header和Footer，非常丑。为了解决这个，需要对ItemAnimator进行很复杂的Hack。</p>
<p> 于是决定把初始刷新状态单独成为View，和LoadStateAdapter协作。然而这么做依然无法彻底解决上述问题。</p>
<p> 同时，为了避免自动滚动，Header不能去掉。但如果把Header高度设置为0，会出现SwipeRefreshLayout失效的问题，因此最后只好把Header设置为空白的1px。</p>
</li>
</ol>
<p>在花费很多天把玩Paging3，结果却依然不理想后，只能自己造轮子了。</p>
<p><a href="https://www.reddit.com/r/androiddev/search/?q=paging3">Reddit上也有很多开发者抱怨Paging3复杂难用</a>。</p>
<h2 id="自制小饼干"><a href="#自制小饼干" class="headerlink" title="自制小饼干"></a>自制小饼干</h2><p>为了自身情况量身定制的方法意外地简单。大体上还是参考了<a href="https://guides.codepath.com/android/endless-scrolling-with-adapterviews-and-recyclerview">Endless Scrolling with AdapterViews and RecyclerView</a>，只不过使用ListAdapter中的getItem来确定已浏览的范围，进而决定何时请求更多。配合Room生成的Flow和自定义的加载状态，确保了Single source of truth。</p>
<ul>
<li>2022年3月6日更新：为了避免更新不到的情况，选择了在ListAdapter的getItem中判断position时，只要剩余数目少于预设值，就进行请求。然后在具体请求的请求方法中，进行上锁、是否请求还是忽略请求的判断。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看起来像个多面手的Paging3到都来只是浪费了不少时间。虽然可以说一句简单的“凡事还得自己来”，<del>但这件事，我还要再下一篇文章中继续反思。</del>想了许久，还是一句话：“不坏不修”。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android Proguard Hell</title>
    <url>/2018/12/16/android-proguard-hell/</url>
    <content><![CDATA[<p>源自于无法忍受LeanCloud的Keep所有类的Proguard规则，想要精简一下APK而摸了Proguard的底。</p>
<span id="more"></span>

<p>Proguard基本上有个任务，精简（删除），混淆，优化。</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul>
<li><p>-keep 不精简且不混淆这个类和它的成员，“别摸这个类”</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-keep class android.support.annotation.Keep</span><br><span class="line">-keep class androidx.annotation.Keep</span><br><span class="line"></span><br><span class="line">-keep @android.support.annotation.Keep class * &#123;*;&#125;</span><br><span class="line">-keep @androidx.annotation.Keep class * &#123;*;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>-keepclasseswithmemebers 效果跟上一条一致，但可以更具体地声明包含某种成员的类。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @androidx.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @androidx.annotation.Keep &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;init&gt;(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @androidx.annotation.Keep &lt;init&gt;(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>-keepclassmembers -keep针对某个类，这个针对某个成员，效果一致（不精简且不混淆）。“别摸这个类的这个成员”</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclassmembers class * implements android.os.Parcelable &#123;</span><br><span class="line">    public static final ** CREATOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclassmembers class **.R$* &#123;</span><br><span class="line">    public static &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Preserve annotated Javascript interface methods.</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    @android.webkit.JavascriptInterface &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>-keepnames 只精简不混淆</p>
</li>
<li><p>-keepclasseswithmembernames 效果跟上一条一致，但可以更具体地声明包含某种成员的类</p>
</li>
<li><p>-keepclassmembernames 只针对这个类的这个成员，只精简不混淆。不影响这个类。</p>
</li>
</ul>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>seeds.txt：第一步(Read Input)的产物。内容是所有匹配proguard-rules的类和成员。是Proguard没有摸过的内容。</p>
<p>usage.txt：第二步(Shrink)的产物。在知道不能摸的内容后，这里是所有Proguard摸过的内容。</p>
<p>mapping.txt：第三步(Obfuscate)的产物，记录了Proguard怎么摸的。是一个混淆前后的对应表。</p>
<p>dump.txt：第四步(Dump)的产物，Progurad处理后的，未压缩或未优化的结果。体量巨大，但可以用于不反编译APK就可以看到APK的内容。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://developer.android.com/studio/build/shrink-code">Shrink your code and resources</a></p>
</li>
<li><p><a href="https://medium.com/google-developers/troubleshooting-proguard-issues-on-android-bce9de4f8a74">Troubleshooting ProGuard issues on Android</a></p>
</li>
<li><p><a href="https://jebware.com/blog/?p=484">Reading ProGuard’s Outputs</a></p>
</li>
<li><p><a href="https://jebware.com/blog/?p=498">Feeding ProGuard’s inputs: where are all of these rules coming from?</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=F9ymcWoDEtc">How Proguard Works</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发的一些知识：Android框架</title>
    <url>/2019/02/03/android-requirements-architecture/</url>
    <content><![CDATA[<p><a href="https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements.md">Android开发的一些知识 - At a high level, what does the Android architecture look like?</a></p>
<span id="more"></span>

<p>参考<a href="https://developer.android.com/guide/platform/">Platform Architecture</a></p>
<p><img src="https://developer.android.com/guide/platform/images/android-stack_2x.png" alt="Android Architecture"></p>
<p>我们久经考验的Linux内核可以提供可靠安全的运行环境：权限、进程分离、IPC、应用沙箱。包括了各种硬件的驱动。</p>
<p>Hardware Abstraction Layer (HAL)，硬件抽象层。抽象具体硬件实现的。</p>
<p>HAL上有Android Runtime。运行程序的。每个应用都有自己的进程和ART实例。负责AOT和JIT、有专门设计的GC等。具体参见系列另一篇Dalvik和ART。</p>
<p>还有一些常有的Java Libraries。</p>
<p>Native C/C++ Libraries：大部分系统服务（ART和HAL）都使用了native libraries written in C and C++。通过Java JNI放出一些接口。</p>
<p>Java API Framework：写应用时接触到Java API。像是View、Resources、Notification、Activity、Content Providers…</p>
<p>System Apps：系统应用。当然还有各种第三方应用。</p>
<p><a href="https://github.com/DeweyReed/site/blob/master/source/_posts/android-internal.md">之前的笔记：Android Internal 笔记</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发的一些知识：Dalvik和ART</title>
    <url>/2019/02/15/android-requirements-dalvik-art/</url>
    <content><![CDATA[<p><a href="https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements.md">Android开发的一些知识 - How Dalvik and ART VMs work?</a></p>
<span id="more"></span>

<p><strong>更新</strong></p>
<p><a href="https://proandroiddev.com/android-cpu-compilers-d8-r8-a3aa2bfbc109">Android CPU, Compilers, D8 &amp; R8</a>，这篇文章中的内容更准确。</p>
<p><strong>完</strong></p>
<h2 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h2><p>运行在4.4之前设备上的虚拟机。JIT编译，每应用一个，运行着Dalvik字节码（.dex）的文件。在运行时把.dex字节码转化为硬件特有的指令。</p>
<p>要塞到小设备（体积、内存）里所以体量很小、优化很少。内存分配和回收很慢。堆碎片化（有什么专业的对应翻译吗）严重。适合不怎么分配内存的应用，因此早期Android开发会教导大伙儿尽量少分配对象。</p>
<p>Dalvik虽然为低内存设备优化过，但依然使用了JIT。</p>
<h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><p>在4.4需手动开启、5.0之后默认开始。依然运行着.dex字节码，相比Dalvik，ART各方面都更好。随着新版本的推出，ART性能也在越来越好。整个Android平台也在和它互相适配。</p>
<p>主要的优势有：</p>
<h3 id="1-AOT"><a href="#1-AOT" class="headerlink" title="1. AOT"></a>1. AOT</h3><p>传统的VM是解释型的，一行一行转换巨慢。</p>
<p>后来出现了JIT，放到虚拟机里跑字节码，但它延迟大、占用内存大，但优点是可以观察代码的具体运行，并进行直接的优化。</p>
<p>AOT只在安装应用时把代码编译为机器对应的字节码，这样运行时更快，内存占用更小。因为第一次运行编译时时间多，所以可以在这一次里进行更细致的优化。这和移动设备要求延迟低、内存小的相性很般配。</p>
<ul>
<li>早期的iOS比Android跑的快，有一部分原因就是其设备架构统一，所以就可以跑编译后的代码，当然快啦。</li>
<li>JIT也在运行啦。在一些代码瓶颈处（Hotspot）会把代码留下来以后跑JIT。</li>
</ul>
<h3 id="2-优化了的GC"><a href="#2-优化了的GC" class="headerlink" title="2. 优化了的GC"></a>2. 优化了的GC</h3><h4 id="Dalvik的行为"><a href="#Dalvik的行为" class="headerlink" title="Dalvik的行为"></a>Dalvik的行为</h4><p>分配：从头找一个足够的空挡放进去。</p>
<p>回收：</p>
<ol>
<li>【暂停所有线程】来找根索引。</li>
<li>所有线程恢复运行，Dalvik顺藤摸瓜，从根索引找到所有可以到达的对象，并标记它们。</li>
<li>再次【暂停所有线程】来找所有可以到达的对象，因为程序可能在第二步又分配的对象。</li>
<li>回收掉没有被标记的对象</li>
</ol>
<p>如果要分配一个大对象，内存又不够用，但内存里又有马上要被回收但还没被回收的对象，这时就会触发<code>GC_FOR_ALLOC</code>，专门为了这次分配回收一次。</p>
<p>如果要分配一个大对象，内存又不够用，但内存里也没有可回收的对象，这时就会增大堆或者out of memory。</p>
<p>Dalvik不会压缩/移动内存来腾空间，导致堆碎片化严重。</p>
<h4 id="ART的行为"><a href="#ART的行为" class="headerlink" title="ART的行为"></a>ART的行为</h4><p>全方面地更快啦。</p>
<p>分配：<code>RosAlloc</code>取代了原来的<code>dlmalloc</code>（是C和C++中使用的算法）。特点有</p>
<ol>
<li>可以针对某一线程进行内存分配</li>
<li>将小对象内存分配打包</li>
<li>将大对象内存分配按页对齐</li>
<li>更好的上锁和解锁</li>
</ol>
<p>分配大对象（<strong>现在</strong>只是针对至少12KB的primitive数组或String）时，不是找空的坑位，而是直接放到空旷的某个地方。</p>
<p>ART学会了通过压缩/移动内存来腾空间，堆碎片化解决了。ART会在应用进入后台后，不影响用户体验时，再进行内存整理，<strong>或者</strong>应用在前台，而急需内存时。</p>
<p>回收：</p>
<p>四个阶段中的第一个阶段不再暂停其他线程。第三个阶段也更快了。</p>
<p>Minor GC：跟踪所有上一次GC后分配的对象，回收时先处理它们，因为它们寿命更短，处理更快。</p>
<h3 id="牛轧糖的ART"><a href="#牛轧糖的ART" class="headerlink" title="牛轧糖的ART"></a>牛轧糖的ART</h3><p>把分配器用汇编代码重写了一遍。</p>
<h3 id="奥利奥的ART"><a href="#奥利奥的ART" class="headerlink" title="奥利奥的ART"></a>奥利奥的ART</h3><p>新的回收器，可以在前台进行持续地内存优化/压缩。结果就是整个系统的内存占用和堆碎片化都有了大幅度优化。移动内存只需要移动指针。</p>
<p>内存分配更快了导致synchronized的对象池的性能有一些情况下比直接分配更差。</p>
<p>AOT跟JIT合作，情况更复杂了。安装时并不会完全编译代码，以此提升安装速度。第一次运行时依赖JIT，然后找到运行瓶颈，再在后台进行AOT和不断地优化。这一过程不断重复，结果就是应用越用越快。</p>
<p>此外还有大量大量的优化。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://source.android.com/devices/tech/dalvik">https://source.android.com/devices/tech/dalvik</a></li>
<li><a href="https://www.quora.com/From-what-Ive-read-online-it-seems-like-Google-is-planning-to-default-to-ART-in-a-future-release-Why-is-ART-better-than-Dalvik">https://www.quora.com/From-what-Ive-read-online-it-seems-like-Google-is-planning-to-default-to-ART-in-a-future-release-Why-is-ART-better-than-Dalvik</a></li>
<li><a href="https://www.youtube.com/watch?v=Zc4JP8kNGmQ">Trash Talk (Android Dev Summit ‘18)</a></li>
<li><a href="https://www.youtube.com/watch?v=vU7Rhcl9x5o">Deep Dive into the ART Runtime (Android Dev Summit ‘18)</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发的一些知识：在Android Studio点击Run之后</title>
    <url>/2019/02/03/android-requirements-start-button/</url>
    <content><![CDATA[<p><a href="https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements.md">Android开发的一些知识 - At a high level, what happens when you hit the build button on Andorid Studio?</a></p>
<span id="more"></span>

<p><a href="https://cn.udacity.com/course/gradle-for-android-and-java--ud867">课程: Gradle for Android and Java</a></p>
<p>Gradle已经提供了很多Automation相关的工作，Google就选它作为Android的build system。</p>
<p>Android Studio把所有任务都交给了Gradle来完成，自己只是一个wrapper。但Gradle并不了解Android，所以Google提供了android-gradle-plugin，简称AGP。</p>
<p>新建一个Empty Activity的Kotlin项目。</p>
<p>点击Run，发现运行了</p>
<p><code>Executing tasks: [:app:assembleDebug]</code></p>
<p>这里摘一些有用的Tasks:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Transform ... // 首先是Jetifier和AAR transform</span><br><span class="line">...</span><br><span class="line">&gt; Task :app:compileDebugAidl // 处理AIDL，用于IPC https://developer.android.com/guide/components/aidl</span><br><span class="line">&gt; Task :app:compileDebugRenderscript // 处理RenderScript https://developer.android.com/guide/components/aidl</span><br><span class="line">&gt; Task :app:checkDebugManifest // 检查Manifest</span><br><span class="line">&gt; Task :app:generateDebugBuildConfig // 生成BuildConfig</span><br><span class="line">...</span><br><span class="line">&gt; Task :app:generateDebugResValues // 首先处理并生成资源Resources</span><br><span class="line">&gt; Task :app:generateDebugResources</span><br><span class="line">&gt; Task :app:createDebugCompatibleScreenManifests</span><br><span class="line">&gt; Task :app:mergeDebugResources</span><br><span class="line">&gt; Task :app:processDebugManifest // 处理Manifest</span><br><span class="line">&gt; Task :app:processDebugResources</span><br><span class="line">&gt; Task :app:compileDebugKotlin // 编译Kotlin</span><br><span class="line">&gt; Task :app:prepareLintJar</span><br><span class="line">&gt; Task :app:generateDebugSources</span><br><span class="line">&gt; Task :app:javaPreCompileDebug // 预编译Java</span><br><span class="line">&gt; Task :app:compileDebugJavaWithJavac // 编译Java</span><br><span class="line">&gt; Task :app:instantRunMainApkResourcesDebug</span><br><span class="line">...</span><br><span class="line">&gt; Task :app:mergeDebugShaders // 继续处理资源，Shaders和Assets</span><br><span class="line">&gt; Task :app:compileDebugShaders</span><br><span class="line">&gt; Task :app:generateDebugAssets</span><br><span class="line">&gt; Task :app:mergeDebugAssets</span><br><span class="line">&gt; Task :app:validateSigningDebug // 签名</span><br><span class="line">&gt; Task :app:signingConfigWriterDebug</span><br><span class="line">&gt; Task :app:processInstantRunDebugResourcesApk</span><br><span class="line">...</span><br><span class="line">&gt; Task :app:compileDebugNdk // NDK</span><br><span class="line">&gt; Task :app:mergeDebugJniLibFolders // JNI</span><br><span class="line">&gt; Task :app:transformNativeLibsWithMergeJniLibsForDebug</span><br><span class="line">&gt; Task :app:processDebugJavaRes // 处理Java Resources</span><br><span class="line">&gt; Task :app:transformResourcesWithMergeJavaResForDebug</span><br><span class="line">&gt; Task :app:transformNativeLibsAndResourcesWithJavaResourcesVerifierForDebug</span><br><span class="line">&gt; Task :app:transformClassesWithInstantRunForDebug</span><br><span class="line">&gt; Task :app:transformClassesAndClassesEnhancedWithInstantReloadDexForDebug</span><br><span class="line">&gt; Task :app:incrementalDebugTasks</span><br><span class="line">&gt; Task :app:preColdswapDebug</span><br><span class="line">&gt; Task :app:fastDeployDebugExtractor</span><br><span class="line">&gt; Task :app:generateDebugInstantRunAppInfo</span><br><span class="line">&gt; Task :app:transformClassesWithDexBuilderForDebug</span><br><span class="line">&gt; Task :app:transformDexArchiveWithExternalLibsDexMergerForDebug</span><br><span class="line">&gt; Task :app:transformDexArchiveWithDexMergerForDebug</span><br><span class="line">&gt; Task :app:transformDexWithInstantRunDependenciesApkForDebug</span><br><span class="line">&gt; Task :app:instantRunSplitApkResourcesDebug</span><br><span class="line">&gt; Task :app:transformDexWithInstantRunSlicesApkForDebug</span><br><span class="line">&gt; Task :app:packageDebug // 打包</span><br><span class="line">&gt; Task :app:buildInfoGeneratorDebug</span><br><span class="line">&gt; Task :app:compileDebugSources</span><br><span class="line">&gt; Task :app:assembleDebug</span><br></pre></td></tr></table></figure>

<p>接下来会运行<code>installDebug</code>。就是简单地把apk push到设备上安装。</p>
<p>最后运行adb打开app的launcher Activity。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发的一些知识</title>
    <url>/2018/12/31/android-requirements/</url>
    <content><![CDATA[<p>一些Android开发的知识。</p>
<span id="more"></span>

<ol>
<li><p>At a high level, what does the Android architecture look like?</p>
<p> <a href="https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements-architecture.md">https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements-architecture.md</a></p>
</li>
<li><p>At a high level, what happens when you hit the build button on Andorid Studio?</p>
<p> <a href="https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements-start-button.md">https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements-start-button.md</a></p>
</li>
<li><p>What happens when you install an application on the device?</p>
<p> <a href="https://stackoverflow.com/questions/7773360/what-exactly-happens-when-i-install-an-android-application">https://stackoverflow.com/questions/7773360/what-exactly-happens-when-i-install-an-android-application</a></p>
</li>
<li><p>How Dalvik and ART VMs work?</p>
<p> <a href="https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements-dalvik-art.md">https://github.com/DeweyReed/site/blob/master/source/_posts/android-requirements-dalvik-art.md</a></p>
</li>
<li><p>How does Inter-Process-Communication work on Android？</p>
<p> 来自Linux的跨进程通信，Android有自己的实现。用于不同Android Components之间如何通信。有多种机制：Intents、Bundles、Binders、Service、BroadcastReceivers。这些实现为通信提高了安全性。</p>
<p> 一些情况可以需要ALDL来实现跨进程通信：<a href="https://developer.android.com/guide/components/aidl">https://developer.android.com/guide/components/aidl</a></p>
</li>
<li><p>How are apps sandboxed and why does it matter?</p>
<p> <a href="https://source.android.com/security/app-sandbox">https://source.android.com/security/app-sandbox</a></p>
<p> 借用了Linux的用户权限系统来给每个应用提供各自的权限，达到了应用分离、沙箱的效果。默认情况下，普通应用没有跟其他应用和系统应用互动的权限。</p>
</li>
<li><p>Processes and application lifecycle</p>
<p> <a href="https://developer.android.com/guide/components/activities/process-lifecycle">https://developer.android.com/guide/components/activities/process-lifecycle</a></p>
<p> 应用在需要运行时，创建进程。再不再运行且系统需要内存时回收。系统根据一个应用正在运行中的组件来给应用分等级，并在需要内存时，从低等级开始回收。</p>
<p> BroadcastReceiver在返回之后，系统就会认为它没用了。需要回收时就会清理掉它和它产生的线程。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android Resources小研究</title>
    <url>/2020/01/12/android-resources-test/</url>
    <content><![CDATA[<p>研究了一下如何获取各种资源，这里用颜色举例，其他类型没有尝试，但应该大同小异。</p>
<span id="more"></span>

<p>我们在<code>styles.xml</code>设置<code>&lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</code>。</p>
<h2 id="R-color-colorPrimary-gt-Color-Int"><a href="#R-color-colorPrimary-gt-Color-Int" class="headerlink" title="R.color.colorPrimary -&gt; Color Int"></a><code>R.color.colorPrimary</code> -&gt; Color Int</h2><p><code>ContextCompat.getColor(context, R.color.colorPrimary)</code> -&gt; Color Int</p>
<h2 id="R-attr-colorPrimary-gt-Color-Int"><a href="#R-attr-colorPrimary-gt-Color-Int" class="headerlink" title="R.attr.colorPrimary -&gt; Color Int"></a><code>R.attr.colorPrimary</code> -&gt; Color Int</h2><p><strong>这里的Context需要带Theme的Context，比如是一个<code>ContextThemeWrapper</code>或是Activity/View的Context，不然什么也拿不到。下个例子同理。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ColorInt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">themeColor</span><span class="params">(<span class="meta">@AttrRes</span> attrRes: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = obtainStyledAttributes(<span class="literal">null</span>, intArrayOf(attrRes))</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.getColor(<span class="number">0</span>, Color.RED)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a.recycle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>context.themeColor(R.attr.colorPrimary)</code> -&gt; Color Int</p>
<h2 id="R-attr-colorPrimary-gt-R-color-colorPrimary-Color-Res"><a href="#R-attr-colorPrimary-gt-R-color-colorPrimary-Color-Res" class="headerlink" title="R.attr.colorPrimary -&gt; R.color.colorPrimary(Color Res)"></a><code>R.attr.colorPrimary</code> -&gt; <code>R.color.colorPrimary</code>(Color Res)</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ColorRes</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">themeRes</span><span class="params">(<span class="meta">@AttrRes</span> attrRes: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = obtainStyledAttributes(<span class="literal">null</span>, intArrayOf(attrRes))</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.getResourceId(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a.recycle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>context.themeRes(R.attr.colorPrimary)</code> -&gt; <code>R.color.colorPrimary</code></p>
<p>一个更有用的例子是<code>context.themeRes(R.attr.colorControlActivated)</code> -&gt; <code>R.color.colorAccent</code>(通常情况下是这个值)</p>
<h2 id="拦截View"><a href="#拦截View" class="headerlink" title="拦截View"></a>拦截<code>View</code></h2><p>比如拦截<code>Button</code>的<code>android:textColor</code>和<code>app:backgroundTint</code>。</p>
<p>首先继承<code>AppCompatButton</code>或<code>MaterialButton</code>。</p>
<p>新建<code>attrs.xml</code>并塞入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;Theme_Button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;backgroundTint&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后就可以</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">context.withStyledAttributes(<span class="keyword">set</span>, attrs, defStyleAttr, defStyleRes) &#123;</span><br><span class="line">    getColorStateList(R.styleable.Theme_Button_android_textColor)</span><br><span class="line">    getColorStateList(R.styleable.Theme_Button_backgroundTint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android创建快捷方式图标的简单快速方法</title>
    <url>/2019/03/11/android-shortcut-icon/</url>
    <content><![CDATA[<p>从Google Material Icons或其他地方拉一个<strong>24dp</strong>的vector，1分钟内创建其对应的快捷方式图标。</p>
<span id="more"></span>

<ol>
<li><p>修改<code>viewportWidth</code>和<code>viewportHeight</code>为<code>48.0</code>。</p>
</li>
<li><p>把现有的所有<code>&lt;path&gt;...&lt;/path&gt;</code>放到一个<code>&lt;group&gt;</code>中，并添加<code>translate</code>：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:translateX</span>=<span class="string">&quot;12&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:translateY</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 原来的path，记得改颜色--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在<code>&lt;group&gt;</code>前添加这一段（就是画了个圆）:</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillColor</span>=<span class="string">&quot;#F5F5F5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathData</span>=<span class="string">&quot;M24,24m-22,0a22,22 0,1 1,44 0a22,22 0,1 1,-44 0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>完成！我记得这样的结果是符合MaterialDesign的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android储存方案研究及分析</title>
    <url>/2020/01/25/android-storage/</url>
    <content><![CDATA[<p>自从Android Q引入了Scoped Storage，储存问题就像在Kotlin Coroutines之前的Android多线程，八仙过海，各显神通，而且每种方案的都有其长处和短处，Android也有了<del>一万</del>多种储存方案。那么在Google决定开发一个Android StorageX来解决这个问题之前，我自己先来捋一捋，正好最近<a href="https://developer.android.com/guide/topics/data">关于储存的官方文档</a>也更新了。</p>
<p>本文只考虑棒棒糖之后的设备。因为<code>SharedPreference</code>和<code>Sqlite(Room)</code>没啥好说的，本文主要研究<code>MediaStore</code>、<code>File</code>和<code>SAF</code>。</p>
<span id="more"></span>

<h2 id="File"><a href="#File" class="headerlink" title="File"></a><code>File</code></h2><p>指的是用于内部储存的<code>getFilesDir()</code>和<code>getCacheDir()</code>和外部的<code>getExternalFilesDir()</code>和<code>getExternalCacheDir()</code>，不要权限，卸载后会消失。</p>
<p>除了直接用<code>File</code>的API外，还可以用<code>Context</code>的<code>context.openFileOutput(filename, Context.MODE_PRIVATE)</code>及其其他方法来达到同样的效果（虽然我觉得后者挺难用而且有点坑）。</p>
<h2 id="MediaStore"><a href="#MediaStore" class="headerlink" title="MediaStore"></a><code>MediaStore</code></h2><blockquote>
<p>READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE when accessing other apps’ files on Android 10 (API level 29) or higher</p>
<p>Permissions are required for all files on Android 9 (API level 28) or lower</p>
</blockquote>
<p>官方文档中说，用这个API(<code>MediaStore</code> + <code>ContentResolver</code>)来读写三种内容：图片、音频和视频。Q之前必须要权限，Q及之后读别人的文件才要权限。</p>
<p>这句话意味着Q及之后，用这个方法<strong>写入</strong>和<strong>读取自己的写入的文件(Uri)<strong>是</strong>不需要权限</strong>的，测试结果也的确是这样的。</p>
<p>这里有个问题，Q及之后是可以通过<code>RELATIVE_PATH</code>把图片保存进相册文件夹中的，但在之前是不能的，这时只能用已被废弃的硬编码 + <code>File</code>来储存了。</p>
<p>此外有一个<code>MediaStore.Downloads</code>，只针对Q及之后，但似乎没啥用？</p>
<p>此外有一个<code>MediaStore.Files</code>，Q之后显示应用创建的图片、音频和视频。</p>
<p>总结一下，Q之前需要读写外部需要权限，Q及之后如果只是读写自己的内容，完全可以不要权限啦。</p>
<h2 id="SAF"><a href="#SAF" class="headerlink" title="SAF"></a>SAF</h2><p>上述未包含的其他文件，不需要权限，读写单个文件很方便，<a href="https://developer.android.com/training/data-storage/shared/documents-files">文档里很清楚</a>。</p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><p>这里列举一些我常用到的情况。</p>
<h3 id="导出-导入一个备份文件"><a href="#导出-导入一个备份文件" class="headerlink" title="导出/导入一个备份文件"></a>导出/导入一个备份文件</h3><p>SAF。导出时还能让用户命名和选择位置。不要权限。</p>
<h3 id="分享一个文件"><a href="#分享一个文件" class="headerlink" title="分享一个文件"></a>分享一个文件</h3><p><code>FileProvider</code> + <code>FLAG_GRANT_READ_URI_PERMISSION</code>导出为Uri，然后用<code>ShareCompat</code>分享。文件放内部储存居然也可以。</p>
<p>但是呢，如果项目中用了一些撒币的第三方分享库，而这些垃圾玩意儿只支持分享<code>File</code>和路径，这就有点麻烦了。解决方案有：</p>
<ol>
<li>把文件放到应用的外部私有文件夹中，然后把<code>File</code>或路径交给那些没有实现Scoped Storage的应用。但这意味着未来某个Android版本如果强制要求Scoped Storage，又得改代码。</li>
<li>如果文件是图片的话，可以考虑分享一张小尺寸的Bitmap。</li>
<li>偷梁换柱。依然使用<code>FileProvider</code>生成的Uri搭配<code>ShareCompat</code>分享，但设置<code>Intent</code>的package为对应应用的包名，如果解析Activity后没有对应的可启动Activity，就清除package后再启动分享选择器。但这么做难以处理某个应用的多种分享方式，比如微信分享和朋友圈分享，要么自己去找对应的Activity名字并承担可能失效的后果，要么只能用对应应用的难用且坑多分享库了。</li>
</ol>
<h3 id="分享一个Bitmap"><a href="#分享一个Bitmap" class="headerlink" title="分享一个Bitmap"></a>分享一个<code>Bitmap</code></h3><p>把<code>Bitmap</code>保存到文件里，再<a href="#%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6">分享一个文件</a>。</p>
<h3 id="选择音乐、图片"><a href="#选择音乐、图片" class="headerlink" title="选择音乐、图片"></a>选择音乐、图片</h3><p>SAF可以选单个文件，不要权限。选多个文件或者要自定义UI的话，还是乖乖<code>MediaStore</code> + 读取权限吧。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>在Activity启动时弹出软键盘并在其之上显示内容</title>
    <url>/2023/01/11/android-soft-keyboard-oncreate/</url>
    <content><![CDATA[<p>想要在Activity一启动就显示如下状态，还要有一个不乱跳的动画，这比预想中要复杂不少。</p>
<table>
<thead>
<tr>
<th align="center">屏幕</th>
</tr>
</thead>
<tbody><tr>
<td align="center">状态栏<br>空白<br>内容<br>紧贴着<br>软键盘<br>导航栏</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>第一次尝试了<code>WindowCompat.setDecorFitsSystemWindows(window, false)</code> + <code>ViewCompat.setWindowInsetsAnimationCallback</code>，但问题在于：</p>
<ol>
<li><p>有的手机上，在动画结束后，软键盘的高度有时会少十几二十个dp。</p>
<p> 在onCreate中唤起动画时，一定几率出现。原因不明。</p>
<p> 如果是用户点击某个按钮后再唤起动画，是没问题的。</p>
</li>
<li><p>软键盘从底部升起时，内容会先显示在底部，然后跟随动画升起。</p>
<p> 这样的效果还行，但很突兀。除非让内容跟随升起时，有一个从小变大动画。</p>
</li>
</ol>
<p>无奈之下，不再使用Edge-to-edge。而使用Activity的<code>android:windowSoftInputMode=&quot;adjustResize&quot;</code>。效果立竿见影，不会再出现高度缺少的问题了。</p>
<p>但第二个问题依然有。一直以为无能为力了，但直到前几天发现Todoist的一个快捷方式做到了。</p>
<p>在一顿反编译后，发现它们也用了<code>adjustResize</code>。虽然没能找到具体实现，但我有了新的想法。</p>
<p><code>adjustResize</code>的实现是Activity自动给Root view增加Padding。那么如果我们记忆之前的Padding，并在之后的onCreate中重复使用，那么就不会跳跃了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里用了JetpackCompose，所以override这个。</span></span><br><span class="line"><span class="comment">// 如果用XML，就override只有一个参数的setContentView。</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContentView</span><span class="params">(view: <span class="type">View</span>?, params: <span class="type">ViewGroup</span>.<span class="type">LayoutParams</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.setContentView(view, params)</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用之前储存的底部Padding</span></span><br><span class="line">    view.updatePadding(bottom = viewModel.bottomHeight)</span><br><span class="line"></span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(view) &#123; _, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> bottom = insets.getInsets(</span><br><span class="line">            WindowInsetsCompat.Type.ime() or WindowInsetsCompat.Type.navigationBars()</span><br><span class="line">        ).bottom</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bottom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            view.updatePadding(bottom = bottom)</span><br><span class="line">            <span class="comment">// 储存好底部Padding，供下次启动使用</span></span><br><span class="line">            viewModel.setBottomPadding(bottom)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案的优点是：</p>
<ol>
<li>内容只会在第一次时跳跃。</li>
<li>可以跟随软键盘高度变化，比如切换语言时。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>天天坏，天天修的Android Studio</title>
    <url>/2020/09/20/android-studio-is-broken/</url>
    <content><![CDATA[<p>记录了个人在确定不是代码问题后，如何修理坏掉的Android Studio的一些经验。</p>
<span id="more"></span>

<p>“坏掉”指的是所有不是自己代码问题的问题。</p>
<h2 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h2><p><a href="https://stackoverflow.com/a/52499659/5507158">曾经的某些AS版本和Dagger的某些版本不兼容</a>，而Dagger出了问题，多数人会先怀疑自己（而且多数情况也的确是自己的问题）。现在有了Hilt，问题会好很多。所以针对Dagger的问题，先学好Dagger，再去Issues里逛一逛。</p>
<p>确认代码没问题后，可以尝试将项目或全局的<code>gradle.properties</code>中的各种配置注释掉重新Build一次。各种为了加速Gradle的配置有时会帮倒忙。</p>
<p>最近发现当<code>DaggerAppComponent</code>中有类型不匹配、缺少Injector的问题时，手动修改生成的<code>DaggerAppComponent</code>，然后重新Build，有时能解决办法，当然这是在确信自己的Dagger代码无误，且各种Clean、清缓存都不起作用的前提下。</p>
<p>2021新发现的方法！给类改名字。</p>
<h2 id="git-clean-fdx"><a href="#git-clean-fdx" class="headerlink" title="git clean -fdx"></a><code>git clean -fdx</code></h2><p>删除所有没被Git管理的文件夹和文件。Android Studio中的Clean Project有时不够用。</p>
<h2 id="修改settings-gradle中的rootProject-name"><a href="#修改settings-gradle中的rootProject-name" class="headerlink" title="修改settings.gradle中的rootProject.name"></a>修改<code>settings.gradle</code>中的<code>rootProject.name</code></h2><p>如果没有<code>rootProject.name</code>，新建一个Android项目，参考里面的示例代码。</p>
<p>把<code>rootProject.name = &quot;ProjectName&quot;</code>中的<code>ProjectName</code>修改为任意名字，保险起见重启一下AS，再修改回原名字，再重启一下AS。这个方法可以解决一些Gradle文件不在IDE中的Android标签下显示的问题。</p>
<h2 id="删除Gradle缓存"><a href="#删除Gradle缓存" class="headerlink" title="删除Gradle缓存"></a>删除Gradle缓存</h2><p>最近遇到一个问题，Kotlin Extension Functions不被识别，上述方案都试过了没用。最后只好打起了Gradle的主意。</p>
<p>除了<code>.gradle/gradle.properties</code>，把<code>.gradle</code>和<code>.m2</code>都删掉。因为小文件很多，删除时间很长，所以要一次性永久删除，如果先丢到回收站，等待时间要翻倍。</p>
<h2 id="删除Android-Studio缓存"><a href="#删除Android-Studio缓存" class="headerlink" title="删除Android Studio缓存"></a>删除Android Studio缓存</h2><p>最近升级到4.2后，遇到问题仅删除Gradle缓存已经不够了。导出AS设置，然后把所有AS缓存都删光，然后重启。相当于重装了。</p>
<h2 id="deep-clean"><a href="#deep-clean" class="headerlink" title="deep-clean"></a><code>deep-clean</code></h2><p>使用Github的<a href="https://github.com/rock3r/deep-clean">deep-clean</a>。</p>
<p>因为破坏力太大，所以个人还没使用过，不过可以参考其中删除了哪些文件和文件夹。</p>
<p>通常是不需要删除IDE配置文件的，而且个人还从没走到那个地步。希望未来也不需要吧。</p>
<h2 id="改变项目文件路径"><a href="#改变项目文件路径" class="headerlink" title="改变项目文件路径"></a>改变项目文件路径</h2><p>最近遇到了ID解析不出来。发现可以先把项目放到一个新文件夹中，然后再用AS打开项目。之后再把项目从文件夹中移出来。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>个人使用的Android Studio配置</title>
    <url>/2024/02/12/android-studio-settings/</url>
    <content><![CDATA[<p>Android Studio的每个新版本都或多或少有点问题，因此每次都重新安装并手动配置来避免配置继承的问题。</p>
<span id="more"></span>

<ul>
<li>Export <code>Live Template</code></li>
<li><code>Appearance &amp; Behavior</code><ul>
<li><code>Appearance</code><ul>
<li><code>Theme</code>: <code>Darcula</code>/<code>Dark</code></li>
<li><code>UI Options</code> - Disable <code>Smooth scrolling</code></li>
</ul>
</li>
<li><code>System Settings</code><ul>
<li><code>HTTP Proxy</code></li>
<li><code>Memory Settings</code></li>
</ul>
</li>
</ul>
</li>
<li><code>Keymap</code>(Delete old keys)<ul>
<li><code>ShowProjectStructureSettings</code>: Empty</li>
<li><code>Type alias</code>: Empty</li>
<li><code>Show vcs Log</code>: Alt + 3</li>
<li><code>Show Logcat</code>: Alt + 4</li>
<li><code>Show Local Changes</code>: Alt + 2</li>
<li><code>Maximize/Restore Active Dialog</code>: Ctrl + Alt + Shift + M</li>
<li><code>Compare with Clipboard</code>: Ctrl + Alt + Shift + C</li>
</ul>
</li>
<li><code>Editor</code><ul>
<li><code>General</code> - <code>On Save</code> - Enable <code>Ensure every saved file ends with a line break</code><ul>
<li><code>Auto Import</code>: Enable 2 <code>Add unambiguous imports on the fly</code>, <code>Optimize imports on the fly</code></li>
<li><code>Appearance</code><ul>
<li>Disable <code>Caret blinking</code></li>
<li>Disable <code>Show line numbers</code></li>
<li>Disable <code>Show Sticky lines while scrolling</code></li>
<li>Enable <code>Show method separators</code></li>
<li>Disable <code>Render documentation comments</code> and <code>Reader Mode</code></li>
</ul>
</li>
<li><code>Code Completion</code> - Disable <code>Match case</code></li>
<li><code>Console</code> - <code>Default Encoding</code>: <code>UTF-8</code></li>
<li><code>Smart Keys</code><ul>
<li>Enable <code>Use &quot;CamelHumps&quot; Words</code></li>
<li>Disable `Reformat again to remove custom line breaks</li>
</ul>
</li>
</ul>
</li>
<li><code>Font</code> - <code>Font</code>: <code>Consolas</code>; <code>Size</code>: <code>22.0</code></li>
<li><code>Color Scheme</code> - <code>Console Font</code> - <code>Size</code>: <code>16</code>; <code>Line height</code>: <code>0.8</code></li>
<li><code>Code Style</code>: <code>Scheme: IDE</code><ul>
<li><code>Groovy</code><ul>
<li><code>Code Generation</code><ul>
<li>Disable <code>Line comment at first column</code></li>
<li>Enable <code>Add a space at line comment start</code> and <code>Enforce on reformat</code></li>
</ul>
</li>
</ul>
</li>
<li><code>Kotlin</code><ul>
<li>Set from <code>Kotlin style guide</code></li>
<li><code>Tabs and Indents</code> - <code>Continuation Indent</code>: 4</li>
<li><code>Wrapping and Braces</code>: Disable <code>New line after multiline entry</code></li>
<li><code>Code Generation</code><ul>
<li>Disable <code>Line comment at first column</code></li>
<li>Enable <code>Add a space at line comment start</code> and <code>Enforce on reformat</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Design Tools</code>: <code>Split</code>, <code>Split</code>, <code>Split</code>, <code>Code</code>, <code>Code</code></li>
<li><code>Inlay Hints</code>: Disable <code>Code Vision</code></li>
</ul>
</li>
<li><code>Plugins</code><ul>
<li><code>ADB Idea</code></li>
<li><code>Archive Browser</code></li>
<li><code>JsonToKotlinClass</code> + Configure manually</li>
<li><code>Nyan Progress Bar</code></li>
<li><code>String Manipulation</code></li>
<li>[Optinal] <code>Kotlin Multiplatform Mobile</code></li>
<li>[Optinal] <code>GLSL Support</code></li>
<li>[Optinal] <code>Wavefront OBJ</code></li>
</ul>
</li>
<li><code>Version Control</code> - <code>Commit</code><ul>
<li>Disable <code>Use non-modal commit interface</code></li>
<li><code>Before Commit</code>: Enable all</li>
</ul>
</li>
<li><code>Build, Execution, Deployment</code><ul>
<li><code>Deployment</code>: Enable all</li>
</ul>
</li>
<li><code>Tools</code><ul>
<li><code>External Tools</code><ul>
<li><code>Avocado</code><ul>
<li><code>Program</code>: <code>...\Yarn\bin\avocado.cmd</code>(<code>Show Hidden Files and Directories</code>)</li>
<li><code>Argument</code>: <code>-i $FileName$</code></li>
<li><code>Working directory</code>: <code>$FileDir$</code></li>
</ul>
</li>
</ul>
</li>
<li><code>Emulator</code>: Disable <code>Launch in the Running Devices tool window</code></li>
</ul>
</li>
<li>Open a project</li>
<li>Clean <code>Gutter Icons</code> and reorder tabs manually</li>
<li>Reorder window layouts and <code>Store Current Layout as Default</code></li>
<li><code>Keymap</code>(Delete old keys)<ul>
<li><code>Build</code>(Tool Window): Alt + 5</li>
</ul>
</li>
<li><code>Editor</code><ul>
<li><code>Live Template</code>: Disable compose related; Import from settings zip</li>
</ul>
</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>L</code><ul>
<li>Enable <code>Optimize imports</code>, <code>Code cleanup</code>, and <code>Rearrange code</code></li>
</ul>
</li>
<li>Disable <code>Show Project Gradient</code> in the toolbar</li>
<li><code>Log</code> - <code>COMPACT</code>, Show <code>Tag Names</code></li>
<li>Commit something and check changes:<ul>
<li>Enable <code>Show Diff in Separate Window</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android System UI</title>
    <url>/2019/05/06/android-system-ui/</url>
    <content><![CDATA[<p>整理自<a href="https://chris.banes.dev/talks/2017/becoming-a-master-window-fitter-lon/">Becoming a master window fitter 🔧)</a>，解释那复杂的Android状态栏与导航栏和应用界面的关系。</p>
<p>只是一些笔记。</p>
<span id="more"></span>

<p>本文用“😲”代表“状态栏与导航栏”这七个字。</p>
<h2 id="setSystemUiVisibility"><a href="#setSystemUiVisibility" class="headerlink" title="setSystemUiVisibility"></a><a href="https://developer.android.com/reference/android/view/View.html#setSystemUiVisibility(int)">setSystemUiVisibility</a></h2><p>SYSTEM_UI_FLAG_</p>
<ul>
<li>VISIBLE：让😲回来，重新显示</li>
<li>LOW_PROFILE：让😲暗淡</li>
<li>HIDE_NAVIGATION</li>
<li>FULLSCREEN</li>
</ul>
<p>SYSTEM_UI_FLAG_</p>
<ul>
<li>IMMERSIVE：让😲消失，但一有操作就会回来。</li>
<li>IMMERSIVE_STICKY：和上面一个一起用，但有操作时，让😲悬浮出现，稍等后再消失。</li>
</ul>
<p>SYSTEM_UI_FLAG_</p>
<ul>
<li>LIGHT_STATUS_BAR</li>
<li>LIGHT_NAVIGATION_BAR</li>
</ul>
<p>让😲浅底深色。默认是深底浅色。</p>
<p>SYSTEM_UI_FLAG_</p>
<ul>
<li>LAYOUT_STABLE</li>
<li>LAYOUT_HIDE_NAVIGATION</li>
<li>LAYOUT_FULLSCREEN</li>
</ul>
<p>跟应用内容的显示有关系。</p>
<p>让应用内容在😲后面显示：LAYOUT_STABLE or LAYOUT_FULLSCREEN or LAYOUT_HIDE_NAVIGATION，后文用WTFs代替。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.systemUiVisibility =</span><br><span class="line">    <span class="comment">// Tells the system that you wish to be laid out</span></span><br><span class="line">    <span class="comment">// as if the navigation bar was hidden</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or</span><br><span class="line">    <span class="comment">// Optional, if we want you be laid out fullscreen,</span></span><br><span class="line">    <span class="comment">// behind the status bar</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or</span><br><span class="line">    <span class="comment">// Tells the system that you wish to be laid out at</span></span><br><span class="line">    <span class="comment">// the most extreme scenario of any other flags</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br></pre></td></tr></table></figure>

<p>From <code>Dark Theme &amp; Gesture Navigation (Google I/O&#39;19)</code></p>
<h2 id="android-windowTranslucentStatus和android-windowTranslucentNavigation"><a href="#android-windowTranslucentStatus和android-windowTranslucentNavigation" class="headerlink" title="android:windowTranslucentStatus和android:windowTranslucentNavigation"></a><code>android:windowTranslucentStatus</code>和<code>android:windowTranslucentNavigation</code></h2><p>从KitKat引入。让😲把透明、渐隐。应用内容在它们后面显示。它们会自动应用WTFs。渐隐不能改变颜色。</p>
<h2 id="android-windowDrawsSystemBarBackgrounds"><a href="#android-windowDrawsSystemBarBackgrounds" class="headerlink" title="android:windowDrawsSystemBarBackgrounds"></a><code>android:windowDrawsSystemBarBackgrounds</code></h2><p>从Lollipop引入。默认已开启。</p>
<p>把😲放到了应用内容的Window中，好让我们可以<code>activity.window.setStatusColor</code>。</p>
<p>和<code>android:windowTranslucent</code>有冲突。后者会覆盖前者设置的😲的颜色，且会关闭<code>android:windowDrawsSystemBarBackgrounds</code>，这会导致😲不再是应用内容的一部分，从而可能导致涉及到😲SharedElement动画失效。</p>
<p>因此为了得到半透明的😲颜色，可以用一个半透明的<code>android:statusBarColor</code>或<code>android:navigationBarColor</code>，而避免使用<code>android:windowTranslucent</code>。</p>
<h2 id="android-fitSystemWindows-quot-true-quot"><a href="#android-fitSystemWindows-quot-true-quot" class="headerlink" title="android:fitSystemWindows=&quot;true&quot;"></a><code>android:fitSystemWindows=&quot;true&quot;</code></h2><p>让这个View自己使用Padding填充周围，让它的内容不和会😲重叠。几乎只有MaterialCompoents（CoordinatorLayout、DrawerLayout、CollapsingToolbarLayout等）才对这个属性有反应。</p>
<p>在和WTFs共同使用后，应用内容就可以既在😲后显示，也不和😲重叠。</p>
<p><code>DrawerLayout</code>设置<code>android:fitSystemWindows=&quot;true&quot;</code>后，会自动设置WTFs。</p>
<p>可以给子View设置，选择是否让子View出现在😲后。</p>
<h2 id="WindowInsets"><a href="#WindowInsets" class="headerlink" title="WindowInsets"></a><code>WindowInsets</code></h2><p>正确的使用😲大小的方式。不许使用resources或hard-coded尺寸，得用这个。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.setOnApplyWindowInsetsListener &#123; _, insets -&gt;</span><br><span class="line">    <span class="keyword">return</span> insets.comsumeSystemWindowInsets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p><code>CoordinatorLayout</code></p>
<ul>
<li><code>app:statusBarBackground</code></li>
</ul>
<p><code>CollapsingToolbarLayout</code></p>
<ul>
<li>statusBar: <code>app:statusBarScrim</code>。默认colorPrimaryDrak。</li>
<li>contentScrim: <code>app:contentScrim</code>。默认@null。</li>
</ul>
<h2 id="参考与资源"><a href="#参考与资源" class="headerlink" title="参考与资源"></a>参考与资源</h2><ul>
<li><a href="https://chris.banes.dev/talks/2017/becoming-a-master-window-fitter-lon/">Becoming a master window fitter 🔧)</a></li>
<li><a href="https://medium.com/androiddevelopers/windowinsets-listeners-to-layouts-8f9ccc8fa4d1">WindowInsets — Listeners to layouts</a></li>
<li><a href="https://gist.github.com/chrisbanes/73de18faffca571f7292">SystemUiHelper.java</a></li>
<li><a href="https://github.com/DreaminginCodeZH/SystemUiHelper">SystemUiHelper</a></li>
<li><a href="https://github.com/mikepenz/Materialize">Materialize</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发后悔的九件事</title>
    <url>/2022/12/20/android-things-i-wish-i-knew/</url>
    <content><![CDATA[<p>RT</p>
<span id="more"></span>

<h2 id="本应适度使用Material-Components"><a href="#本应适度使用Material-Components" class="headerlink" title="本应适度使用Material Components"></a>本应适度使用Material Components</h2><p>虽说部分组件，诸如<code>MaterialButton</code>、<code>MaterialCardView</code>和<code>CoordinatorLayout</code>，自定义程度很高，用起来也很顺手。但另外一些，诸如<code>TabLayout</code>、<code>BottomAppBar</code>和<code>TopAppBar</code>等，需要诸多奇技淫巧才能符合UI。到头来，其实不如用<code>TextView</code>和<code>ImageView</code>从头攒一个，来得容易实现和维护。</p>
<p>更别提从Material 3开始，想要把背景颜色设置为一个特定值都变得困难起来。</p>
<h2 id="本应谨慎使用Post"><a href="#本应谨慎使用Post" class="headerlink" title="本应谨慎使用Post"></a>本应谨慎使用Post</h2><p>在<code>onCreate</code>或<code>onCreateView</code>中，所有View还未被定位和绘制。这时获取其宽度或高度会为0。一个常见的方法是将获取尺寸的代码放到一个<code>post &#123;&#125;</code>中（我最早从AdMob的早期文档中看到类似的用法）。大多数情况下，问题会得到解决。</p>
<p>但这会打开一个潘多拉魔盒。这个方案意味着每次修改<code>View</code>的属性后，想要得到修改后的状态，就得Post一次。逻辑复杂之后，代码库很快就会充斥着Post嵌套Post多次的糟糕实现。</p>
<p>根据<a href="https://cheesecakelabs.com/blog/understanding-android-views-dimensions-set/">Understanding when and how Android Views have dimensions set</a>，<code>View.doOnLayout()</code>是比<code>Post</code>更好的方案。但这依然解决不了嵌套太多的问题。而最终解决方案则和下一条有关。</p>
<h2 id="本应在View层少放业务逻辑"><a href="#本应在View层少放业务逻辑" class="headerlink" title="本应在View层少放业务逻辑"></a>本应在View层少放业务逻辑</h2><p>想法和MVI或Jetpack Compose类似，View收到的永远是UI的状态数据，而业务逻辑全都在ViewModel中。虽然只是把一个文件分为两个文件，但UI实现的复杂度会得到惊人的下降。配合<code>SavedStateHandle</code>，还可以存活过Configuration changes。</p>
<p>常见的Configuration changes不仅是旋转屏幕，还包括深色模式切换、时区变化、一些破手机切换个应用就会被杀等情况。这里还是要早做打算。</p>
<p>这样也可以缓解不少上一条Post嵌套太多的问题。</p>
<h2 id="本应适度使用Single-Activity"><a href="#本应适度使用Single-Activity" class="headerlink" title="本应适度使用Single Activity"></a>本应适度使用Single Activity</h2><p>没人会告诉你，在面对一些核心操作时，Single Activity就力不从心了。</p>
<p>比如在Fragment中放相机预览，每次切换页面后返回时，相机都得重新启动一遍，使用体验很糟糕。</p>
<p>在一些应用核心操作时，最好单独使用一个Activity。这并不意味不需要控制好UI状态，只是不让这些核心状态太容易地被丢失。</p>
<h2 id="本应细心规划Navigation"><a href="#本应细心规划Navigation" class="headerlink" title="本应细心规划Navigation"></a>本应细心规划Navigation</h2><p>如果要在不同屏幕间做约定，最好在顶层设计一些通用抽象的功能。不然未来就看不懂代码了。</p>
<h2 id="本应记录更多日志"><a href="#本应记录更多日志" class="headerlink" title="本应记录更多日志"></a>本应记录更多日志</h2><p>面对一些棘手的Bug，在尝试各种方案的同时，要确保多留一些日志。</p>
<h2 id="本应谨慎使用null"><a href="#本应谨慎使用null" class="headerlink" title="本应谨慎使用null"></a>本应谨慎使用null</h2><p>null代表的是不存在，而不是默认值。使用null就意味需要在之后不断地判断是否为null。</p>
<p>比如用户的主题设置怎么会不存在，最多也就是默认主题。对吧！</p>
<p>能不用null就不用。使用enum、sealed interface或者继承都会优雅的多。</p>
<h2 id="本应注释废弃的功能"><a href="#本应注释废弃的功能" class="headerlink" title="本应注释废弃的功能"></a>本应注释废弃的功能</h2><p>把废弃功能入口关掉就好，谁不知道未来会不会有用。</p>
<h2 id="本应适度使用Singleton"><a href="#本应适度使用Singleton" class="headerlink" title="本应适度使用Singleton"></a>本应适度使用Singleton</h2><p>这里不是用多了，而是用少了。</p>
<p>都怪Android一开始鼓吹不用Singleton，导致我尽可能用依赖注入的<code>@Resuable</code>来控制内存。但是这会让一些简单的操作都复杂起来。</p>
<p>既然一个对象从应用开始之初就会被分配并一直使用，就乖乖用Singleton。性能问题几乎永远不会在于几个Singleton。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发牢骚 - 2021年2月6日</title>
    <url>/2021/02/06/android-thoughts-20210206/</url>
    <content><![CDATA[<p>好几个月没写东西了，主要是因为开发界无新鲜事，没啥可写。今天勉为其难地发发牢骚。</p>
<span id="more"></span>

<h2 id="StateFlow和SharedFlow"><a href="#StateFlow和SharedFlow" class="headerlink" title="StateFlow和SharedFlow"></a><code>StateFlow</code>和<code>SharedFlow</code></h2><p>Kotlin Coroutines的新玩意儿，看样子要在Kotlin项目中替代LiveData，最近的MAD Skills的问答视频中也表达了类似的观点。</p>
<p>但我在UI层使用Coroutines的体验实在难言理想，比如<code>Fragment.viewLifecyclerOwner</code>在<code>Fragment.onViewCreated</code>丢NPE呀，<code>lifecycleScope.launchWhen</code>不正常运行呀、自定义<code>CoroutineScope</code>里的代码不执行呀等，还有<a href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow">文档中那劝退的两段说明</a>。和UI层通信还是乖乖用<code>LiveData</code>吧。</p>
<p><code>callbackFlow</code>和<code>TestCoroutineDispatcher</code>作为实验API已经快两年了吧，JetBrains是不是把它们都忘了呀。</p>
<p>最近浏览了Flutter的异步实现，很是羡慕。突然觉得手里的Coroutines不香了。</p>
<h2 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a><code>Hilt</code></h2><p>Dagger是个好东西，虽然学起来有几丢丢难，但依赖注入让新增功能和测试变得很容易。</p>
<p>Hilt更是好东西，学起来无脑，用起来也简单。</p>
<p>唯一想吐槽的就是这玩意儿虽说还是Alpha，但官方已经到处推荐人使用了。官方说法是，Hilt很稳定啦，我们Google内部的应用也都在用，跑在很多很多设备上都没问题啊，只不过想在正式版前再加点东西、改点东西。可惜我被坑怕了，非正式版的不敢用，正式版了也要等几个修复版才敢用，就这个样子还遇到不少坑哩。</p>
<p>语义化版本是不是只算加分项？</p>
<h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a><code>Android Studio</code></h2><p>IDE开发都是这个样子吗，搬了西瓜丢芝麻，这里修好那里漏？</p>
<p>AS 4.x版本可以说体验极差。Google内部是不是人手三台MBP，每台机器跑10个Android模拟器不带卡。</p>
<p>每天都需要多次重启和Invalidate Cache and Restart。ViewBinding不显示了、资源ID不识别了、Kapt莫名报错了、Dagger生成代码不正常了……</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>也许开发一直都是这个样子吧，还记得AS 2.3的Instant Run坏掉时，到处找解决方案，还参与Stackoverflow讨论的情景。时至今日，嘛也不剩了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android应用白名单指南</title>
    <url>/2019/01/11/android-whitelist-guideline/</url>
    <content><![CDATA[<p>更新日期：2022年9月2日</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>第三方厂商生产的Android设备（包括但不限于一加、华为、三星、小米、魅族、华硕、Wiko、联想、OPPO、VIVO、诺基亚、索尼等，排名根据严重程度分先后），都存在不同程度的强杀后台的问题。具体表现为应用在熄屏或切换到其他应用时，经过短则几十秒，长则十几分钟后，应用被系统强制关闭。</p>
<p>需要用户自行进入系统设置中，设置一些选项才可让应用正常运行。这一过程在本文中称为“白名单”。</p>
<span id="more"></span>

<blockquote>
<p>问：为什么微信、QQ、网易云音乐等应用进入后台后可正常运行？</p>
<p>答：生产厂商给予了这些流行的大众应用默认白名单的特别优待。</p>
</blockquote>
<p>以下资料搜集自网络，请自行参考使用。</p>
<h2 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h2><p><strong>根据推荐度排名分先后</strong></p>
<ol>
<li><p>Github项目<a href="https://dontkillmyapp.com/">dont-kill-my-app</a>，记录了一些流行设备的白名单指南（英文）</p>
</li>
<li><p><a href="https://tasker.joaoapps.com/userguide/en/faqs/faq-problem.html#00">Tasker的白名单指南</a>（英文）</p>
</li>
<li><p><a href="https://sspai.com/post/55264">少数派 - 手机里有无法正常运行的 Android 应用？用这四步手动排查问题</a>（中文）</p>
</li>
<li><p><a href="http://wpengapp.com/lightstart">轻应用</a>的<a href="http://wpengapp.com/romsetting">白名单指南</a>（有图片、中文）</p>
</li>
<li><p><a href="https://bitbucket.org/copluk/acr/issues/607">某个应用的Bitbucket项目中的一个Issue，提供了很多手机手机白名单过程的图片指南</a>（英文）</p>
</li>
<li><p><a href="https://get.slack.help/hc/en-us/articles/360001562747-Known-issues-with-Android-notifications">Slack的帮助文档，提供了很多设备的<strong>通知</strong>白名单的指南</a>（英文）</p>
</li>
</ol>
<h2 id="计时机器的额外指南"><a href="#计时机器的额外指南" class="headerlink" title="计时机器的额外指南"></a>计时机器的额外指南</h2><ol>
<li><p>在应用打开【侧边栏/抽屉/汉堡包】-&gt;【帮助与反馈】-&gt;【白名单指南】，其中有计时机器需要白名单的解释，下方还<strong>可能</strong>会有一些按钮，点击后可以打开设备的一些设置页面。没有的话，就需要参照<a href="#%E6%8C%87%E5%8D%97">上述指南</a>。</p>
</li>
<li><p>华为设备的一张单独的链接：<a href="https://github.com/DeweyReed/site/blob/master/source/_posts/timer-huawei-solution.md">https://github.com/DeweyReed/site/blob/master/source/_posts/timer-huawei-solution.md</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android 12升级笔记</title>
    <url>/2022/06/25/android12-upgrade-notes/</url>
    <content><![CDATA[<p>一些笔记没地方放了就决定丢这里。</p>
<span id="more"></span>

<h2 id="Android-App-Links-verification-changes"><a href="#Android-App-Links-verification-changes" class="headerlink" title="Android App Links verification changes"></a>Android App Links verification changes</h2><p><a href="https://developer.android.com/about/versions/12/behavior-changes-all#web-intent-resolution">https://developer.android.com/about/versions/12/behavior-changes-all#web-intent-resolution</a></p>
<p><a href="https://developer.android.com/about/versions/12/behavior-changes-12#android-app-links-verification-changes">https://developer.android.com/about/versions/12/behavior-changes-12#android-app-links-verification-changes</a></p>
<h2 id="Foreground-service-launch-restrictions"><a href="#Foreground-service-launch-restrictions" class="headerlink" title="Foreground service launch restrictions"></a>Foreground service launch restrictions</h2><p><a href="https://developer.android.com/about/versions/12/behavior-changes-12#foreground-service-launch-restrictions">https://developer.android.com/about/versions/12/behavior-changes-12#foreground-service-launch-restrictions</a></p>
<h2 id="Exact-alarm-permission"><a href="#Exact-alarm-permission" class="headerlink" title="Exact alarm permission"></a>Exact alarm permission</h2><p><a href="https://developer.android.com/about/versions/12/behavior-changes-12#exact-alarm-permission">https://developer.android.com/about/versions/12/behavior-changes-12#exact-alarm-permission</a></p>
<h2 id="Notification-trampoline-restrictions"><a href="#Notification-trampoline-restrictions" class="headerlink" title="Notification trampoline restrictions"></a>Notification trampoline restrictions</h2><p><a href="https://developer.android.com/about/versions/12/behavior-changes-12#notification-trampolines">https://developer.android.com/about/versions/12/behavior-changes-12#notification-trampolines</a></p>
<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p><a href="https://developer.android.com/about/versions/12/features/widgets">https://developer.android.com/about/versions/12/features/widgets</a></p>
<p><a href="https://github.com/android/user-interface-samples/tree/main/AppWidget">https://github.com/android/user-interface-samples/tree/main/AppWidget</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android 13升级笔记</title>
    <url>/2023/02/22/android13-upgrade-notes/</url>
    <content><![CDATA[<p>一些笔记没地方放了就决定丢这里。</p>
<span id="more"></span>

<ul>
<li><p>Notifications</p>
<ul>
<li><a href="https://developer.android.com/about/versions/13/behavior-changes-all#notification-permission">https://developer.android.com/about/versions/13/behavior-changes-all#notification-permission</a></li>
<li><a href="https://developer.android.com/about/versions/13/behavior-changes-all#dismissible-fgs-notifs">https://developer.android.com/about/versions/13/behavior-changes-all#dismissible-fgs-notifs</a></li>
</ul>
</li>
<li><p>RecognitionService</p>
<ul>
<li><a href="https://developer.android.com/about/versions/13/behavior-changes-all#speech-service">https://developer.android.com/about/versions/13/behavior-changes-all#speech-service</a></li>
</ul>
</li>
<li><p>Storage</p>
<ul>
<li><a href="https://developer.android.com/about/versions/13/behavior-changes-13#granular-media-permissions">https://developer.android.com/about/versions/13/behavior-changes-13#granular-media-permissions</a></li>
</ul>
</li>
<li><p>Intent</p>
<ul>
<li><a href="https://developer.android.com/about/versions/13/behavior-changes-all#intents">https://developer.android.com/about/versions/13/behavior-changes-all#intents</a></li>
</ul>
</li>
<li><p>GMS</p>
<ul>
<li><a href="https://developer.android.com/about/versions/13/behavior-changes-13#ad-id">https://developer.android.com/about/versions/13/behavior-changes-13#ad-id</a></li>
</ul>
</li>
<li><p><a href="https://developer.android.com/about/versions/13/features#app-languages">Per-app language preferences</a></p>
</li>
<li><p><a href="https://developer.android.com/about/versions/13/features#copy-paste">Clipboard preview</a></p>
<ul>
<li><a href="https://developer.android.com/guide/topics/text/copy-paste#duplicate-notifications">Avoid duplicate notifications</a></li>
</ul>
</li>
<li><p><a href="https://developer.android.com/about/versions/13/features#predictive-back-nav">Predictive back gesture</a></p>
</li>
<li><p><a href="https://developer.android.com/about/versions/13/features#runtime-receivers">Safer exporting of context-registered receivers</a></p>
</li>
<li><p><a href="https://developer.android.com/about/versions/13/features#photo-picker">Photo picker</a></p>
</li>
<li><p><a href="https://developer.android.com/about/versions/13/features#use-exact-alarm-permission">New permission to use exact alarms</a></p>
</li>
<li><p><a href="https://developer.android.com/about/versions/13/features#large-screens">Tablet and large screen support</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android 15升级笔记</title>
    <url>/2025/01/10/android15-upgrade-notes/</url>
    <content><![CDATA[<p>一些笔记没地方放了就决定丢这里。</p>
<span id="more"></span>

<ul>
<li><a href="https://developer.android.com/about/versions/15/behavior-changes-all#16-kb">Support for 16 KB page sizes</a></li>
<li><a href="https://developer.android.com/about/versions/15/behavior-changes-15#openjdk-api-changes">Collision with <code>MutableList.removeFirst()</code> and <code>MutableList.removeLast()</code> extension functions in kotlin-stdlib</a></li>
<li><a href="https://developer.android.com/about/versions/15/behavior-changes-15#safer-intents">Safer intents</a></li>
<li><a href="https://developer.android.com/about/versions/15/behavior-changes-15#edge-to-edge">Edge-to-edge enforcement</a></li>
<li><a href="https://developer.android.com/about/versions/15/behavior-changes-15#audio-focus">Restrictions on requesting audio focus</a></li>
<li><a href="https://developer.android.com/about/versions/15/behavior-changes-15#other_changes">Secured background activity launches</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android 14升级笔记</title>
    <url>/2024/04/22/android14-upgrade-notes/</url>
    <content><![CDATA[<p>一些笔记没地方放了就决定丢这里。</p>
<span id="more"></span>

<ul>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-all">Schedule exact alarms are denied by default</a>, <a href="https://developer.android.com/about/versions/14/changes/schedule-exact-alarms">https://developer.android.com/about/versions/14/changes/schedule-exact-alarms</a></li>
<li><a href="https://developer.android.com/about/versions/14/changes/partial-photo-video-access#app-gallery-picker">Grant partial access to photos and videos</a></li>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14#secure-fsi">Secure full-screen Intent notifications</a></li>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14#fgs-types">Foreground service types are required</a>, <a href="https://developer.android.com/about/versions/14/changes/fgs-types-required">https://developer.android.com/about/versions/14/changes/fgs-types-required</a></li>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14#safer-intents">Restrictions to implicit and pending intents</a></li>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14#runtime-receivers-exported">Runtime-registered broadcasts receivers must specify export behavior</a></li>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14#background-activity-restrictions">Additional restrictions on starting activities from the background</a></li>
<li><a href="https://developer.android.com/about/versions/14/features#convert-pixels">Convert scaled pixel (sp) units</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>换域名啦</title>
    <url>/2023/06/10/changing-domain/</url>
    <content><![CDATA[<p>由于 <del>不想继续花钱续费域名</del> 想不到心仪的域名，决定用回GitHub的默认域名。平平淡淡才是真。旧域名再续个几年就丢掉了。</p>
<p>本文记录换域名和重定向的历程。</p>
<span id="more"></span>

<p>旧域名是在NameSilo购买的。NameSilo的界面是复古了点，但能出色完成工作。</p>
<p>但在使用其提供的重定向试图将旧域名定向到GitHub默认域名时，发现其不支持HTTPS，导致直接访问链接失败。一番搜索后发现有人提到了用Cloudflare来移花接木。</p>
<p>于是问了问ChatGPT具体该怎么做。走了不少弯路，ChatGPT也说了几个错误的步骤，不过到最后还是帮到了我。从结果上来说，根据Cloudflare的教程导入域名后，保持导入的DNS不变，增加一个Page Rule是最终的解决方案。</p>
<p>接下来就是迁移项目中用过的旧域名了。怕不是要花几年哟。</p>
<p>ChatGPT现阶段虽然错误不少，但我想到了前段时间看的一个神经学家的视频，人类的进化不也是一路犯错过来的嘛。</p>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
  </entry>
  <entry>
    <title>想要自动清空浏览记录</title>
    <url>/2020/08/06/clean-browser-history/</url>
    <content><![CDATA[<p>一直有个心结：在网上冲浪时，不想留下任何痕迹。倒不是因为浏览记录中有什么见不得人的内容（真见不得人就用Tor啦），而是在搜索栏输入一些内容，却看到一些自己以前搜索过的关键词，会有一种被窥探、被监视的糟糕感觉。</p>
<p>每个浏览器都有手动清空包括浏览记录在内的各种信息的一个选项，但是在每次使用完浏览器后，都要手动清空一次太机械、太重复了，而且重复的操作是要抽象出来复用的。于是，我踏上了一条自动清空浏览记录之路。</p>
<span id="more"></span>

<h2 id="不争气的Chrome"><a href="#不争气的Chrome" class="headerlink" title="不争气的Chrome"></a>不争气的Chrome</h2><p>Chrome的设置中并没有退出浏览器时，自动清空浏览记录的设置，反而有一个退出时自动清空Cookie的设置，但我不需要它，因为我还是想要下次启动浏览器时，登陆状态被保存。而且如果在搜索引擎中搜索如何自动清空浏览记录时，几乎全都是这个清空Cookie设置相关的链接。</p>
<p>于是，我求助于Chrome扩展。的确有这么一个扩展<a href="https://chrome.google.com/webstore/detail/clickclean/ghgabhipcejejjmhhchfonmamedcbeod">Click&amp;Clean</a>可以在关闭浏览器时，自动清空浏览记录。它的设置很齐全，也很方便，而且还时不时弹出各种保护隐私的小技巧。</p>
<p>我用了很长一段时间，但是应该是从2019年的某个时候，它的小技巧弹窗开始烦人了，不仅不能永久关闭，还一直循环弹出那些重复的内容。再看Chrome扩展商店中它的评论，会发现有大量的机器人好评，有限的看起来像真人的评论也几乎都在抱怨弹窗。进一步在网络上搜索后，还发现有人怀疑它是间谍软件，但我没找到什么确凿的证据。</p>
<p>这让我不禁思考：它为什么这么做？如果它的弹窗内容是广告，可以理解为要盈利。但它弹的是自己的文章，而且此外也没有什么赢利点。同时考虑到它并不开源，却一直在更新，我对这个扩展的运营模式产生了深深的怀疑。其实，我对不少浏览器扩展的盈利模式都挺疑惑的，除了不少用爱发电的开源扩展，那些成功却又没有明显赢利点的扩展，是怎么存活的呢？</p>
<p>我开始寻找下一个替代品。</p>
<h2 id="开源但还需完善BleachBit"><a href="#开源但还需完善BleachBit" class="headerlink" title="开源但还需完善BleachBit"></a>开源但还需完善BleachBit</h2><p>稍加搜索后，我发现了开源的<a href="https://www.bleachbit.org/">BleachBit</a>，据说希拉里用了都说好（在以前的软件主页中提到过，估计为了避免不必要的麻烦，现在没有了，但<a href="https://en.wikipedia.org/wiki/BleachBit">在维基中还有记录</a>）。</p>
<p>这个软件并不支持关闭浏览器时，自动清空浏览记录，但是我发现可以通过命令行，在某个特定时间或每次开关机时，运行该软件清理浏览记录，而BleachBit也确实提供了<a href="https://docs.bleachbit.org/doc/command-line-interface.html">这么做的详细文档</a>，还包括了各个平台的具体操作指南。</p>
<p>用了一段时间后，我发现它失效了。在翻看它的<a href="https://github.com/bleachbit/bleachbit/issues">Github Issues</a>后，发现的确是个Bug，同时也发现Chrome存放历史记录的方案还挺复杂的。</p>
<p>我等不及Bug修复了，于是决定寻找下一个替代品。</p>
<h2 id="还差临门一脚的Chromium-Edge"><a href="#还差临门一脚的Chromium-Edge" class="headerlink" title="还差临门一脚的Chromium Edge"></a>还差临门一脚的Chromium Edge</h2><p>微软的新Edge现在应该正式推送了，而它也正好内置了关闭浏览器时，自动清空浏览记录的功能，这让我非常满意，也产生了迁移到新Edge的念头。</p>
<p>在把新Edge的设置舔了个干净，并初步尝试后，发现新Edge整体上不错，但在一些糟糕的小细节很破坏<strong>我的体验</strong>，比如语言设置对有些网站不起作用、Google系网站一直推荐Chrome（尤其对我这种给Google Android写代码的人来说）等。</p>
<p>当然，未采用新Edge只是因为现阶段的个人需求造成的。没有类似的需求，且不介意从别的浏览器迁移的话，新版Edge就是完美的解决方案。</p>
<h2 id="目前的解决方案：CCleaner"><a href="#目前的解决方案：CCleaner" class="headerlink" title="目前的解决方案：CCleaner"></a>目前的解决方案：CCleaner</h2><p>BleachBit启发了我：只要清理垃圾的软件支持清理浏览记录和命令行，就可以通过系统中计划任务的机制来达成目的。因为我一直在用<a href="https://www.ccleaner.com/">CCleaner</a>清理垃圾，所以在稍加搜索后，的确发现了<a href="https://www.ccleaner.com/docs/ccleaner/advanced-usage/command-line-parameters">它的命令行接口</a>。尝试后发现效果令人满意。另外，如果是Pro版的话，可以直接用它的智能清理。免费版的话，就需要命令行了。</p>
<p>用了一段时间，发现有几个小缺点：</p>
<ul>
<li>CCleaner默认会清理Cookie，需要在软件中手动关掉。</li>
<li>命令行调用是异步的，且一次清理比较费时，从而导致有时候清理的同时浏览器正在打开的话，会安静地失败。使用了一段时候后，发现是真的有点慢。</li>
<li>不知为何会导致Adobe CC退出登录。</li>
</ul>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p>历时几年的旅途终于告一段落了。如果未来CCleaner也成了流氓软件（现在也有一些还算克制的流氓行为，比如安装时尝试捆绑一个杀毒软件，不过拒绝按钮很大很明显），或者新Edge一骑绝尘，再来更新。</p>
<h2 id="火绒"><a href="#火绒" class="headerlink" title="火绒"></a>火绒</h2><p>CCleaner变成了流氓软件，会在后台不停地向Avast发统计。</p>
<p>下了一个火绒。把各种功能关掉后，手动使用其垃圾清理。</p>
<p>平平淡淡才是真。</p>
<h2 id="回到了BleachBit"><a href="#回到了BleachBit" class="headerlink" title="回到了BleachBit"></a>回到了BleachBit</h2><p>火绒会替代Windows Defender且无法撤销。尝试了其他途径后，最后回到了BleachBit。现在似乎修好了之前的问题。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>Dagger2 入门路线图 (2018年5月)</title>
    <url>/2018/05/20/dagger2-roadmap/</url>
    <content><![CDATA[<p><strong>2019年11月22日 本文已过时 请查看Android官方的<a href="https://developer.android.com/training/dependency-injection">Dependency Injection</a>教程和<a href="https://codelabs.developers.google.com/codelabs/android-dagger/">Codelab</a> <del>谁能想到dagger-android要凉凉了呢？</del></strong></p>
<p><strong>2018年5月20日更新了测试的更多思路</strong></p>
<p><strong>2018年5月19日更新了Dagger2测试的思路</strong></p>
<p>现在是<strong>2018年5月</strong>，Dagger2的版本是<strong>2.16</strong>，Kotlin版本是<strong>1.2</strong>，IDE是<strong>Android Studio</strong>。</p>
<p>过时的话就要话就要慎重地看。</p>
<p>Dagger2学起来是真心难受，现有的很多资料都已过世，误人子弟，而且和Kotlin结合在一起，会有很多很多坑和弯路。</p>
<blockquote>
<p>Copy-pasting code makes it hard to refactor later on. As more and more developers copy-paste that block, fewer will know what it actually does.</p>
</blockquote>
<p>本路线图指明的是：</p>
<p>从：对Dagger2只懂一点，不熟悉，只会到处复制粘贴。</p>
<p>到：熟悉Dagger2的使用方法，明白什么时候用interface，什么时候用abstract class，什么时候用@JvmStatic等等，能够看懂生成的代码，能分辨出Dagger2实现的好坏。</p>
<span id="more"></span>

<ul>
<li>因为Dagger2 + Kotlin有不少坑，建议先用Java操练，再用Kotlin。</li>
</ul>
<ol>
<li><p><a href="https://google.github.io/dagger/users-guide">官方文档 User’s Guide</a></p>
<p> Dagger2面向的是Java项目，所以先不涉及Android代码也可以运行。</p>
<p> 官方文档现在比较友好了，结合<a href="https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee">其中的代码</a>，并阅读生成的代码，理解Dagger2的原理。试一试什么@Singleton啊，@Named呀。</p>
<ul>
<li>使用Build =&gt; Make Project生成代码。</li>
<li>这一步研究生成的代码可以说很重要了。Dagger2的实现并不复杂，但信心++。</li>
</ul>
</li>
<li><p><a href="https://google.github.io/dagger/multibindings">官方文档 Multibindings</a></p>
<p> 官方文档的顺序有问题，所以先跳过Android的部分。</p>
<p> Multibindings内容比较简单，主要为以后做准备。</p>
</li>
<li><p><a href="https://google.github.io/dagger/subcomponents">官方文档 Subcomponents</a></p>
<p> 重头戏来了，Subcomponenets将会是使用dagger-android的核心，必须要理解的内容。</p>
<ul>
<li>至于后面的Producers，Testing，需要时再看也可以。</li>
</ul>
</li>
<li><p><a href="https://google.github.io/dagger/android">官方文档 Android</a></p>
<p> 这其中最莫名其妙的内容应该是<code>@ContributesAndroidInjector</code>的引入。简单来说它仅仅是简化了Subcomponent的建立过程。看不懂时先忽略，明白了Subcomponent的使用再回来看它。</p>
<p> 想要具体理解dagger-android的使用，还需要搭配</p>
<ol>
<li><p><a href="https://proandroiddev.com/how-to-android-dagger-2-10-2-11-butterknife-mvp-part-1-eb0f6b970fd">[HOW-TO] Android Dagger (2.11–2.14) Butterknife (8.7-8.8) MVP (Part 1)</a></p>
<p> 非常详细的指南。可以算是Best Practices了。</p>
<ul>
<li>这个月刚更新的，还热乎，乘早了。</li>
<li>虽然支持到Dagger2.14，但Dagger2.15、2.16也只是修理修理Bug</li>
<li>它支持support和无support的版本，还包括对应的kotlin版本。</li>
</ul>
</li>
</ol>
</li>
<li><p>Dagger + Kotlin</p>
<p> 多坑地带。宝贝有</p>
<p> <a href="https://github.com/google/dagger/issues/900">Kotlin+Dagger best practices/documentation</a></p>
<p> <a href="https://github.com/google/dagger/issues/848">@Named(…) qualifier not working with Firebase or Kotlin</a></p>
<p> 比较有用的有：静态@Provides的两种方法、@field:Named的使用等等。</p>
</li>
<li><p>其他</p>
<p> <a href="https://medium.com/mindorks/dagger-2-generated-code-9def1bebc44b">Dagger 2 Generated Code.</a>粗略地介绍了Dagger2生成的代码。如果在第一步研究够了的话，这里不是什么问题。</p>
</li>
</ol>
<p>至此，如果项目中出现了以下情况，都可以认为其不是Best Practices：</p>
<ul>
<li>Android项目中没有使用dagger-android(AndroidInjector等)</li>
<li>在Activity中引用Application来获得DaggerAppComponent再注入，而不是使用AndroidInjection</li>
<li>没有使用Scope而是手动管理。</li>
<li>到处都是@Singleton而没有用@Reusable或其他</li>
<li>其他的还没想到或见到</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>虽说<a href="https://google.github.io/dagger/testing">官方文档</a>中说Dagger2呀，测试很方便，但资料却很少。在逛遍SO和Github后，找到一些不成熟的还算能用的方案。这方面并没有一个Best Practice，哪个符合使用情况用哪个。八仙过海，各显神通了。</p>
<ul>
<li><p>使用测试用的TestAppComponent</p>
<p>  Instrumentation Test时，重写AndroidJunitRunner，在其newApplication中返回一个TestApplication，在TestApplication中注入一个测试用的TestAppComponent。</p>
<ul>
<li>官方文档中TestAppComponent继承了AppComponent，但在使用dagger-android时，会有一些问题，因此不继承了。TestAppComponent和AppComponent差不多，修改为测试用Module并暴露一些需要的类。</li>
</ul>
</li>
<li><p>新建一个使用TestAppComponent的Flavor</p>
<p>  参照<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-dagger">Blueprints中的Dagger</a>。虽然工程量比较大，但测试起来还算方便。</p>
</li>
<li><p>不使用Dagger2，直接mock</p>
<p>  参照<a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample">GithubBrowserSample</a>，同样重写AndroidJunitRunner和newApplication，但在TestApplication中不注入任何依赖。测试时，直接手动mock。</p>
<ul>
<li>还有各种第三方库，比如<a href="https://github.com/fabioCollini/DaggerMock">DaggerMock</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Docker快速搭建Wordpress + HTTPS</title>
    <url>/2018/03/20/docker-wordpress/</url>
    <content><![CDATA[<p>虽然最终选择了GithubPages + Hexo，但之前使用Docker搭的Wordpress + HTTPS。搭完后才发现维护起来又累又贵，就把整个流程贴出来留给有缘人吧。</p>
<p>甩锅申明：出了问题我不知道怎么解决，请问万能的Stackoverflow吧😉</p>
<p>好处：</p>
<ol>
<li>方便，命令几乎都是cd, ls和nano/vim。</li>
<li>快速，不需要LAMP或者LNMP漫长的安装/编译过程。新机器建站和删库跑路都很快。</li>
<li>干净，不污染其他文件夹，删除网站只需要一条Docker命令。</li>
<li>https，Let’s Encrypt! 不仅是网站，还要加个绿色的小锁。</li>
</ol>
<span id="more"></span>

<p>坏处：</p>
<ol>
<li>出了问题不好解决，包括通过命令行修改网站、给网站装个监控什么的等等，都涉及有一定门槛儿的Docker命令。但对于正常地通过Wordpress面板的操作足够了。</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先把域名解析上，最后上小锁时需要。</p>
<p>新系统来了先</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure>

<p>老系统没有<code>apt</code>，用<code>apt-get</code></p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Docker是将程序和其依赖放在容器中，再进行部署的开源软件……总之很方便就对了。</p>
<p>在其官网，不同系统有不同的安装教程。</p>
<p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a><br><a href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a><br><a href="https://docs.docker.com/install/linux/docker-ce/centos/">Fedora</a><br><a href="https://docs.docker.com/install/linux/docker-ce/fedora/">Ubuntu</a></p>
<p>中文文档在</p>
<p><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/">Ubuntu</a><br><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/debian/">Debian</a><br><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/">Fedora</a><br><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/fedora/">Ubuntu</a></p>
<p>举例：我的Debian8（注意对内核有要求）是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install \</span><br><span class="line">     apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     gnupg2 \</span><br><span class="line">     software-properties-common</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ID</span>&quot;</span>)/gpg | apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选，查看签名是否添加成功，在输出的内容中应该有下面那行内容。</span></span><br><span class="line">apt-key fingerprint 0EBFCD88</span><br><span class="line"><span class="comment"># 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</span></span><br><span class="line"></span><br><span class="line">add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/<span class="subst">$(. /etc/os-release; echo <span class="string">&quot;<span class="variable">$ID</span>&quot;</span>)</span> \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br><span class="line"></span><br><span class="line">apt update</span><br><span class="line">apt install docker-ce</span><br></pre></td></tr></table></figure>

<h2 id="安装Docker-compose"><a href="#安装Docker-compose" class="headerlink" title="安装Docker-compose"></a>安装Docker-compose</h2><p>一次运行多个容器的工具。</p>
<p>官网有<a href="https://docs.docker.com/compose/install/">安装指南</a>，中文的似乎没翻译。</p>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.19.0/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h2 id="安装代理"><a href="#安装代理" class="headerlink" title="安装代理"></a>安装代理</h2><p>安装之前，先新建一些文件夹，来存放我们网站的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/你的目录</span></span><br><span class="line"><span class="comment">#    /nginx-files</span></span><br><span class="line"><span class="comment">#    /database</span></span><br><span class="line"><span class="comment">#    /wordpress</span></span><br><span class="line"><span class="comment">#        /core/files</span></span><br><span class="line"><span class="comment">#        /wp-content</span></span><br><span class="line"><span class="comment"># 命令是：</span></span><br><span class="line"><span class="built_in">mkdir</span> nginx-files</span><br><span class="line"><span class="built_in">mkdir</span> database</span><br><span class="line"><span class="built_in">mkdir</span> wordpress</span><br><span class="line"><span class="built_in">cd</span> wordpress</span><br><span class="line"><span class="built_in">mkdir</span> core</span><br><span class="line"><span class="built_in">mkdir</span> wp-content</span><br><span class="line"><span class="built_in">cd</span> core</span><br><span class="line"><span class="built_in">mkdir</span> files</span><br><span class="line"><span class="built_in">cd</span> 回你的最上层目录</span><br></pre></td></tr></table></figure>

<p>安装代理需要这么一个Github Repo: <a href="https://github.com/evertramos/docker-compose-letsencrypt-nginx-proxy-companion">Web Proxy using Docker, NGINX and Let’s Encrypt</a></p>
<p>它的README有安装教程，但有几个坑。</p>
<ol>
<li>下载Repo：<code>git clone https://github.com/evertramos/docker-compose-letsencrypt-nginx-proxy-companion.git</code></li>
<li>【可选】如果不使用反向代理的话，可以删掉Repo中<code>/conf.d/realip.conf</code></li>
<li>【可选】可以修改<code>/conf.d/uploadsize.conf</code>中的<code>client_max_body_size</code>的值，默认是100MB，限制上传文件的最大大小，不够就加大。</li>
<li>改名，<code>mv .env.sample .env</code></li>
<li>修改变量，<code>nano .env</code>，或者用<code>vim</code>。</li>
<li>需要修改的变量有<ul>
<li><code>IP</code>：修改为机器的IP </li>
<li><code>NGINX_FILES_PATH</code>：修改为刚刚新建的<code>nginx-files</code>文件夹的路径</li>
<li><code>USE_NGINX_CONF_FILES</code>：【可选】去掉变量前的井号。这里是要使用conf.d文件夹下的设置，包括之前第三步上传文件的最大大小。如果不在乎这几个设置也可以不管它（后果就是搭好后上传主题时，2MB就GG）</li>
</ul>
</li>
<li>运行<code>./start.sh</code></li>
</ol>
<h2 id="安装Wordpress"><a href="#安装Wordpress" class="headerlink" title="安装Wordpress"></a>安装Wordpress</h2><p>又需要一个Github Repo：<a href="https://github.com/evertramos/docker-wordpress-letsencrypt">Using Wordpress with SSL enabled integrated with NGINX proxy and autorenew LetsEncrypt certificates</a></p>
<p>同样有几个坑。</p>
<ol>
<li><p>下载：<code>git clone https://github.com/evertramos/wordpress-docker-letsencrypt.git</code></p>
</li>
<li><p>【可选】新建一个<code>uploads.ini</code>的文件，内容是</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_uploads = On</span><br><span class="line">memory_limit = 64M</span><br><span class="line">upload_max_filesize = 64M</span><br><span class="line">post_max_size = 64M</span><br><span class="line">max_execution_time = 600</span><br></pre></td></tr></table></figure>
<p> 这里跟上一步中修改上传文件的最大大小是一致的，要么一起用，要么就不用，下几步的可选也是一样的，不用的话都可以跳过。这里的最大上传文件设置为64MB，不够随便改。</p>
</li>
<li><p>【可选】修改<code>docker-compose.yml</code>，在<code>services - wordpress - volumes</code>下加一行<code>- $&#123;PHP_UPLOAD_CONF&#125;:/usr/local/etc/php/conf.d/uploads.ini</code></p>
</li>
<li><p>改名，<code>mv .env.sample .env</code></p>
</li>
<li><p>修改<code>.env</code></p>
<ul>
<li><code>DB_PATH</code>: 修改为刚刚新建的<code>database</code>文件夹的路径</li>
<li><code>MYSQL_ROOT_PASSWORD</code>: 挑一个数据库根密码</li>
<li><code>MYSQL_DATABASE</code>: 数据库的名字，随便取，习惯上用<code>wordpress</code></li>
<li><code>MYSQL_USER</code>: 数据库用户，随便取，习惯上用<code>wordpress</code></li>
<li><code>MYSQL_PASSWORD</code>: 挑一个数据库密码</li>
<li><code>WP_CORE</code>: 修改为刚刚新建的<code>core</code>文件夹的路径</li>
<li><code>WP_CONTENT</code>: 修改为刚刚新建的<code>wp-content</code>文件夹的路径</li>
<li><code>DOMAINS</code>: 修改为开头就应该解析上的域名</li>
<li><code>LETSENCRYPT_EMAIL</code>: 修改为你的邮箱，用于Let’s Encrypt</li>
<li>【可选】如果执行了2、3步的话，最后加一行<code>PHP_UPLOAD_CONF=/刚刚新建的文件路径/uploads.ini</code></li>
</ul>
</li>
<li><p>运行<code>docker-compose up -d</code></p>
</li>
</ol>
<p>等个几十秒一分钟，网站就可以使用了，带个https绿色小锁。</p>
<h2 id="命令与支援"><a href="#命令与支援" class="headerlink" title="命令与支援"></a>命令与支援</h2><ul>
<li>不带<code>-d</code>直接运行<code>docker-compose up</code>可以查看日志，用于排错。</li>
<li>在第二个Repo的文件夹中，运行<code>docker-compose down</code>可以停止Wordpress。</li>
<li><code>docker container ls [--all]</code>: 显示所有Container，最后不带<code>--all</code>的仅显示运行中的，带的话还显示已停止的。最后应该一共有5个Container。</li>
<li><code>docker rm [--force] linux_tweet_app</code>: 删除一个Container，带<code>--force</code>强制删除，无视是否运行。</li>
</ul>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
  </entry>
  <entry>
    <title>aprildown.xyz将会在未来到期</title>
    <url>/2023/08/12/domain-expiration/</url>
    <content><![CDATA[<p>惊闻XYZ域名即将涨价，索性决定再续费一两年后放弃该域名。之后继续乖乖地使用无需多虑的Github域名。</p>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
  </entry>
  <entry>
    <title>Github Stars整理</title>
    <url>/2019/11/24/github-stars/</url>
    <content><![CDATA[<p>由于要收藏各种Repo，但有的Repo因为年久失修或其他原因，食之无味弃之可惜，只好丢在这里了。</p>
<p><a href="https://github.com/DeweyReed?tab=stars">Github的Stars页</a></p>
<span id="more"></span>

<p><a href="https://github.com/ncase/wbwwb">wbwwb(We Become What We Behold – a minigame about the news!)</a></p>
<p><a href="https://github.com/javiersantos/MaterialStyledDialogs">MaterialStyledDialogs(A library that shows a beautiful and customizable Material-based dialog with header. API 11+ required.)</a></p>
<p><a href="https://github.com/FoxxMD/intellij-jvm-options-explained">intellij-jvm-options-explained(Common JVM options used with Intellij and what they do)</a></p>
<p><a href="https://github.com/rock3r/uplift">uplift(A playground for elevation on Android)</a></p>
<p><a href="https://github.com/lopspower/GradientView">GradientView(Create gradient view in Android in the simplest way possible 🌈)</a></p>
<p><a href="https://github.com/PandoraMedia/BottomNavigator">BottomNavigator(Android Bottom Navigation multiple stack manager)</a></p>
<p><a href="https://github.com/skydoves/Balloon">Balloon(🎈 A lightweight popup like tooltips, fully customizable with arrow and animations.)</a></p>
<p><a href="https://github.com/skydoves/Only">Only(💐 An easy way to persist and run code block only as many times as necessary on Android.)</a></p>
<p><a href="https://github.com/roughike/SwipeSelector">SwipeSelector(A nicer-looking, more intuitive and highly customizable alternative for radio buttons and dropdowns for Android.)</a></p>
<p><a href="https://github.com/skydoves/Submarine">Submarine(🚤 Floating navigation view for listing items dynamically on Android.)</a></p>
<p><a href="https://github.com/zhanghai/SystemUiHelper">SystemUiHelper(Helper for dealing with Android System UI visibility)</a></p>
<p><a href="https://github.com/bernaferrari/ChangeDetection">ChangeDetection(Automatically track websites changes on Android in background.)</a></p>
<p><a href="https://github.com/Dimowner/AudioRecorder">AudioRecorder(Audio Recording Android application)</a></p>
<p><a href="https://github.com/SimonMarquis/InternalAppStore">InternalAppStore(Manage your own internal Android App Store.)</a></p>
<p><a href="https://github.com/ashishb/adb-enhanced">adb-enhanced(🔪Swiss-army knife for Android testing and development 🔪 ⛺)</a></p>
<p><a href="https://github.com/jaredrummler/Cyanea">Cyanea(A theme engine for Android)</a></p>
<p><a href="https://github.com/novoda/bintray-release">bintray-release(A helper for releasing from gradle up to bintray)</a></p>
<p><a href="https://github.com/Karn/notify">notify(Simplified notification construction and delivery for Android.)</a></p>
<p><a href="https://github.com/afollestad/aesthetic">aesthetic(🔮 A fast, easy to use, dynamic theme engine. Powered by Rx and Kotlin, for Android apps.)</a></p>
<p><a href="https://github.com/rubensousa/BottomSheetBuilder">BottomSheetBuilder(A simple library that creates BottomSheets according to the Material Design specs)</a></p>
<p><a href="https://github.com/Tinder/StateMachine">StateMachine(A Kotlin DSL for finite state machine)</a></p>
<p><a href="https://github.com/aritraroy/Flashbar">Flashbar(⚡️A highly customizable, powerful and easy-to-use alerting library for Android.)</a></p>
<p><a href="https://github.com/vanniktech/gradle-dependency-graph-generator-plugin">gradle-dependency-graph-generator-plugin(Gradle plugin that generates dependency graphs from your project.)</a></p>
<p><a href="https://github.com/willowtreeapps/Hyperion-Android">Hyperion-Android(App Debugging &amp; Inspection Tool for Android)</a></p>
<p><a href="https://github.com/JetradarMobile/desertplaceholder">desertplaceholder(Animated placeholder in desert style.)</a></p>
<p><a href="https://github.com/KeepSafe/dexcount-gradle-plugin">dexcount-gradle-plugin(A Gradle plugin to report the number of method references in your APK on every build.)</a></p>
<p><a href="https://github.com/openstf/stf">stf(Control and manage Android devices from your browser.)</a></p>
<p><a href="https://github.com/daattali/beautiful-jekyll">beautiful-jekyll(✨ Build a beautiful and simple website in literally minutes.)</a></p>
<p><a href="https://github.com/MEiDIK/Cipher.so">Cipher.so(A simple way to encrypt your secure data like passwords into a native .so library.)</a></p>
<p><a href="https://github.com/Ereza/CustomActivityOnCrash">CustomActivityOnCrash(Android library that allows launching a custom activity when your app crashes, instead of showing the hated “Unfortunately, X has stopped” dialog.)</a></p>
<p><a href="https://github.com/Triple-T/gradle-play-publisher">gradle-play-publisher(GPP is Android’s unofficial release automation Gradle Plugin. It can do anything from building, uploading, and then promoting your App Bundle or APK to publishing app listings and other metadata.)</a></p>
<p><a href="https://github.com/akexorcist/Android-LocalizationActivity">Android-LocalizationActivity(Let’s make language swithching in your app with easy way)</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>Google I/O 2018 笔记</title>
    <url>/2018/05/12/google-io-2018-notes/</url>
    <content><![CDATA[<p>把今年I/O的内容参加的差不多了，这里记录一些对我有用的东西。</p>
<span id="more"></span>

<h2 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h2><p>感觉像是给Development换了个更酷的名字。四块中Architecture中才是最重要的各种Libraries。</p>
<p>最有亮点的应该是Navigator。在将Activity和Fragment的逻辑分离出来后，单Activity加多Fragment成为了官方推荐的做法，这样让动画也更方便了。</p>
<p>WorkManager算是造了一个大轮子，使用起来似乎比现有的更方便。把后台运算、服务、Job Scheduler、GCM、FCM等都可以替代了。</p>
<p>Paging，ListAdapter和Recycler Selection覆盖了更多的列表显示。</p>
<h2 id="ContraintLayout"><a href="#ContraintLayout" class="headerlink" title="ContraintLayout"></a>ContraintLayout</h2><p>RelativeLayout都不推荐，要被取代了。而且还引入了关键帧动画，可以说野心很大了。</p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>当初看Android Permormance Pattern的内容还历历在目，现在就说枚举可以用了，内存使用也放开一些手脚，也有了推荐的框架。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>Material Theming和Component给开发和设计带来了更好的指导。</li>
<li>长文字的显示可以用RecyclerView或者premeasure来处理</li>
<li>使用夜间主题来省电</li>
<li>Slice是不是要取代Widget呀，还要观望一下。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle缓存笔记</title>
    <url>/2022/03/06/gradle-cache/</url>
    <content><![CDATA[<p>来自于：</p>
<ul>
<li><a href="https://jasonatwood.io/archives/1966">Understanding Different Gradle Caches for Android Projects, part 1.</a></li>
<li><a href="https://jasonatwood.io/archives/1995">Understanding Different Gradle Caches for Android Projects, part 2</a></li>
<li><a href="https://jasonatwood.io/archives/2127">Understanding Different Gradle Caches for Android Projects, part 3</a></li>
</ul>
<span id="more"></span>

<p>[Build]-[Clean Project]和<code>gradlew clean</code>都是仅删除根目录和Module目录下的<code>build</code>文件夹。<code>build</code>文件夹是Gradle自带的、默认的缓存策略。</p>
<p>Build Cache（现在默认关闭，通过<code>--build-cache</code>或<code>org.gradle.caching=true</code>打开），使用了默认单项目缓存一样的机制，会把部分缓存保存到<code>~/.gradle/caches/build-cache-*</code>，机器上所有项目可共享。这也就是为什么Dagger偶尔失效时，需要删除系统Gradle缓存的原因。</p>
<ul>
<li>文中提到<code>R.java</code>，但记得在某个AGP版本中，文件已经变成<code>jar</code>，轻易找不到了。</li>
<li><code>kapt</code>的<code>useBuildCache</code><a href="https://docs.gradle.org/current/userguide/caching_android_projects.html#annotation_processors_and_kotlin">在某个版本中默认开启了</a>。<a href="https://kotlinlang.org/docs/kapt.html#gradle-build-cache-support">关闭文档</a>。</li>
</ul>
<p>Gradle Deamon默认开启。</p>
<p>依赖储存在<code>~/.gradle/caches/*</code>中。其中<code>transform-*</code>保存了本地修改后的依赖，非下载内容。</p>
<p>Invalidate Caches / Restart只清理IDE缓存，不清理上述缓存。</p>
<p><code>android.enableBuildCache</code>在AGP 7中被弃用。</p>
<p><code>org.gradle.unsafe.configuration-cache=true</code>实验中的Configuration Cache，期待正式版。缓存储存在<code>[PROJECT_ROOT]/.gradle/configuration-cache</code>中。</p>
<p>还有一些<a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties">各种属性的默认值</a>。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>灰度显示</title>
    <url>/2018/11/04/greyscale/</url>
    <content><![CDATA[<p>搜集的一些如何在电子设备上打开灰度显示的设置。</p>
<span id="more"></span>

<ul>
<li><p>Windows10</p>
<ul>
<li>设置搜索“颜色滤镜”，勾选“允许使用快捷键打开或关闭滤镜”，把滤镜设置为“灰度”。使用Windows + Ctrl + C切换灰度。</li>
<li><a href="https://justgetflux.com/">flux</a>，最新版(4.84)有灰度设置。</li>
</ul>
</li>
<li><p>Android 5.0及以后</p>
<ul>
<li>开发者设置，从最后开始找“模拟颜色空间”，设置为“全色盲”。</li>
<li>应用<a href="https://github.com/fei-ke/Greyscale">灰度</a>，或在酷安搜索。</li>
</ul>
</li>
</ul>
<p>其他的，有缘再添加吧。</p>
]]></content>
      <categories>
        <category>What</category>
      </categories>
  </entry>
  <entry>
    <title>论如何避免垃圾游戏</title>
    <url>/2023/07/06/how-to-avoid-trash-games/</url>
    <content><![CDATA[<p>终于打完了Fire Emblem Engage。过程极度痛苦，在此深刻检讨并反省。<strong>有剧透</strong>。</p>
<span id="more"></span>

<p>先假定这是一部想要用游戏换钞票的作品。文末讨论另外一种情况。</p>
<h2 id="这一作算得上垃圾游戏吗？"><a href="#这一作算得上垃圾游戏吗？" class="headerlink" title="这一作算得上垃圾游戏吗？"></a>这一作算得上垃圾游戏吗？</h2><p>看到一些中文社区对该游戏总体上持有正面评价，因此先论证标题的合理度。</p>
<p>正如评价一道菜时，不会因为其中有喜欢的材料和佐料，就忽略掉其他不好的味道。考虑到游戏优秀的画面和出色的难度，还有其他方面的灾难，只能说瑜不掩<strong>瑕</strong>。</p>
<img src="/2023/07/06/how-to-avoid-trash-games/engage.jpg" class="" title="[engage.jpg](.&#x2F;how-to-avoid-trash-games&#x2F;engage.jpg)">

<p>游戏<a href="https://www.metacritic.com/game/switch/fire-emblem-engage">此时在Metacritic用户评分6.6</a>，可见一些愤怒玩家的极端情绪。</p>
<p>在IS自家手游Fire Emblem Heroes中，游戏发布的一月，同步发布了一个卡池。而六个月后，终于有一位新角色（不是一个Engage卡池喔）出现了！可惜不出意外地是游戏中最媚宅的那位。</p>
<p>相比之下，三房发布后，手游中三房的池子接二连三，多到了有些令人厌烦的程度。</p>
<p>在手游中，为了赚钱，人气高的角色的换皮都快用脚趾头来数了。而Engage迄今为止只有个位数的角色。</p>
<p>游戏本体的质量已经不会再变了。过了游戏发售的宣发期，Engage在手游中的人气很凄惨。</p>
<h2 id="错误的开始"><a href="#错误的开始" class="headerlink" title="错误的开始"></a>错误的开始</h2><p>三房由光荣开发，而Engage是IS自己操刀。因此和Engage相比的是应该是上一作回声，而不是三房。也可以看到游戏继承了回声和IF的很多设定，比如不停刷新且越来越难的大地图遭遇战、虽然有提升但依旧难受的3D转弯手感、一个皇族配两个家臣的偷懒设定、用一个离谱标签来定义某个角色的方法等。相比回声，进步不少；相比三房，一言难尽。</p>
<p>而对于硬核的战旗玩家则是另一种情况，在文末讨论。</p>
<p>现在想起来，在观看游戏发售前的预告片时，我曾有过不详的预感。</p>
<p>二次元 + 低幼向的画风配合亮丽的低多边形的场景，让我不经想起了另外一款风靡全球的手游。这也让我不仅怀疑自己是不是已经和主流游戏玩家群体的审美脱钩了。</p>
<p>看着那么多小学生和初中生模样的队友谈论着拯救世界和伸张正义，可信度很低。虽然三房中五年后成长为年轻人的学生们年纪也不大，也比Engage中这帮未成年要可信吧。</p>
<p>似乎自从苍晓之后，火纹主角团的年纪越来越小了。</p>
<h2 id="游戏的体验"><a href="#游戏的体验" class="headerlink" title="游戏的体验"></a>游戏的体验</h2><h3 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h3><p>这是我心目中火纹系列中最差的剧情。相比之下，IF等作品的剧情只是平淡、无聊、让人犯困，但这一作可以让催生负面情绪，让人只想快进。</p>
<p>游戏剧情中有着常见的带动情绪的情节，但其呈现方式非常糟糕。对细节的忽略和演出的敷衍，让一个最差只是平淡的故事，变成了让人苦笑的尴尬桥段。</p>
<p>反派会制造“异形兵”，这和觉醒和回声中“尸兵”类似，虽然解决了敌人哪里来的问题（凭空捏造出来的），但这样的偷懒到头来却催生了更加偷懒的反派刻画。</p>
<p>整个故事中，完全没有皇城士兵奋勇作战保家卫国的刻画，有的只是几个反派长驱直入，直取各个国家光杆儿司令的桥段儿。而绝大多数反派都会反水，构成了主角团的不小的一部分。真是最大程度地不浪费建模和立绘。</p>
<p>另外，在IS上一部作品，纸片马力欧折纸国王中，几乎完美的箱庭解谜游戏却有一个离谱的成就和莫名其妙的结局，让人唏嘘不已。剧情的确不是IS的长项。万年不变的王子复仇记哟。</p>
<h3 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h3><p>琉尔是第一位在剧情中完全不提变身为龙的龙族。是剧情被砍了吗？</p>
<p>纹章士的设定虽然让系列老玩家很兴奋，但也决定了老角色无法有新剧情。没有了成长的各位老角色，最后只沦为了辅助战斗和填充对话的工具人。从故事和剧情上来说，纹章士系统也决定了剧情无法有太多波折。</p>
<h3 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h3><p>画面和立绘非常精致。但正如世间万物，精致不会长久。</p>
<p>游戏播片几乎都是站桩对话，且都集中游戏后半段，没有什么大场面。IF还有几段激动人心的播片（龙马的雷神刀记忆犹新），但对于这一作的播片，只恨不能二倍速。</p>
<p>在主角第一次在预告片中亮相时，我的第一反应是“大饼脸”。也许是新纹谜留下了心里阴影，对类似于大饼脸的造型都很排斥。巧了，马大饼在这一部中也是主角。</p>
<p>客气地说，Engage的角色建模保持了统一的风格；老实地说，在建模上很偷懒。看起来像是，同样的脸型，移动移动五官，换点配饰就得到了新角色。这也解释了为何都是大饼脸。</p>
<h3 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h3><p>由于建模精度的提升，且游戏会在UI中加载选中角色的3D模型，导致在打开角色界面时，总会等几百毫秒才能看到角色全貌。同时，所有的UI都无法在操作动画结束前进行下一步。这些特点让整个UI非常难用、卡顿。在不断地买卖武器、切换装备和更改配置时，像是玩几百延迟的FPS。</p>
<p>由于喜欢秒杀反派，所以游戏都开最低难度，于是我也不知道这作战旗有多精妙咯。</p>
<h2 id="全成就踩坑"><a href="#全成就踩坑" class="headerlink" title="全成就踩坑"></a>全成就踩坑</h2><p>游戏中的家园仿佛是一帮大学生头脑风暴后，将草稿案甩给了开发团队后得到的系统。数量多、不完善、无深度且意义不明。全成就列表中的条目更像是用Excel直接拖拽得到的数值设计。</p>
<ul>
<li>收留动物和捡食材只用于料理</li>
<li>料理结果取决于厨师，不要数值的话可以空气拌饭</li>
<li>不要数值而选择空气拌饭的话，就没必要收留动物和捡食材</li>
<li>研磨戒指只服务于成就</li>
<li>戒指抽卡主要服务于成就。似乎在高难度的特定几章有点用。要刷一万年才能把戒指都抽齐。</li>
<li>小游戏（飞龙、肌肉锻炼、钓鱼）全皇冠只有好看这么一个奖励</li>
<li>俯卧撑要根据速度在黄色区域上方按键</li>
<li>最高难度的仰卧起坐需要三千分，不需要使劲浪费手柄</li>
<li>其他小游戏多练习几次就能拿皇冠了</li>
<li>主角和其他角色提升好感的最快方法是疯狂送最便宜的礼物。礼物商店后期解锁。高价格礼物的用处只是为了显得商店不会太空</li>
<li>小王八需要持续喂养，不然好感会降</li>
<li>钓鱼池有九个区，特定时间特定区出特定鱼</li>
<li>最花时间的成就是全支援和联网战斗相关的成就</li>
<li>联网战斗只是用玩家的数据，操作是电脑控制的</li>
<li>想要全角色全纹章士满羁绊要刷一万年。奖励是每队组合的不痛不痒的八句台词</li>
</ul>
<h2 id="如果？"><a href="#如果？" class="headerlink" title="如果？"></a>如果？</h2><p>如果Engage是一部只服务于高难度战旗小众玩家的作品，那么一切都可以解释地通！</p>
<ul>
<li>为什么除了战斗都很糟糕？因为目标玩家只战斗。画面和其他系统都算加分项。</li>
<li>为什么要引入纹章士这种对新玩家不友好的设定？因为目标玩家必玩火纹。</li>
<li>为什么手游不出新池子？因为手游面向大众玩家。</li>
<li>为什么买之前没人告诉我这些？因为IS要赚钱。老任可不会因为游戏不好玩而退款。</li>
<li>为什么IS不怕销量差？估计是因为手游赚太多了。</li>
</ul>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>虽然有着等游戏发售后几个月再买游戏的习惯，但由于火纹系列都有在玩，Engage在发布之初就抓紧了我的钱包。另外，由于四月五日是游戏和手游联动奖励的截止日期，让我买之前也没花太多时间认真思考。然而，联动奖励之后在DLC中永久可领取。</p>
<p>最简单的方案是在游戏发售后几个月后买游戏时，再次调查评分和评测来决定是否购买。</p>
<p>而更重要的是，要记牢未来的不确定，而自己能做的是只是欣赏当下已有的优秀作品。</p>
]]></content>
      <categories>
        <category>Gaming</category>
      </categories>
  </entry>
  <entry>
    <title>在Android Studio中引入AAR文件</title>
    <url>/2018/08/13/include-aar/</url>
    <content><![CDATA[<h2 id="2019年2月10日-更新"><a href="#2019年2月10日-更新" class="headerlink" title="2019年2月10日 更新"></a>2019年2月10日 更新</h2><p>发现一个更好的方案：不管是自己的项目还是Fork来的项目，直接到Jitpack里找到对应的commit，拉下来直接用。这样就省去了很多体力劳动。而且这个过程并不需要配置Gradle，源码都自带。【完】</p>
<p>任务很简单，最小程度影响当前项目的前提下，导入一个AAR第三方库。</p>
<p>要解决的问题在于</p>
<ol>
<li>按导入<code>.jar</code>的方法导入<code>.aar</code>会失败</li>
<li>使用Android Studio自带的<code>Improt Module</code>中的导入AAR会创建一个新的Module，而我们只想声明一个依赖</li>
</ol>
<span id="more"></span>

<h2 id="这么做的优点"><a href="#这么做的优点" class="headerlink" title="这么做的优点"></a>这么做的优点</h2><ol>
<li>Module该有好处自然有的了</li>
<li>不需要复杂漫长地发布到JCenter等地方，才能使用依赖</li>
<li>修改后直接复制粘贴AAR就可使用</li>
</ol>
<h2 id="缺点也是明显的"><a href="#缺点也是明显的" class="headerlink" title="缺点也是明显的"></a>缺点也是明显的</h2><ol>
<li>不要求发布，就不适用多人协作的大项目，电脑GG后源代码也会丢失</li>
<li>不带注释，需要手动选择代码目录，有时候选择还会失效</li>
<li>修改后复制粘贴AAR才能使用</li>
<li>AAR的版本被保存在了另一个项目中</li>
<li>AAR的依赖需要手动添加到项目的依赖中</li>
<li>AAR定义的Annotation，比如IntDef，需要手动在Proguard <code>-dontwarn</code></li>
<li>似乎并不能跨module使用</li>
</ol>
<p><del>缺点比优点多可还行</del></p>
<p>个人习惯：</p>
<ul>
<li>把名字改为library名+git commit编号</li>
<li>另建一个文件夹专门放各种AAR</li>
<li>把修改的项目丢到Github或GitBucket</li>
<li>在版本控制中删掉所有AAR</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="1-一个有正常的Library-Module的Android项目"><a href="#1-一个有正常的Library-Module的Android项目" class="headerlink" title="1. 一个有正常的Library Module的Android项目"></a>1. 一个有正常的Library Module的Android项目</h3><p>新建一个项目，带上需要的Library，或最简单的就是直接clone一个现有的依赖。</p>
<h3 id="2-生成AAR文件"><a href="#2-生成AAR文件" class="headerlink" title="2. 生成AAR文件"></a>2. 生成AAR文件</h3><p>使用<code>./gradlew assemble</code>或者Android Studio中, 点击Gradle面板/你的library/Tasks/build/assemble</p>
<p>我在使用中，单纯地运行应用并不一定能生成AAR。</p>
<h3 id="3-定位AAR文件"><a href="#3-定位AAR文件" class="headerlink" title="3. 定位AAR文件"></a>3. 定位AAR文件</h3><p>在项目/library/build/outputs/aar/中找到生成的AAR文件，给<code>library-release.aar</code>（谁能解释一下它和<code>library-debug.aar</code>除了名字不一样有什么区别？字节数都一样）改个名字，拉出来。</p>
<p>最好在文件名后加一个tag或版本号，确保以后更新时Sync Gradle可以成功更新代码库。</p>
<h3 id="4-把AAR复制到所需项目"><a href="#4-把AAR复制到所需项目" class="headerlink" title="4. 把AAR复制到所需项目"></a>4. 把AAR复制到所需项目</h3><p>复制到项目/app/src/main/libs/下，可能需要新建一个<code>libs</code>文件夹（文件名可以随便起）。</p>
<h3 id="5-在Gradle中添加目录"><a href="#5-在Gradle中添加目录" class="headerlink" title="5. 在Gradle中添加目录"></a>5. 在Gradle中添加目录</h3><p>首先修改项目根目录主<code>build.gradle</code>，在<code>allprojects/repositories</code>(不写classpath的那个区域里)下添加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">flatDir &#123;</span><br><span class="line">     dirs <span class="string">&#x27;src/main/libs&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意把<code>libs</code>替换为你那奇思妙想的新名字。</p>
<h3 id="在Dependencies中引用AAR"><a href="#在Dependencies中引用AAR" class="headerlink" title="在Dependencies中引用AAR"></a>在Dependencies中引用AAR</h3><p>添加<code>implementation(name:&#39;library-name&#39;, ext:&#39;aar&#39;)</code></p>
<p>注意<code>name</code>中不带后缀。</p>
<p>Ta-Da。完成！</p>
<p>参考:</p>
<p><a href="https://medium.com/@notestomyself/how-to-include-external-aar-file-using-gradle-6604b378e808">How to Include an External .aar File Using Gradle?</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin + JSON 默认参数适配问题</title>
    <url>/2018/05/18/kotlin-json/</url>
    <content><![CDATA[<p>2018年5月18日更新：Moshi 1.6增加了Codegen的选项，可以取代Kotshi。原方案依旧可行。</p>
<p>之前用Gson序列化Kotlin的data class一直都没问题，但一天当data class中出现了默认参数时，问题就来了。</p>
<p>如果JSON中没有对应的Field，按道理Gson应该生成一个使用了默认参数的data class，但它没有，而且会无视Kotlin的不可null，直接生成一个null。</p>
<p>那换一个支持Kotlin的JSON库呗。这时Moshi就很厉害了，自带一个Kotlin的Adapter，用起来很舒服。但是在最后生成Release版本时，才发现安装包大了600+KB。原因是Moshi对Kotlin的支持使用了Kotlin的Reflection，这个就很占空间，虽然也有Kotlin Relection Lite这个轻量级版本，但目前并不支持。</p>
<p>所以，我在</p>
<span id="more"></span>

<p>在Gson的Issue<a href="https://github.com/google/gson/issues/1148">讨论</a>中，还有Moshi的讨论中，找到了<a href="https://github.com/ansman/kotshi">Kotshi</a>，问题才最终解决。</p>
<p>Kotlin + Moshi（不带Kotlin插件）+ Kotshi就是最终解决方案。当然AutoValue之类的也可以，不过没深入研究。</p>
<p>Kotshi没有采用一劳永逸的方案，而是让每个Kotlin data class类都加一个annotation，再根据它生成一个adapter，<br>在序列化和反序列化时手动处理。</p>
<p>不算很方便的方案，但也算比<a href="https://medium.com/@MaxMello/most-elegant-way-of-using-gson-kotlin-with-default-values-and-null-safety-b6216ac5328c">通过Backing field处理</a>来的舒服。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>用于展示的Markdown徽章集合</title>
    <url>/2018/04/19/markdown-badges/</url>
    <content><![CDATA[<h1 id="大部分勋章使用markdown，SVG的格式。"><a href="#大部分勋章使用markdown，SVG的格式。" class="headerlink" title="大部分勋章使用markdown，SVG的格式。"></a>大部分勋章使用markdown，SVG的格式。</h1><span id="more"></span>

<ol>
<li><p><a href="http://shields.io/">Shields.io</a></p>
<p> 满足绝大部分需求，可以自定义内容和样式。没时间看剩下的内容的话，学会这么一个就够了。</p>
<p> 在搜索栏中输入“github”可以找到一些常用的勋章。</p>
</li>
<li><p><a href="https://badge.fury.io/">https://badge.fury.io/</a></p>
<p> 输入项目名（需要项目有版本号（Tag）），生成各种格式的版本勋章。</p>
</li>
<li><p><a href="https://github.com/ellerbrock/open-source-badges">open-source-badges</a></p>
<p> 提供带有爱心的开源勋章，还有Linceses勋章</p>
</li>
<li><p><a href="https://github.com/jitpack/jitpack.io#badges">Jitpack</a></p>
<p> 如果使用Jitpack发布，可以使用这个链接直接嵌入Jitpack为你设计好的版本勋章。</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![Release</span>](<span class="link">https://jitpack.io/v/User/Repo.svg</span>)](<span class="link">https://jitpack.io/#User/Repo</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://github.com/KotlinBy/awesome-kotlin#spread-awesome-kotlin">Awesome Kotlin Badge</a></p>
<p> 如果是awesome kotlin，就又有一个很酷的勋章</br></p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![Awesome Kotlin Badge</span>](<span class="link">https://kotlin.link/awesome-kotlin.svg</span>)](<span class="link">https://github.com/KotlinBy/awesome-kotlin</span>)</span><br></pre></td></tr></table></figure>

<p> <a href="https://github.com/KotlinBy/awesome-kotlin"><img src="https://kotlin.link/awesome-kotlin.svg" alt="Awesome Kotlin Badge"></a></p>
</li>
<li><p><a href="https://github.com/jirutka/maven-badges#usags">Maven central</a></p>
<p> 一个第三方的针对maven central的版本勋章</p>
</li>
<li><p>Android Arsenal</p>
<p> 在项目信息中间一栏的下方，有“Badge”选项，点击右边”Generate”就可以生成一个链接。</p>
</li>
<li><p>Emoji</p>
<p> 虽然算不上勋章，但可以起到勋章的作用。</p>
<p> 常见的就是使用:cn::us:表示支持的语言、国家。<br> 可以直接使用<a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/">Emoji Cheat Sheet</a>中的内容表示。</p>
</li>
<li><p><a href="https://github.com/larsenwork/web.svg.min">Web.svg.min</a></p>
<p> 一些常用图标的Vector格式。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5450520-b5058065eb46307d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="preview"></p>
</li>
<li><p><a href="https://gist.github.com/lukas-h/2a5d00690736b4c3a7ba">各种Licenses</a></p>
</li>
<li><p><a href="https://circleci.com/docs/1.0/status-badges/">Circleci</a></p>
</li>
<li><p><a href="https://docs.travis-ci.com/user/status-images/">Travis CI</a></p>
</li>
<li><p><a href="https://support.codacy.com/hc/en-us/articles/212799365-Badges">Codacy</a></p>
</li>
<li><p><a href="https://play.google.com/intl/en_us/badges/">Google Play链接</a></p>
</li>
<li><p><a href="https://ko-fi.com/">Bug me a coffee</a></p>
</li>
<li><p>其他勋章集合</p>
<p> <a href="https://github.com/boennemann/badges">Badges</a></p>
<p> <a href="https://gist.github.com/lukas-h/2a5d00690736b4c3a7ba">Markdown License badges</a></p>
<p> <a href="https://github.com/dwyl/repo-badges">repo-badges</a></p>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><p>使用各种服务时，服务商提供了Badge -&gt; 使用它; 没有 -&gt; 2</p>
</li>
<li><p>使用Shields.io自己做一个</p>
</li>
</ol>
]]></content>
      <categories>
        <category>What</category>
      </categories>
  </entry>
  <entry>
    <title>Nexus 5 购入 刷机 升级 笔记</title>
    <url>/2022/07/08/nexus5/</url>
    <content><![CDATA[<p>在论坛中看到可以入手一台Nexus 5来测试应用，于是开始了折腾之旅。</p>
<span id="more"></span>

<p>从淘宝或咸鱼花一百左右收一台Nexus 5。注意它是用老版的Android数据线。</p>
<p>到手是Android 4.4，在升级到Android 5.0.1后，一切正常。于是开始熟练地<code>adb shell pm uninstall --user 0 -k ...</code>卸载起系统应用来。但是在最后卸载Google搜索后，把机器给弄死机了。无奈只好强制恢复出厂设置。</p>
<p>根据<a href="https://zhuanlan.zhihu.com/p/19635679">Nexus 刷机步骤</a>，<code>关机状态下长按音量下+电源就可以进入</code>。要先按音量下。</p>
<p>顺利双清后，发现系统连不上Wifi了。一通失败的操作后，最后决定根据上文链接手动换系统。</p>
<p>先去 <a href="https://developers.google.com/android/images">https://developers.google.com/android/images</a> 下载压缩包，然后ADB一通操作。据说直接运行flash-all脚本就可以，但是我总会遇到系统无限重启的问题。</p>
<p>最后根据<a href="https://www.jianshu.com/p/c14f003fa844">Nexus 5刷机无限重启的解决方案</a>，只好手动输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot erase cache</span><br><span class="line">fastboot erase userdata</span><br><span class="line">fastboot erase boot</span><br><span class="line">fastboot erase cache</span><br><span class="line">fastboot erase recovery</span><br><span class="line">fastboot erase system</span><br><span class="line"></span><br><span class="line">fastboot flash bootloader bootloader-hammerhead-hhz20h.img</span><br><span class="line">fastboot reboot-bootloader</span><br><span class="line"></span><br><span class="line">fastboot flash radio radio-hammerhead-m8974a-2.0.50.2.30.img</span><br><span class="line">fastboot reboot-bootloader</span><br><span class="line"></span><br><span class="line">fastboot flash recovery recovery.img</span><br><span class="line">fastboot flash boot boot.img</span><br><span class="line">fastboot flash system system.img</span><br><span class="line">fastboot flash cache cache.img</span><br><span class="line">fastboot flash userdata userdata.img</span><br></pre></td></tr></table></figure>

<p>另外发现为了解决无法连接Wifi的问题，必须刷到Andorid 4.4，再到手机中手动升级到Andorid 5。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Material Design 笔记</title>
    <url>/2018/05/27/md-notes/</url>
    <content><![CDATA[<p><strong>不保证全对、可能更新，这玩意儿主要是给自己看的</strong></p>
<p>2018年5月27日更新：更新了一些无用的笔记<br>2018年5月23日更新：增加了Material Desgin 2字体的可能的可选值</p>
<p><a href="https://material.io/">Material Desgin</a></p>
<span id="more"></span>

<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><h4 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a>Surfaces</h4><p>各个元素的厚度都是相同的，1dp，白色，自带一个阴影。但可以通过不同elevation和shadows表示高度。</p>
<ul>
<li>Elevation和Shadows: Elevation指的是元素的高度；后者指的是阴影大小。原则是，高度越大，阴影越大。</li>
</ul>
<p>元素的分辨率应为无限 =&gt; 使用矢量图</p>
<p>在Surfaces上显示的内容只要不超出边界，厚度为0，随意使用。</p>
<p>同一时间这能操作一个Surface。多个Surfaces重叠时，使用不同的elevation分别。</p>
<p>Surface继承于一张纸: </p>
<ul>
<li>不是气体或液体，不能穿透。可以规则变形（通过折纸）、可以旋转或移动（动画要协调、用于容纳内容或其他目的）</li>
<li>可以改变透明度、长宽可变、可以分割或合并</li>
<li>不可以卷角</li>
<li>可以凭空出现或消失（魔法）</li>
<li>点击时，向上升起(elevation++, shadows++)迎接点击。</li>
</ul>
<h4 id="Elevation-amp-amp-Depth"><a href="#Elevation-amp-amp-Depth" class="headerlink" title="Elevation &amp;&amp; Depth"></a>Elevation &amp;&amp; Depth</h4><p>所有元素都有elevation，值越大，内容越重要。常见的有：Dialog 24dp, Drawer 16dp, App Bar 4dp, FAB 6dp</p>
<p>不同情况和布局，元素的elevation可变。比如点击Button 2dp =&gt; 8dp，Fab 6dp =&gt; 12dp。</p>
<p>为了解决elevation变化时，不同元素的重叠问题，被重叠的元素可以暂时消失（实现起来复杂了，这类行为尽可能减少）。</p>
<p>Elevation也被用作不同Surfaces的分割，也可以使用颜色或不透明度。</p>
<p><a href="https://material.io/design/environment/elevation.html#default-elevations">各元素默认elevation</a></p>
<h4 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h4><p>分为点光源（Key Light）和平行光源（Ambient Light），结合起来使用。</p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>元素按8dp排列，小元素按4dp。sp默认大小与dp一样，设置中的字体大小会给sp一个倍数。</p>
<p>Columns, Gutters, Margins：Margins就是左右边边界（手机16dp，平板24dp），Columns是一个个竖块儿（宽度可变)，Gutters是Columns之间的空隙（宽度可变）。</p>
<p>Columns和Gutters应为一个宽，一个窄。</p>
<p>常用的Breakpoints就只剩600dp了吧。</p>
<p>可触摸元素至少是48dp，边界8dp。不可触摸元素至少是24dp，边界8dp。</p>
<p>行高通常为48dp。</p>
<p><a href="https://material.io/design/layout/component-behavior.html#responsive-patterns">响应式</a>个人实现思路：</p>
<ul>
<li>Reveal Drawer：知道MaterialDrawer似乎可以直接拿来用，Support Library中的还真不知道</li>
<li>Reveal Options：Custom View吧</li>
<li>Reveal Card：TextView中的叫ell什么的属性</li>
<li>Transform Drawer to Tab：两套UI和代码？</li>
<li>Transform List to Grid：换一下LayoutManager</li>
<li>Transform Overflow Menu：ifRoom的属性</li>
<li>Devide Drawer：同Reveal Drawer</li>
<li>Devide Tab to Cards：两套UI和代码？</li>
<li>Reflow List：FlexboxLayout</li>
<li>Reflow Tab to List：两套UI和代码？</li>
<li>Reflow Picker：两套UI和代码？</li>
<li>Expand Cards：设置最大宽度和Increment</li>
<li>Expand Dialog：有区别吗？</li>
<li>Position Sheet to Overflow Menu：两套UI和代码？</li>
<li>Position FAB：两套代码？</li>
</ul>
<h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><p><a href="https://material.io/design/navigation/navigation-transitions.html">实现？</a></p>
<h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><p>Primary Color：出现次数最多的颜色。没有Accent时取代Accent。</p>
<p><a href="https://material.io/design/color/text-legibility.html">各种文字颜色和透明度的推荐值</a></p>
<h3 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h3><ul>
<li>Typeface和Font：前者可以看成一种风格，后者是一种具体字体。</li>
<li>Sans Serif和Serif：是两种typeface。Serif译作衬线，比如<code>I</code>，有衬线就是上下有横杠。<code>sans</code>是无的意思，非衬线体，<code>I</code>就一竖杠。</li>
<li>Monospace：typeface，宽度都一样。表示数字时很有用。</li>
<li>Handwriting：typeface，手写体，用于Headlines H1 - H6</li>
</ul>
<p>分为了12个Type Scale。Headline H1 - H6, Subtitle 1 - 2, Body 1 - 2, Button, Caption和Overline</p>
<ul>
<li>Headlines：标题。除六个外还可以使用自定义的字体。Serif或sans serif也可以，它们适合小标题。</li>
<li>Subtitles：副标题。Serif或sans serif也可以。但自定义字体可能会让问题看不清。</li>
<li>Body：内容体。Serif或sans serif也可以。不用自定义字体。</li>
<li>Caption &amp;&amp; Overline(文字上方一横线)：极小字体，用于解释图片或标注。Serif或sans serif也可以。不用自定义字体。</li>
<li>Button：通常都是sans serif + 全大写。也可以serif。和非互动文字混淆时，用户可能意识不到可以点击。不用自定义字体。</li>
</ul>
<p>每行字数通常为短为20 - 40，中为40 - 60，最多120。</p>
<p>开发过程中，可以参考<a href="https://stackoverflow.com/a/19692168/5507158">Valid values for android:fontFamily and what they map to?</a>中的字体，图省事得用<code>android:textAppearance=&quot;@style/TextAppearance.AppCompat.**&quot;</code></p>
<p>更新：在新版本的Material Desgin 2中，似乎可以通过类似<code>?attr/textAppearanceHeadline6</code>或<code>TextAppearance.MaterialComponents.Subtitle2</code>获取相应的字体。</p>
<h3 id="Iconography"><a href="#Iconography" class="headerlink" title="Iconography"></a>Iconography</h3><p>图标48dp。编辑时放大四倍，按192dp编辑，4dp边缘。方形边长152dp，圆形直径176dp。</p>
<h3 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h3><h3 id="Interaction"><a href="#Interaction" class="headerlink" title="Interaction"></a>Interaction</h3><h3 id="Communication"><a href="#Communication" class="headerlink" title="Communication"></a>Communication</h3><h2 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h2><h3 id="Development-Tuturials-Kotlin-Codelabs"><a href="#Development-Tuturials-Kotlin-Codelabs" class="headerlink" title="Development Tuturials(Kotlin Codelabs)"></a>Development Tuturials(Kotlin Codelabs)</h3><p>新玩意：</p>
<ul>
<li><code>MaterialButton</code>取代默认<code>Button</code>。使用<code>style=&quot;@style/Widget.MaterialComponents.Button.TextButton&quot;</code>可以移除背景。</li>
<li>很多元素用<code>MaterialComponents</code>取代<code>AppCompat</code></li>
<li><code>CardView</code>被囊括在design library中，更名为<code>MaterialCardView</code></li>
<li><code>?attr/textAppearanceHeadline6</code>：新的(?)<code>textAppearance</code>，符合Design中的Type Scale</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Deprecated 开发历程</title>
    <url>/2019/07/07/personal-info/</url>
    <content><![CDATA[<p>Deprecated</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>What</category>
      </categories>
  </entry>
  <entry>
    <title>Material Desgin响应式布局Android实现思路</title>
    <url>/2018/06/03/reponsive-patterns/</url>
    <content><![CDATA[<p>虽然Google已经放弃了它的Android平板产品，但开发者不会（哭）。</p>
<p>在Mateiral Design中，有一部分是<a href="https://material.io/design/layout/component-behavior.html#responsive-patterns">关于适配手机小屏幕和平板大屏幕的内容</a>。这里是他们的一些实现思路。</p>
<span id="more"></span>

<h2 id="Reveal-1-Drawer"><a href="#Reveal-1-Drawer" class="headerlink" title="Reveal 1: Drawer"></a>Reveal 1: Drawer</h2><p><img src="https://material.io/design/assets/1eEEDI_xEyFFa6y-_yyRxyP-TpgsPb2Pr/layout-responsive-patterns-reveal-navdrawer.png" alt="Reveal 1: Drawer"></p>
<p>简单方案：使用<a href="https://github.com/mikepenz/MaterialDrawer">MaterialDrawer</a>，内置了MiniDrawer支持。在代码中根据屏幕大小判断并设置。</p>
<p><a href="https://github.com/mikepenz/MaterialDrawer/blob/develop/app/src/main/java/com/mikepenz/materialdrawer/app/MiniDrawerActivity.java">MaterialDrawer MiniDrawerActivity</a>和<a href="https://github.com/mikepenz/MaterialDrawer/blob/develop/app/src/main/res/layout/activity_mini_drawer.xml">它的Layout XML</a></p>
<p>复杂方案：<a href="https://nganthony.github.io/2016/01/24/implementing-android-mini-navigation-drawer.html">手动实现</a></p>
<p>其他方案：等待Google官方支持</p>
<h2 id="Reveal-2-Options"><a href="#Reveal-2-Options" class="headerlink" title="Reveal 2: Options"></a>Reveal 2: Options</h2><p><img src="https://material.io/design/assets/1QUva50z9eylQ2Me2EAptRdB3Yfu03WuP/layout-responsive-patterns-reveal-wordprocessor.png" alt="Reveal 2: Options"></p>
<p>简单方案：使用HorizontalScrollView、FlexboxLayout、Overflow Menu的话，修改好一些属性后无需担心。</p>
<p>复杂方案：使用CustomView，手动排列、显示、隐藏</p>
<h2 id="Reveal-3-Dialog"><a href="#Reveal-3-Dialog" class="headerlink" title="Reveal 3: Dialog"></a>Reveal 3: Dialog</h2><p><img src="https://material.io/design/assets/1X0_fk6SxxVfzcq3FXawUxT5HmiKta3b3/layout-responsive-patterns-reveal-card.png" alt="Reveal 3: Dialog"></p>
<p>手动判断，为小屏幕隐藏那些过多的内容。</p>
<h2 id="Transform-1-Drawer-to-Tab"><a href="#Transform-1-Drawer-to-Tab" class="headerlink" title="Transform 1: Drawer to Tab"></a>Transform 1: Drawer to Tab</h2><p><img src="https://material.io/design/assets/1vz5WkJG9K_dyBrfJHekJ8c5Wsol-yN9O/layout-responsive-patterns-transform-navdrawer.png" alt="Transform 1: Drawer to Tab"></p>
<p>为了适配Tab，就得用ViewPager。</p>
<p>所以使用ViewPager + Fragments，在手机屏幕下，<a href="https://stackoverflow.com/a/13437997/5507158">禁止ViewPager滑动</a>，移除或隐藏TabLayout，使用Drawer进行切换Fragments；平板屏幕下，允许ViewPager滑动，增加或显示TabLayout，移除Drawer，让用户滑动进行Navgiate。</p>
<h2 id="Transform-2-List-to-Grid"><a href="#Transform-2-List-to-Grid" class="headerlink" title="Transform 2: List to Grid"></a>Transform 2: List to Grid</h2><p><img src="https://material.io/design/assets/1ikwM7lbX4PAK34WZOL4IMBm9SIhaN2Di/layout-responsive-patterns-transform-list.png" alt="Transform 2: List to Grid"></p>
<p>使用不同的LayoutManager和ViewHolder(使用泛型Adapter?)</p>
<h2 id="Transform-3-Overflow-Menu"><a href="#Transform-3-Overflow-Menu" class="headerlink" title="Transform 3: Overflow Menu"></a>Transform 3: Overflow Menu</h2><p><img src="https://material.io/design/assets/1a7U47c6ZgWVfDZKRpZ7FzLKgMmZdfOvy/layout-responsive-patterns-transform-toolbar.png" alt="Transform 3: Overflow Menu"></p>
<p>设置showAsAction为ifRoom或者在代码中根据屏幕设置。</p>
<h2 id="Devide-1-Drawer"><a href="#Devide-1-Drawer" class="headerlink" title="Devide 1: Drawer"></a>Devide 1: Drawer</h2><p><img src="https://material.io/design/assets/1oIscQOmfgUeVn7YHdm4j103W8K3SONg_/layout-responsive-patterns-transform-divide-1.png" alt="Devide 1: Drawer"></p>
<p>同<a href="#reveal-1:-drawer">Reveal 1: Drawer</a></p>
<h2 id="Devide-2-Tab-to-Cards"><a href="#Devide-2-Tab-to-Cards" class="headerlink" title="Devide 2: Tab to Cards"></a>Devide 2: Tab to Cards</h2><p><img src="https://material.io/design/assets/1NWWybr23o4mQ3eka3MIZfNomzNoPGaT4/layout-responsive-patterns-transform-divide-2.png" alt="Devide 2: Tab to Cards"></p>
<p>手机屏幕用ViewPager，平板屏幕用两个Fragment。在Activity中判断。</p>
<h2 id="Reflow-1-List-to-Grid"><a href="#Reflow-1-List-to-Grid" class="headerlink" title="Reflow 1: List to Grid"></a>Reflow 1: List to Grid</h2><p><img src="https://material.io/design/assets/15dkIemLoJvvIR4Y--C_aylSLrub4e-RW/layout-responsive-patterns-transform-reflow-1.png" alt="Reflow 1: List to Grid"></p>
<p>同<a href="#transform-2:-list-to-grid">Transform 2: List to Grid</a></p>
<h2 id="Reflow-2-Tabs-to-Lists"><a href="#Reflow-2-Tabs-to-Lists" class="headerlink" title="Reflow 2: Tabs to Lists"></a>Reflow 2: Tabs to Lists</h2><p><img src="https://material.io/design/assets/1VXqd6WD0BvreENnNk0g_dqtyUv8rAMsT/layout-responsive-patterns-transform-reflow-2.png" alt="Reflow 2: Tabs to Lists"></p>
<p>更换每个Fragment的LayoutManager。手机屏幕使用ViewPager，平板屏幕使用Static Fragments。</p>
<h2 id="Reflow-3-Time-Picker"><a href="#Reflow-3-Time-Picker" class="headerlink" title="Reflow 3: Time Picker"></a>Reflow 3: Time Picker</h2><p><img src="https://material.io/design/assets/1Aj5t9FM3cIrRgmCaTnPWrKLlPUjd34bv/layout-responsive-patterns-transform-reflow-3.png" alt="Reflow 3: Time Picker"></p>
<p>使用不同的Layout XML</p>
<h2 id="Expand-1-Max-Size"><a href="#Expand-1-Max-Size" class="headerlink" title="Expand 1: Max Size"></a>Expand 1: Max Size</h2><p><img src="https://material.io/design/assets/1L6lMye5M8N6h3NHkmRD9b7mqWNd-aqIY/layout-responsive-patterns-transform-expand-1.png" alt="Expand 1: Max Size"></p>
<p>使用不同的style设置width和height。</p>
<p>顶部空白：1. 顶部添加一个空白View，手机屏幕上0dp，平板屏幕上有高度。2. 直接使用不同的paddingTop。</p>
<h2 id="Expand-2-Dialog"><a href="#Expand-2-Dialog" class="headerlink" title="Expand 2: Dialog"></a>Expand 2: Dialog</h2><p><img src="https://material.io/design/assets/1apntZGLUuUlSkhpnTJe2ikMeTIFP1cKJ/layout-responsive-patterns-transform-expand-2.png" alt="Expand 2: Dialog"></p>
<p>我不认为这需要修改任何代码。</p>
<h2 id="Position-1-Menu"><a href="#Position-1-Menu" class="headerlink" title="Position 1: Menu"></a>Position 1: Menu</h2><p><img src="https://material.io/design/assets/1pmCqvMVPajmoDsmxmL-JBz4zqy88dSEa/layout-responsive-patterns-transform-position-1.png" alt="Position 1: Menu"></p>
<p>在代码中使用BottomDialog并显示或隐藏OverflowMenu(修改onCreateOptionsMenu返回值)。</p>
<h2 id="Position-2-FAB"><a href="#Position-2-FAB" class="headerlink" title="Position 2: FAB"></a>Position 2: FAB</h2><p><img src="https://material.io/design/assets/1QALKDtXeGMSXcRu3uOA7eOUDoa2GMnlm/layout-responsive-patterns-transform-position-2.png" alt="Position 2: FAB"></p>
<p>不同的style，设置FAB的anchor。也可以通过代码设置。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>使用Splinter模拟网页操作</title>
    <url>/2018/04/01/splinter/</url>
    <content><![CDATA[<p>之前需要用代码来代替一些繁琐重复的网页操作，自然想到用Python自动化这些工作。</p>
<p>然后找到了<a href="https://hackernoon.com/mastering-python-web-scraping-get-your-data-back-e9a5cc653d88">这篇文章</a>。它用了Splinter，一个Selenium的包装。尝试之后发现意外地简单。</p>
<p>内容大同小异，说明几个坑。</p>
<span id="more"></span>

<p>我用的是Py3.6和Chrome.</p>
<h2 id="Chrome驱动"><a href="#Chrome驱动" class="headerlink" title="Chrome驱动"></a>Chrome驱动</h2><p>需要提前在<a href="https://sites.google.com/a/chromium.org/chromedriver/">这里</a>下载Chrome的驱动，再把下载到的<code>chromedriver.exe</code>放到Python代码的目录下。就可以使用了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">executable_path = &#123;<span class="string">&#x27;executable_path&#x27;</span>: <span class="string">&#x27;chromedriver.exe&#x27;</span>&#125;</span><br><span class="line">browser = Browser(<span class="string">&quot;chrome&quot;</span>, **executable_path)</span><br><span class="line">browser.driver.set_window_size(<span class="number">1200</span>, <span class="number">800</span>)</span><br></pre></td></tr></table></figure>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul>
<li><code>browser.driver.execute_script(&quot;window.open(&#39;&#39;);&quot;)</code> 新建Tab</li>
<li><code>browser.windows.current = browser.windows[0]</code> 切换Tab</li>
<li><code>Pandas</code>读数据：  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_dict</span>(<span class="params">name</span>):</span><br><span class="line">    my_df = pd.read_csv(name)</span><br><span class="line">    titles = my_df[<span class="string">&#x27;Title&#x27;</span>].tolist()</span><br><span class="line">    links = my_df[<span class="string">&#x27;Link&#x27;</span>].tolist()</span><br><span class="line">    <span class="keyword">return</span> &#123;titles[i]: links[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(titles))&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>用Splinter和Selenium完成一些简单的签到、爬数据还算方便，不需要理会用爬虫时Cookie、异步、认证等问题。</p>
<p>开头提到的文章中讲的太详细以致于我已无法可说了。</p>
]]></content>
      <categories>
        <category>Automation</category>
      </categories>
  </entry>
  <entry>
    <title>sed 使用笔记</title>
    <url>/2024/04/21/sed/</url>
    <content><![CDATA[<p><code>sed</code></p>
<span id="more"></span>

<p><a href="https://regex-vis.com/">https://regex-vis.com/</a></p>
<ul>
<li><p>替换<code>oldfile</code>文件中的<strong>每行第一个</strong><code>find</code>为<code>replace</code>，保存内容到<code>newfile</code>中</p>
<p><code>sed &#39;s/find/replace/&#39; &lt;oldfile &gt;newfile</code></p>
</li>
<li><p>替换<code>oldfile</code>文件中的<strong>每一个</strong><code>&lt;space&gt;find</code>为<code>replace</code>，保存内容到<code>newfile</code>中</p>
<p><code>sed &#39;s/ find/replace/g&#39; &lt;oldfile &gt;newfile</code></p>
</li>
<li><p>替换<code>filename</code>文件中的每一个<code>find</code>为<code>replace</code></p>
<p><code>sed -i &#39;s/find/replace/g&#39; filename</code></p>
</li>
<li><p>替换<code>filename</code>文件中的包含<code>Replace</code>文字的每一行中的<code>the</code>为<code>THE</code></p>
<p><code>sed -i &#39;/Replace/s/the/THE/g&#39; filename</code></p>
</li>
<li><p>删除<code>filename</code>文件中的包含<code>Replace</code>文字的每一行</p>
<p><code>sed -i &#39;/Replace/d&#39; filename</code></p>
</li>
<li><p>不使用<code>-i</code>则打印内容</p>
</li>
<li><p>运行多条命令</p>
<ul>
<li><code>sed -i &#39;...;...&#39; filename</code></li>
<li><code>sed -i -e &#39;...&#39; -e &#39;...&#39; filename</code></li>
</ul>
</li>
<li><p><code>\/</code>转义<code>/</code>或使用<code>s#find#replace#g</code>, <code>s|find|replace|g</code>, <code>.</code></p>
</li>
<li><p>打印出包含<code>usr</code>的每一行: <code>sed &#39;/user/p&#39;</code></p>
</li>
<li><p>删除<code>redacted</code>: <code>sed &quot;s/redacted//g filename</code></p>
</li>
<li><p>删除空行: <code>sed &quot;/^$/d&quot; filename</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>我们为什么不相信狼来了中的那个孩子</title>
    <url>/2018/12/25/thoughts-cry-wolf/</url>
    <content><![CDATA[<p>废话，因为他说的话不靠谱。但是狼真的来的时候，他也没说错呀。</p>
<span id="more"></span>

<p>这是一个信任成本的问题。如果一个人的信任成本很高，大伙儿就偏向于不相信他。注意是信任成本<strong>高</strong>，而不是无穷大或者说这个人不能被信任，毕竟不存在一直在撒谎的人。</p>
<p>所以我们的逻辑成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 这个人的信任成本高：</span><br><span class="line">  不相信他</span><br><span class="line">else：</span><br><span class="line">  另加讨论</span><br></pre></td></tr></table></figure>

<p>我们不相信他<strong>不是因为他有错</strong>，而是因为从他口中得到的信息假多真少。我们为了让自己信任一个人的成本维持在一个正常水平，才选择不相信他说的所有内容。</p>
<p>那我们在微信群中常见的谣言、微博上一些信口开河的大/小V，他们的信任成本高吗？那相信他们的人多吗？那他们知道狼来了的故事吗？那他们明白那个故事吗？</p>
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>两种安慰别人的方式</title>
    <url>/2019/07/05/thoughts-comfort/</url>
    <content><![CDATA[<p>生活压力大，找人诉苦。别人听完了你的诉苦水，总得说点什么吧。有意思的地方来了。</p>
<span id="more"></span>

<p>有两种安慰人的方式，对不同的人有不同的效果。快来对号入座儿。</p>
<h2 id="1-“你过得一点都不惨”"><a href="#1-“你过得一点都不惨”" class="headerlink" title="1. “你过得一点都不惨”"></a>1. “你过得一点都不惨”</h2><p>“比你过得惨的人多的去了，${列举各种惨状}的人还不过了嘛？”之类的安慰语。</p>
<p>诉苦主体可以对此两种反应:</p>
<ol>
<li><p>“原来我也不算最糟糕的嘛，比我惨多的去了，平衡了平衡了。”</p>
<p> 起到了正面效果。诉苦主题认清了自己的位置，重拾了生活的希望。</p>
</li>
<li><p>“你是在说我矫揉造作，是个懦夫吗？”</p>
<p> 起到了负面效果。诉苦主体此时感觉更糟糕了，因为不仅没人能跟他感同身受，而且还被嘲讽、鄙视了。</p>
</li>
</ol>
<h2 id="2-“你过得好惨啊”"><a href="#2-“你过得好惨啊”" class="headerlink" title="2. “你过得好惨啊”"></a>2. “你过得好惨啊”</h2><p>“这也太惨了吧”之类的安慰语，有的人甚至还会笑出来。</p>
<p>诉苦主体可以对此两种反应:</p>
<ol>
<li><p>“我真的是惨，失败的人生！”</p>
<p> 起到了负面效果。击碎了诉苦主体最后的波纹。</p>
</li>
<li><p>“哈哈，对吧。这就是生活啊！”</p>
<p> 起到了正面效果。诉苦主题接受了现实，被迫面对生活。跟前一个相比，效果也算比较正面。</p>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>具体要说什么话，还是要对人对事。</p>
<h2 id="嗯…………"><a href="#嗯…………" class="headerlink" title="嗯…………"></a>嗯…………</h2><p>我总感觉还有些东西没有挖掘出来，但找不到是哪些。</p>
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>万恶淫为首，论迹不论心，论心世上无完人</title>
    <url>/2022/04/21/thoughts-junzi/</url>
    <content><![CDATA[<p>今日网上冲浪，遇到了一句“君子论迹不论心，论心世上少完人”，于是有了本文。</p>
<span id="more"></span>

<p>当然，“万恶淫为首”中的“淫”在广义上指的是欲望的放纵。</p>
<h2 id="今天之前"><a href="#今天之前" class="headerlink" title="今天之前"></a>今天之前</h2><p>曾经在读《苏菲的世界》时，记录了一句印象深刻的话：</p>
<blockquote>
<p>我们因此对每一件与性和性器官有感的事情有了一种罪恶感。由于这种罪恶感一直停留在在超我之中，因此很多人——弗洛伊德甚至认为是大多数人——终其一生都对性有一个罪恶感。而根据弗洛伊德的说法，性的欲望和需求事实上人类天性中很自然而且很重要的一部分。就这样，人的一生都充满了欲望与罪恶感之间的冲突。</p>
</blockquote>
<p>我自然也不例外，一直深受其扰。</p>
<p>久而久之，我便萌生了一个念头：我想了什么不重要，重要的是我做了什么。而我迄今还未放浪形骸，于是这件事也就暂告一段落了。</p>
<h2 id="新的转机"><a href="#新的转机" class="headerlink" title="新的转机"></a>新的转机</h2><p>但在今天，我看到网友提了一句“君子论迹不论心，论心世上少完人”，惊为天人！</p>
<p>这种自己的想法与古人的想法，穿越时空然后殊途同归、意外碰撞的感觉太棒了！</p>
<p>谨慎的我决定找一找这句话的出处。</p>
<h2 id="出师不利"><a href="#出师不利" class="headerlink" title="出师不利"></a>出师不利</h2><p>直接在搜索引擎中搜索，除去对这句话本身的讨论外，几乎所有中文资料都指向了一个出处：<a href="https://zh.wikipedia.org/zh-cn/%E5%9B%B4%E7%82%89%E5%A4%9C%E8%AF%9D">清朝作家王永彬的作品《围炉夜话》</a>。</p>
<p>但是，我在找到《围炉夜话》细细查阅后，只发现了<a href="https://so.gushiwen.cn/guwen/bookv_46653FD803893E4F13BF45F8F63D53DB.aspx">这么一句</a>：</p>
<blockquote>
<p>常存仁孝心，则天下凡不可为者，皆不忍为，所以孝居百行之先；一起邪恶念，则生平极不欲为者，皆不难为，所以淫是万恶之首。</p>
</blockquote>
<p>但这句话明显没有“论迹不论心，论心世上少完人”这个意思呀！</p>
<p>到这里我明白了，这又是一个中文互联网互相抄袭、大锅乱炖的信息了。</p>
<h2 id="大海捞针"><a href="#大海捞针" class="headerlink" title="大海捞针"></a>大海捞针</h2><p>在经历了逐条翻阅搜索记录、失足于内容农场、切换使用引号逐词搜索后，终于功夫不负有心人，发现了线索！</p>
<p>在<a href="https://www.zhihu.com/question/23539073/answer/44490757">知乎的某个回答中</a>提到了：</p>
<blockquote>
<p>这幅对联一般在城隍庙门前书写…如沈阳城隍庙…出处已难以考证，张维迎教授在《市场逻辑和强盗逻辑》中提到他在山西榆次县古衙门看到过，南怀瑾先生在书中也提到过“古人云”，亦有书籍提到“上联为道光时甘谷生员张及泉先生撰写”。在天津市社科院研究员温克勤教授的《中国伦理思想简史》中，提到过后两句是后人所填：</p>
<blockquote>
<p>过去有个故事：一城隍庙有副对联：“百行孝为先；万恶淫为首”。后来有人在对联下面续加了字句，成为“百行孝为先，论心不论事，论事则天下无孝子；万恶淫为首，论事不论心，论心则举世无完人。”</p>
</blockquote>
</blockquote>
<p>在另<a href="http://zhidao.baidu.com/question/1644539061054966260/answer/3402893393">一个百度知道回答中</a>，有了更多的线索：</p>
<blockquote>
<p>这是梁章钜《楹联丛话》卷四·庙祀中：张南山寄录城隍庙一幅对联中的半句。</p>
</blockquote>
<p><a href="https://book.douban.com/subject/1910469/">《楹联丛话》</a>虽是《围炉夜话》之后成书，但<a href="https://ctext.org/wiki.pl?if=gb&chapter=782493&remap=gb#p38">其中有一句</a>：</p>
<blockquote>
<p>张南山寄录城隍庙一联云：「百行孝为先，论心不论事，论事贫家无孝子；万恶淫为首，论事不论心，论心终古少完人。」</p>
</blockquote>
<p>至此，看来这句话：</p>
<blockquote>
<p>百善孝为先，论心不论迹，论迹贫家无孝子；万恶淫为首，论迹不论心，论心世上无完人。</p>
</blockquote>
<p>的一半意思的出处已不可靠。内容常见于城隍庙。</p>
<p>不过这句话却深得我心，不禁感叹文化的博大精深，民间的熟语也都充满了智慧。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>中华文化真包容呀，既有“知行合一”，又有“论心不论迹”、“论迹不论心”。</p>
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>三个和尚没水喝</title>
    <url>/2018/10/30/thoughts-three-monks/</url>
    <content><![CDATA[<p>没时间解释了，直接切入正题。</p>
<span id="more"></span>

<p>发展到二十一世纪，这个现象依然普遍存在 =&gt;</p>
<p>可以假设这个现象将长时间存在并难以避免或逆转 (=&gt; 激进版：我认为在人类摆脱肉体存在之前做不到) + 我们不能浪费这个寓言故事 =&gt;</p>
<p>我们要利用这个注定存在现象/事实 + 我们都是<strong>广义</strong>的利己主义者 =&gt;</p>
<p>我们要利用它，让它利于我们 =&gt;</p>
<p>利用需要方法 + 解决问题的方案有两种 =&gt;</p>
<ol>
<li><p>正面迎击，解决问题：立下规矩，轮流挑水。</p>
</li>
<li><p>侧面回避，让问题消失</p>
<ol>
<li><p>排挤第三个人，让他退出，回到两个人挑水喝的日子。</p>
</li>
<li><p>拉第四个人入伙，配对挑水。</p>
</li>
</ol>
</li>
<li><p>不解决：那就不喝水喽，喝自己的冰阔落。</p>
</li>
</ol>
<p>=&gt; 这些把戏很常见吧，这就对了。</p>
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>截至到2020年1月19日三个月内计时机器的统计数据</title>
    <url>/2020/01/19/timer-analytics-2020-1-19/</url>
    <content><![CDATA[<p>这里做个大概的总结，文中出现的所有排列<strong>都分先后</strong>，只选取了数据最多的前几名进行展示和说明。</p>
<p>因为我发现这些数据没啥用，从4.1.0开始将不再统计了。</p>
<span id="more"></span>

<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>国内：七成4.0.0，一七成3.8.0，第三用户量最多的是1.1.1(2.67%)（应该是第一个引入专业版的版本，但我不知道为何有人停留在此版本）和2.1.0(2.08%)（这个也不清楚）。</p>
<p>谷歌：九七成的4.0.0，0.2%的3.8.0。</p>
<p>Google Play Store的更新真及时呀。</p>
<h2 id="运行界面下方按钮"><a href="#运行界面下方按钮" class="headerlink" title="运行界面下方按钮"></a>运行界面下方按钮</h2><p>国内：默认的五个（开始/暂停，下一步，停止，编辑，上一步）霸占前五，剩下的就是更多里的选项，都是百分之一或二。</p>
<p>谷歌：默认的五个（下一步，开始/暂停，编辑，停止，上一步）霸占前五，其余同上。</p>
<h2 id="计时器选项（打开此选项并保存的用户中）"><a href="#计时器选项（打开此选项并保存的用户中）" class="headerlink" title="计时器选项（打开此选项并保存的用户中）"></a>计时器选项（打开此选项并保存的用户中）</h2><p>国内：7%的人选择关闭计时器通知中的读秒，8%的人选择关闭计时器通知。21.5%的人选择了在计时器结束后继续运行一个其他计时器。</p>
<p>谷歌：3%的人选择关闭计时器通知中的读秒，4%的人选择关闭计时器通知。22.3%的人选择了在计时器结束后继续运行一个其他计时器。</p>
<h2 id="起始步骤"><a href="#起始步骤" class="headerlink" title="起始步骤"></a>起始步骤</h2><p>国内：大伙儿喜欢用嘟嘟、朗读、倒数来运行一个5秒左右的步骤来作为计时器的开始。</p>
<p>谷歌：老外们喜欢用嘟嘟、朗读、倒数来运行一个少则5到10秒，多则2到5分钟的步骤来作为计时器的开始。</p>
<p>行为一致，时长不同。</p>
<h2 id="普通步骤"><a href="#普通步骤" class="headerlink" title="普通步骤"></a>普通步骤</h2><p>国内：大伙儿喜欢用朗读、音乐、倒数来运行一个少则1分钟以内，多则2到10分钟的计时器。1到2分钟的步骤是最少的（百分之四）。</p>
<p>谷歌：老外们喜欢用朗读、嘟嘟、振动、倒数来运行10秒到5分钟的普通步骤。1到2分钟的步骤是同样最少的。</p>
<h2 id="通知步骤"><a href="#通知步骤" class="headerlink" title="通知步骤"></a>通知步骤</h2><p>国内：大伙儿喜欢用振动、音乐、屏幕来运行一个5秒左右的步骤来作为步骤间的提醒。</p>
<p>谷歌：老外们喜欢用音乐、振动、屏幕来运行一个5秒左右的步骤来作为步骤间的提醒。</p>
<h2 id="结束步骤"><a href="#结束步骤" class="headerlink" title="结束步骤"></a>结束步骤</h2><p>国内：大伙儿喜欢用朗读、音乐、振动来运行一个5秒左右的步骤来作为计时器的结束。</p>
<p>谷歌：老外们喜欢用朗读、音乐、振动来运行一个少则5秒左右，多则2到5分钟的步骤来作为计时器的结束。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>关于计时机器在Google Play渠道引入订阅制云备份的决定</title>
    <url>/2020/09/07/timer-cloud-backup/</url>
    <content><![CDATA[<p>计时机器在4.6.0开始，在Google Play下载的应用将包含需要订阅后可使用的云备份功能。在酷安下载的应用将不包含此功能。在此进行一些记录和说明。</p>
<span id="more"></span>

<h2 id="Google-Play版本和酷安版本区别"><a href="#Google-Play版本和酷安版本区别" class="headerlink" title="Google Play版本和酷安版本区别"></a>Google Play版本和酷安版本区别</h2><p>Google Play版本独占：云备份、未来可能加入到订阅计划中所有服务</p>
<p>酷安版本独占：开发日志、打赏</p>
<h2 id="从酷安版本迁移到Google-Play版本"><a href="#从酷安版本迁移到Google-Play版本" class="headerlink" title="从酷安版本迁移到Google Play版本"></a>从酷安版本迁移到Google Play版本</h2><ol>
<li>打开应用，打开侧边栏，选择“备份与还原”，选择“导出应用数据”，根据步骤将应用数据导出为一个文件。</li>
<li>在Google Play搜索“计时机器”并安装。</li>
<li>打开Google Play下载的应用，打开侧边栏，选择“备份与还原”，选择“导入应用数据”，将第一步导出的文件导入。</li>
<li>把新应用的系统白名单设置一下，以免应用锁屏后被系统强制关闭。</li>
<li>如果要使用云备份，且手机不是一直处于魔法上网的环境，请在订阅后将自动打开的自动云备份关闭，然后在需要时手动备份。</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>订阅使用了Google Play的In-app Billing，云备份使用了Firebase，而上述两个服务在中国大陆由于众所周知的原因无法使用。虽然这个问题有一个常见的解决方案：在大陆使用支付宝或微信支付，和Firebase的同类替代（像之前用过的LeanCloud），但由于<strong>国内个人支付资格难以获得、域名备案困难繁琐、应用曝光渠道狭窄、应用市场分散混乱等</strong>原因，故暂时放弃在中国大陆提供该服务的想法。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>计时机器公告2019-7-6</title>
    <url>/2019/07/06/timer-death/</url>
    <content><![CDATA[<h2 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h2><p>从计时机器3.8.0起，计时机器应用将从内购模式转为真·免费应用，所有专业版功能会在升级后为所有用户解锁。旧版本的登录、注册和激活将也会在未来几天失效。</p>
<p>以后的更新随缘，也会更加放飞自我。</p>
<span id="more"></span>

<h2 id="深情版本"><a href="#深情版本" class="headerlink" title="深情版本"></a>深情版本</h2><h3 id="想法的萌生"><a href="#想法的萌生" class="headerlink" title="想法的萌生"></a>想法的萌生</h3><p>这个应用的想法源自于16年跑步锻炼时，按着《爱上跑步的13周》里的计划，发现计时是个问题。当初就用手机自带的闹钟，到时间后按一下音量键，就会自动延时1分钟，以此来记录时间。碰巧当时刚刚接触Android开发，就萌生了写一个专门的应用的想法。于是“循环计时器”就诞生了。一开始还叫“循环闹钟”。</p>
<p>就这么像无头苍蝇一样维护了一年多吧。当初不会写代码，就到处抄。后来发现AOSP里的闹钟，也就是Android系统自带的时钟（叫DeskClock）是个很好的例子，而且也听信了<a href="https://web.archive.org/web/20180505121013/https://plus.google.com/+DianneHackborn/posts/FXCCYxepsDU">Dianne Hackborn说的Android搞MVC就可以啦的“谎言”</a>，就几乎把DeskClock里能搬过来的都改一改搬了过来。结果也料到了，代码库一团糟。</p>
<h3 id="计时机器的诞生"><a href="#计时机器的诞生" class="headerlink" title="计时机器的诞生"></a>计时机器的诞生</h3><p>同时随着用户的积累和反馈，也发现现有的代码库毫无可扩展性，就萌生了写一个新应用，用上我一路上所有学到的本事的想法。所以“计时机器”（英文名叫TimeR Machine，比时间机器Time Machine多了一个R，多好的名字）就在17年底诞生了。</p>
<p>计时机器也算自己亲生的，所以特别上心。代码库到今天也很干净，不仅上了MVVM，也用了TDD，测试一大堆。每次发布都要Code Review + 跑测试 + 亲自测试新功能，所以很少出现新版本发布后大面积崩溃/失效的情况。当然也翻车过一次，就是步骤重复那一次(开发日志2019年3月27日)，看来测试也不能涵盖所有使用情况呀。</p>
<p>计时机器经历了6个月左右的alpha版 + 3个月beta版后，正式版就在18年9九月发布啦。于此同时，循环计时器也正式被替代，凉凉了。</p>
<p>在18年底添加的专业版。其中的自定义主题费了我不少功夫，这也是我一个很自豪的功能，因为很多其他应用都只能使用预设的主题，而我的可以随便选，这个可费了不少功夫。各位还没试过的快去更新然后试试吧。</p>
<h2 id="现在的情况"><a href="#现在的情况" class="headerlink" title="现在的情况"></a>现在的情况</h2><p>计时机器一直都有两个版本，一个GooglePlay发布的，接入了Play的支付，数据保存用的是Firebase；一个是国内（酷安）发布的，数据保存用的是LeanCloud，但因为支付宝、微信支付等不给个人开发者一个方便的渠道，因此没有支付系统，所以各位需要在给我转账后，等我确认，然后手动在数据后台把专业版状态调一下，然后各位再刷新，就有专业版了。很笨的办法，但运行了半年来也很不错。</p>
<p>因为计时机器是独立开发的，所以我没时间、没精力、没能力去维护一个后台，所以必须使用一个BaaS（包装好的云服务器）。国外我用了杀手级服务Firebase，用到今天一直都很靠谱，也基本不用管。国内我挑了半天，最后选了LeanCloud，虽然跟Firebase相比简陋了很多，但过去跑起来也不错。</p>
<p>这次事故的<strong>直接原因</strong>来自于LeanCloud。在六月中下旬之交，<a href="https://blog.avoscloud.com/6841/">LeanCloud停摆了5天</a>，这也就是那几天各位都无法登录/注册的原因。在服务恢复后，LeanCloud就提出了新要求，要求实名认证和备案域名。前者传个身份证就搞定了，后者就要命了。要命的原因我想了很久、找了很久也不知道怎么解释。各位自己搜索 + 意会吧。但结果就是如果搞不定它，LeanCloud很快就不给用了；如果不给用了，登录/注册就都会失效。</p>
<p>其他BaaS服务商像Bmob等也考虑过，但那样的话不仅需要迁移各位的数据（就是让各位重新登陆/注册一遍），未来也可能面临需要备案域名的风险。</p>
<p><strong>同时也考虑到维护这个应用的资金基本转不起来、应用推广困难重重等原因，索性不破不立，转免费吧。</strong></p>
<h2 id="谢谢各位"><a href="#谢谢各位" class="headerlink" title="谢谢各位"></a>谢谢各位</h2><p>谢谢各位使用计时机器，谢谢各位在应用商店里的打分和评论，谢谢各位早期对我的赞赏，谢谢各位专业版用户的支持！</p>
<p>一直以来，哪怕看到各位的只有一次支持和鼓励，都让我充满了继续更新下去的决心。再次谢谢各位！</p>
<img src="/2019/07/06/timer-death/bananice.jpg" class="" title="[bananice.jpg](.&#x2F;timer-death&#x2F;bananice.jpg)">

<p>以后的更新随缘，也会更加放飞自我。</p>
<blockquote>
<p>I’ve seen things you people wouldn’t believe. Attack ships on fire off the shoulder of Orion. I watched C-beams glitter in the dark near the Tannhäuser Gate. All those moments will be lost in time, like tears in rain. Time to die. - Blade Runner</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>计时机器无法唤醒设备的临时解决方案</title>
    <url>/2017/12/10/timer-huawei-solution/</url>
    <content><![CDATA[<p>计时机器无法唤醒国产设备的临时解决方案。几乎所有国产手机都需要类似的设置，因为国内厂商的对Android应用后台的态度是，错杀一万也不能放走一个没跟自己打招呼的应用。</p>
<span id="more"></span>

<p>华为用户：感谢酷安用户@无野 提供的华为设备在锁屏后无法运行的解决方案。我顺便修了一下图。</p>
<img src="/2017/12/10/timer-huawei-solution/huawei-solution.jpg" class="" title="[huawei-solution.jpg](.&#x2F;timer-huawei-solution&#x2F;huawei-solution.jpg)">

<p>其他用户：最近发现了一个链接<a href="https://bitbucket.org/copluk/acr/issues/607">ACR is automatically closed on some phones</a>，是个国外应用处理一些应用在国产设备上后台被杀时如何白名单的文章。虽然是英文，但下面有各个设备的链接，里面有一些示范图片，各位可以参考一下。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>计时机器的使用方法</title>
    <url>/2018/12/19/timer-machine-usage-zh/</url>
    <content><![CDATA[<p><strong>此文章已过时，来这里看最新的使用指南：<a href="https://github.com/DeweyReed/Grocery/blob/master/instruction-manuals/zh.md">计时机器的使用指南</a></strong></p>
<span id="more"></span>

<ol>
<li><p>步骤</p>
<p> 一个步骤代表要在一定时间内完成一件事。一个默认的步骤（新建普通步骤后不进行任何操作）只会安静地计时，然后安静地进入下一步骤或结束。</p>
<p> 如果想要知道一个步骤结束了，那么就需要在这个步骤添加一个专门提醒的步骤，并给它添加音乐、振动等等提醒效果（行为）。</p>
<p> 所有步骤的时间、行为、名字等都是可以修改的。</p>
<ul>
<li><p>特殊的步骤</p>
<ul>
<li><p>提醒步骤：它有一个不同的颜色（默认蓝色）；它会保存上一次编辑后的内容，并在下一添加提醒步骤时显示相同的内容；在这种步骤微调时间时，会退回到上一步并把时间设置为1分钟（设置里可以关闭）。</p>
</li>
<li><p>起始和结束步骤：一个计时器可以有多次循环，那这两个步骤可以用作整个计时器开始和结束的标志，它们只会在整个计时器的开始和结束时各执行一次。另外，使用计划任务来终结一个计时器时，到指定时间，计时器会自动跳到结束步骤。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>与循环计时器的不同</p>
<p> 最大的不同就是在计时机器中，需要手动添加提醒步骤，不然是不会得到任何反馈的。</p>
<p> 另外，循环计时器的提醒时长在应用设置里配置，并且是全局的。但在计时机器中，提醒步骤也是计时器的一部分（一个步骤），它的时长、音乐等等都需要手动设置。</p>
</li>
<li><p>未来的<del>饼</del>计划</p>
<p> 预计在2.0.0中加入“组”的概念，可以把现有的步骤放到组里，组有各自的名字和循环。到那个时候，我就得画图来解释了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android文字转语音(TTS)引擎</title>
    <url>/2019/03/11/tts/</url>
    <content><![CDATA[<p>位于【设置】-【无障碍】-【文字转语音(TTS)输出】。在这里可以配置引擎。一些应用会使用这个引擎进行文字阅读。但因为国内设备的特殊情况，想要让这个玩意儿阅读中文，还是需要一些设置的。</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这个设置是系统自带。这个功能不仅仅用于盲人使用设备时，将屏幕上的文字阅读出来，更广泛的用途是，语音播报内容，比如导航、天气预报等。这个功能的登场次数不算多，但我见过不少。</p>
<p>几乎所有Android设备会自带一个<code>Pico TTS</code>。</p>
<blockquote>
<p>Pico TTS: AOSP自带的TTS，支持的语言只有英德西法意。</p>
</blockquote>
<p>它不支持中文，加上国内多数厂商对这块儿并不怎么重视，导致了TTS这个功能在国内基本是荒废的。但Android留出接口，可以安装一些第三方支持中文的引擎来让Android阅读中文。</p>
<p><strong>有的国产系统后台管理严格，导致TTS无法启动运行，这种情况下TTS就已经凉了</strong></p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>国内一些导航应用导航时使用的方法，并不是使用这个引擎，而是另起炉灶，用的自己的方法或购买第三方的SDK。</p>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="Google文字转语音"><a href="#Google文字转语音" class="headerlink" title="Google文字转语音"></a>Google文字转语音</h3><p>在Google自家的设备上取代了<code>Pico TTS</code>，支持地球上绝大多数语言，基本是首选。在酷安和Google Play或各大应用市场都可以找到。</p>
<p>它默认会联网获取语音，但可能出现因网络状况而读不出来的情况，所以需要提前下载好语音包。但即使下好了语音包，有时也会读不出来 ㄟ( ▔, ▔ )ㄏ</p>
<h2 id="讯飞语记"><a href="#讯飞语记" class="headerlink" title="讯飞语记"></a>讯飞语记</h2><p>是讯飞的一个单独应用。安装后就会添加一个引擎。可以自定义的内容不少。<del>虽然声音不如谷歌娘好听。</del></p>
<h2 id="小爱-TTS"><a href="#小爱-TTS" class="headerlink" title="小爱 TTS"></a>小爱 TTS</h2><p>似乎只有在小米应用商店有下载：<a href="http://app.mi.com/details?id=com.xiaomi.mibrain.speech">http://app.mi.com/details?id=com.xiaomi.mibrain.speech</a></p>
<p>没有试过，但应用信息</p>
<blockquote>
<p>软件大小:20.86 M 版本号：1.1.1 更新时间：2018-08-02</p>
</blockquote>
<p>怕是不靠谱。</p>
<h2 id="还有呢？"><a href="#还有呢？" class="headerlink" title="还有呢？"></a>还有呢？</h2><p>信息太少了，一个能打的都找不到了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>更新，还是不更新，这是个问题</title>
    <url>/2022/05/25/update-or-not/</url>
    <content><![CDATA[<p>项目依赖想升不敢升，升了怕有坑，到底怎么整？</p>
<span id="more"></span>

<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>依赖 == 第三方库 == Library ≈≈ 某个Github项目</p>
<h2 id="如果东西没坏，就别修理它"><a href="#如果东西没坏，就别修理它" class="headerlink" title="如果东西没坏，就别修理它"></a>如果东西没坏，就别修理它</h2><p>升级依赖最糟糕的体验就是，本来没问题，升级升出了问题。</p>
<p>所以如果没有“想升级”之外更充分的理由，尽量别升级依赖。要升级<strong>等最少几个月再升级</strong>。</p>
<h2 id="依赖的源头"><a href="#依赖的源头" class="headerlink" title="依赖的源头"></a>依赖的源头</h2><p><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS, Keep it simple, stupid</a></p>
<p>从源头上来讲，要<strong>尽量减少使用的依赖</strong>。</p>
<p>一些对应用架构影响很大的依赖，比如一些MVI框架、复杂的UI嵌套实现等，一定要<strong>慎重考虑依赖的必要性</strong>，不然未来积重难返。</p>
<p>还有一些专用的、不怎么更新的依赖，要么一个版本用到老，要么拷贝到项目中。</p>
<h2 id="依赖的选择"><a href="#依赖的选择" class="headerlink" title="依赖的选择"></a>依赖的选择</h2><p>即使是一些作者积极维护、社区反馈热烈、代码质量很高的依赖，也会偶尔出现有坑的版本。更别提那些无人问津、一两个版本就杳无音信的依赖了。在选择前一定要评估<strong>评估依赖的维护状态</strong>。</p>
<p>针对一些闭源依赖，有新版本时一定要等几个月再尝试。</p>
<h2 id="依赖的管理"><a href="#依赖的管理" class="headerlink" title="依赖的管理"></a>依赖的管理</h2><p>个人用<a href="https://github.com/ben-manes/gradle-versions-plugin">ben-manes/gradle-versions-plugin</a>来检测需要升级的依赖，和<a href="https://github.com/dropbox/dependency-guard">dropbox/dependency-guard</a>来保证升级后的依赖版本（排查出依赖的依赖的升级）。</p>
<h2 id="依赖的更新"><a href="#依赖的更新" class="headerlink" title="依赖的更新"></a>依赖的更新</h2><p>有新版本时一定要等一两个月再尝试，无论大小。</p>
<h3 id="小更新"><a href="#小更新" class="headerlink" title="小更新"></a>小更新</h3><p>大部分依赖更新只需修改版本号，这样在发现问题回退版本时很容易。</p>
<h3 id="大更新"><a href="#大更新" class="headerlink" title="大更新"></a>大更新</h3><p>对于有着Breaking Changes或需要大幅修改项目库的依赖更新，要特别小心。<strong>在升级前一定要规划好来避免意外</strong>，比如专门开一个Git Branch、进行专门的测试等，以免升级时发现太复杂而放弃，或升级后发现旧版本更适合自己。</p>
<p>虽然一些依赖的大版本更新有着兼容，但也要小心。比如Paging3虽然兼容旧版API，但行为却有些许变化。</p>
<h3 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h3><p>因为会进行详尽的测试，这里当然要使用<strong>最新稳定版</strong>的依赖。</p>
<h3 id="老项目"><a href="#老项目" class="headerlink" title="老项目"></a>老项目</h3><p>为了项目稳定，尽量不升级依赖，或者只升级那些确定很稳定的依赖。</p>
<h2 id="其他的更新"><a href="#其他的更新" class="headerlink" title="其他的更新"></a>其他的更新</h2><p>印象最深刻的要属某次升级了某个开源应用，结果在我的设备上有Bug。作者修了一个月，但这期间等不及只好删掉应用装旧版本，数据全没啦！</p>
<p>教训就是，如果某次更新是无法回退的，且更新失败的代价是难以接受的，那么<strong>如果它没坏，就别修理它</strong>！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>个人常用的视频下载及处理命令整理</title>
    <url>/2023/11/23/youtube-dl-commands/</url>
    <content><![CDATA[<p>RT</p>
<span id="more"></span>

<h2 id="下载最佳视频-音频"><a href="#下载最佳视频-音频" class="headerlink" title="下载最佳视频+音频"></a>下载最佳视频+音频</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yt-dlp -S ext</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/yt-dlp/yt-dlp/issues/3398">https://github.com/yt-dlp/yt-dlp/issues/3398</a></p>
<h2 id="合成视频加音频"><a href="#合成视频加音频" class="headerlink" title="合成视频加音频"></a>合成视频加音频</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yt-dlp -F</span><br><span class="line">yt-dlp -f 641+140 </span><br></pre></td></tr></table></figure>

<p><a href="https://www.reddit.com/r/youtubedl/comments/qfsuxu/ytdlp_download_and_merge_multiple_format/">https://www.reddit.com/r/youtubedl/comments/qfsuxu/ytdlp_download_and_merge_multiple_format/</a></p>
<h2 id="裁剪音频"><a href="#裁剪音频" class="headerlink" title="裁剪音频"></a>裁剪音频</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -ss 1:00 -to 2:00 -i input.mp3 output.mp3</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/46508055/using-ffmpeg-to-cut-audio-from-to-position">https://stackoverflow.com/questions/46508055/using-ffmpeg-to-cut-audio-from-to-position</a></p>
<h2 id="下载视频的音频"><a href="#下载视频的音频" class="headerlink" title="下载视频的音频"></a>下载视频的音频</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yt-dlp --extract-audio --audio-format mp3 </span><br></pre></td></tr></table></figure>

<p><a href="https://askubuntu.com/a/178991">https://askubuntu.com/a/178991</a></p>
<h2 id="下载视频列表的音频"><a href="#下载视频列表的音频" class="headerlink" title="下载视频列表的音频"></a>下载视频列表的音频</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yt-dlp --extract-audio --audio-format mp3 -o <span class="string">&quot;%(title)s.%(ext)s&quot;</span> </span><br></pre></td></tr></table></figure>

<p><a href="https://askubuntu.com/a/564571">https://askubuntu.com/a/564571</a></p>
<h2 id="转换视频文件夹为音频文件夹"><a href="#转换视频文件夹为音频文件夹" class="headerlink" title="转换视频文件夹为音频文件夹"></a>转换视频文件夹为音频文件夹</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> %i <span class="keyword">in</span> (*.mp4) <span class="keyword">do</span> ffmpeg -i &quot;%i&quot; &quot;%~ni.mp3&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/a/56244203/5507158">https://stackoverflow.com/a/56244203/5507158</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>计时机器开发日志</title>
    <url>/2017/12/10/timer-devLog/</url>
    <content><![CDATA[<p><a href="https://play.google.com/store/apps/details?id=io.github.deweyreed.timer.google" target="_blank">Google Play Store</a> or <a href="https://www.coolapk.com/apk/177033" target="_blank">在酷安下载APK</a></p>
<span id="more"></span>

<h2 id="2021年10月19日"><a href="#2021年10月19日" class="headerlink" title="2021年10月19日"></a>2021年10月19日</h2><p>应用开源了 <a href="https://github.com/timer-machine/timer-machine-android">https://github.com/timer-machine/timer-machine-android</a></p>
<h2 id="2021年9月12日"><a href="#2021年9月12日" class="headerlink" title="2021年9月12日"></a>2021年9月12日</h2><p>下一版本将会是6.0：</p>
<ul>
<li>增加了一些新功能、新提醒方式、新设置等。</li>
<li>应用将不再支持Android 5，最低支持将会是Android 6。</li>
<li>出于缩小版本差别的考虑，移除了国内版本的开发日志和赞赏选项。</li>
<li>出于Google Play付款的一些问题，应用内购将对未购买用户关闭。已购买内容不受影响。</li>
</ul>
<p>最近也在进行一些开源的准备。具体开源时间应该在会在6.0发布之后，今年底到明年初。</p>
<p>同时，本开发日志也就不更新了啦，以后的问题和规划就放到Github Issues区。</p>
<h2 id="2021年8月22日"><a href="#2021年8月22日" class="headerlink" title="2021年8月22日"></a>2021年8月22日</h2><p>开源的意外出现了！因为<del>懒</del>工作量太大了，还是慢慢来吧。</p>
<h2 id="2021年8月10日"><a href="#2021年8月10日" class="headerlink" title="2021年8月10日"></a>2021年8月10日</h2><p><del>因为遇到了种种困难，我正在考虑开源本应用。不出意外的话，年底前开源。</del></p>
<h2 id="2021年7月8日"><a href="#2021年7月8日" class="headerlink" title="2021年7月8日"></a>2021年7月8日</h2><p>5.7.0的Google Play测试版已发。正如之前所提，现在的更新内容都算比较细枝末节。</p>
<p>Jetpack Compose快要出了，因此现在积压的各种界面相关的修改和优化都变成了“等Jetpack Compose出了后，再重写吧”。</p>
<h2 id="2021年4月24日"><a href="#2021年4月24日" class="headerlink" title="2021年4月24日"></a>2021年4月24日</h2><p>一直以来都在酷安上回复评论，但最近酷安的开屏广告越来越烦，所以懒得开酷安了。有需求的各位请善用应用内的“帮助与反馈”-“反馈”来发邮件联系。</p>
<h2 id="2021年4月18日"><a href="#2021年4月18日" class="headerlink" title="2021年4月18日"></a>2021年4月18日</h2><p>因为Android上的闹钟机制（计划任务所依赖的接口）实在不靠谱，在不同厂商的系统上有的能有、有的不能用，而且Android 12又得继续和系统API斗智斗勇，因此暂时不打算为计划任务增加新功能，只进行Bug修复。</p>
<h2 id="2021年3月16日"><a href="#2021年3月16日" class="headerlink" title="2021年3月16日"></a>2021年3月16日</h2><p>从前段时间Flutter 2.0发布开始，由于馋Flutter不仅覆盖移动端，还是覆盖Web和桌面端，所以最近一直都看一些Flutter的内容。感觉就是，我要转方向了。。</p>
<p>虽然缝合怪Dart难写又难用、各平台特性难以利用、配套工具少得可怜、继承了Google代码的拆东墙坏西墙的特性等等，Flutter还是不错的。</p>
<h2 id="2021年2月8日"><a href="#2021年2月8日" class="headerlink" title="2021年2月8日"></a>2021年2月8日</h2><p>各位！突然发现这个项目的代码成屎山了！上一次遇到类似的情况，我决定另起炉灶，于是有了计时机器。不过这次，我打算慢慢优化，所以接下来的更新虽然代码改了不少，但日志会乏善可陈。</p>
<h2 id="2021年2月3日"><a href="#2021年2月3日" class="headerlink" title="2021年2月3日"></a>2021年2月3日</h2><p>今年的大年三十没有新版本了。要说可以增加或优化的地方，有很多，但我决定细水长流慢慢来。另外，我也在计划一些其他的项目。</p>
<h2 id="2020年11月30日"><a href="#2020年11月30日" class="headerlink" title="2020年11月30日"></a>2020年11月30日</h2><p>5.2已发。迁移到了Firebase，统计似乎可以正常用，崩溃似乎偶尔可以用。而今天才发现AppCenter十一月初活了过来，或许未来可以混用。</p>
<p>想要加的功能还很多，一步一步来吧。</p>
<h2 id="2020年10月31日"><a href="#2020年10月31日" class="headerlink" title="2020年10月31日"></a>2020年10月31日</h2><p>5.0前几天已发，几天下来一切正常。应用的大更新告一段落。</p>
<p>5.1将会更新：可互动的使用教程、更详细的白名单指南。再之后的更新就是一些小修小补了。</p>
<p>如果AppCenter在年底前无法恢复正常，我将会在应用中统一使用Firebase，因为虽然Firebase的主服务被屏蔽，但开发者圈子中一直有它的统计和崩溃服务还能用的流言，索性死马当活马医了。</p>
<h2 id="2020年10月16日"><a href="#2020年10月16日" class="headerlink" title="2020年10月16日"></a>2020年10月16日</h2><p>下个版本是5.0，主要是计时器合集（就是之前提到的文件夹）功能。基本已完成，接下来就是测试，各种测试了。</p>
<p>未来的5.1的计划是换一套新的使用教程，现在的还是不够简单明了；在订阅计划中增加一些无关痛痒的小功能。</p>
<h2 id="2020年10月7日"><a href="#2020年10月7日" class="headerlink" title="2020年10月7日"></a>2020年10月7日</h2><p>文件夹功能比预想中快了很多，就作为十一月的更新吧。</p>
<h2 id="2020年9月27日"><a href="#2020年9月27日" class="headerlink" title="2020年9月27日"></a>2020年9月27日</h2><p>我有三点要发表：</p>
<h3 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h3><p>虽然Android 11已经出了，但我决定过段时间，到年底或明年年初，等待配套的AppCompat稳定了再适配，或者计时机器在11上出了问题再适配也不晚，吧。</p>
<h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p>新版本加了一些小功能，预计十一期间可以放出。之后就要正式开始文件夹功能了。</p>
<h3 id="国内版统计问题"><a href="#国内版统计问题" class="headerlink" title="国内版统计问题"></a>国内版统计问题</h3><p>计时机器在Fabric被Google Firebase收购后，出于Firebase可能国内连不上的缘故，就切换到微软的AppCenter进行崩溃统计，可是最近发现，AppCenter最近在国内也无法访问了。如果这个情况无法得到解决的话，计时机器的国内版可能要裸奔了，这样我将无法看到并解决任何国内版的应用问题。</p>
<p>国内的替代品？我能找到的都是流氓服务，相比之下宁愿裸奔。</p>
<h2 id="2020年9月7日"><a href="#2020年9月7日" class="headerlink" title="2020年9月7日"></a>2020年9月7日</h2><p><a href="https://github.com/DeweyReed/site/blob/master/source/_posts/timer-cloud-backup.md">关于计时机器在Google Play渠道引入订阅制云备份的决定</a></p>
<h2 id="2020年8月27日"><a href="#2020年8月27日" class="headerlink" title="2020年8月27日"></a>2020年8月27日</h2><p>云备份一直在测试，各种小错误不断。</p>
<p>另外，文件夹功能已经在做了，这里是<del>仅有的一张</del>设计图：</p>
<img src="/2017/12/10/timer-devLog/timer_folder.png" class="" title="[timer_folder.png](.&#x2F;timer-devLog&#x2F;timer_folder.png)">

<h2 id="2020年7月27日"><a href="#2020年7月27日" class="headerlink" title="2020年7月27日"></a>2020年7月27日</h2><p>应用数据云端备份和保存的功能终于完成了基础部分，都拖了一个月了，不过距离最终完成还需要一段时间。</p>
<p>除了代码，我还需要处理UI、文案、服务器等等。像是前段时间写了个小应用，代码半天搞定，图标却活活憋了三天，而且最后看起来也很一般。ㄟ( ▔, ▔ )ㄏ</p>
<h2 id="2020年7月24日"><a href="#2020年7月24日" class="headerlink" title="2020年7月24日"></a>2020年7月24日</h2><p>最近买了一个电子闹钟，因为根据我个人对Andorid的使用体验，加上几年来的Android开发经验，觉得Andorid手机里的闹钟实在难以被信任。听着电子闹钟发出的刺耳铃声，我再一次感受到了现代科技的伟大。</p>
<p>之所以提这个，是因为计时机器的计划任务使用了和手机闹钟同样的实现方式，所以在使用前自行测试，并做好不少系统上可能失效的准备。</p>
<h2 id="2020年7月1日"><a href="#2020年7月1日" class="headerlink" title="2020年7月1日"></a>2020年7月1日</h2><p>下一版本是小修小补的小版本，之后是云端备份，将会以Google Play渠道独占的每年订阅制的形式登场。</p>
<p>想了几天的UI都不满意，最后发现还是直接抄一个别人的好看(。﹏。)</p>
<h2 id="2020年6月14日"><a href="#2020年6月14日" class="headerlink" title="2020年6月14日"></a>2020年6月14日</h2><p>最近在做运行记录的图表显示，又是饼状图又是柱状图的，真好（复）看（杂）呀！</p>
<p>还要给数据处理写测试 (。_。)</p>
<h2 id="2020年5月17日"><a href="#2020年5月17日" class="headerlink" title="2020年5月17日"></a>2020年5月17日</h2><p>4.4.0将会加一些小功能，然后接下来计划是四个大工程：多语言、更详细的运行记录展示、数据云端备份、文件夹（包括排序）。因为文件夹是最繁琐的，所以放在最后。其他三个看心情和时间逐步推进。</p>
<h2 id="2020年5月16日"><a href="#2020年5月16日" class="headerlink" title="2020年5月16日"></a>2020年5月16日</h2><p>关于不做无限循环功能的决定：一个5分钟的步骤，循环1000次就有83小时，循环最大20亿（2147483647）。此外，如果循环不够还可以设置计时器结束后，启动自己，这样可以做到无限循环。而无限循环的功能不仅会榨干手机电量，还会导致运行记录无法被统计。综上所述，此功能暂不考虑。</p>
<h2 id="2020年5月12日"><a href="#2020年5月12日" class="headerlink" title="2020年5月12日"></a>2020年5月12日</h2><p>现在计划任务只能设置一次、一周的某几天或每隔几天。考虑到闹钟在短时间内一直触发会导致应用达到系统最大限制，进而导致闹钟失效，因此决定不添加每隔几小时和更小时间尺度的循环模式。考虑到复杂的循环需求数不胜数（设置在多个时刻运行、根据不同日子进行不同循环等），这里还是建议使用Tasker、Automate等应用。</p>
<h2 id="2020年5月7日"><a href="#2020年5月7日" class="headerlink" title="2020年5月7日"></a>2020年5月7日</h2><p>新版本一般会在Google Play的beta测试中放一个礼拜再放正式版出来，想尝新的可以点页面顶端的Google Play链接去参加。</p>
<h2 id="2020年4月21日"><a href="#2020年4月21日" class="headerlink" title="2020年4月21日"></a>2020年4月21日</h2><p>设计真是痛点。最近寻思着在编辑页面显示计时器总时间，死活整不出一个又漂亮又方便的方案😂</p>
<h2 id="2020年3月14日"><a href="#2020年3月14日" class="headerlink" title="2020年3月14日"></a>2020年3月14日</h2><p>嘿嘿！最近发现同为流程控制应用，Automate比Tasker好用且漂亮多了。它们都支持计时机器的插件。</p>
<h2 id="2020年1月19日"><a href="#2020年1月19日" class="headerlink" title="2020年1月19日"></a>2020年1月19日</h2><p><a href="https://github.com/DeweyReed/site/blob/master/source/_posts/timer-analytics-2020-1-19.md">截至到2020年1月19日三个月内计时机器的统计数据</a></p>
<h2 id="2020年1月18日"><a href="#2020年1月18日" class="headerlink" title="2020年1月18日"></a>2020年1月18日</h2><p>如果未来增加任何涉及联网的服务（比如同步等），打算都用Firebase，这意味着它们只会在Google Play渠道上线，而且绝大多数情况下需要魔法。Google Play和国内（酷安）两个渠道用的不同包名，所以可以同时装，数据迁移也只需要导出然后导入。两个渠道现在的不同仅在于包名和国内可以看到开发日志。</p>
<h2 id="2019年11月4日"><a href="#2019年11月4日" class="headerlink" title="2019年11月4日"></a>2019年11月4日</h2><p>自动夜间模式的确有问题，这个东西实现起来比我想象地要复杂。</p>
<h2 id="2019年11月2日"><a href="#2019年11月2日" class="headerlink" title="2019年11月2日"></a>2019年11月2日</h2><p>重新试了一下，自动夜间模式没问题呀。。那马上就发4.0.0。</p>
<h2 id="2019年10月28日"><a href="#2019年10月28日" class="headerlink" title="2019年10月28日"></a>2019年10月28日</h2><p>GooglePlay渠道上架了4.0.0的beta版，但自动夜间模式似乎有点问题，有时间了就修。</p>
<h2 id="2019年10月20日"><a href="#2019年10月20日" class="headerlink" title="2019年10月20日"></a>2019年10月20日</h2><p><del>我，再一次，误删掉了我自己的应用数据。。。</del>该做联网同步了。。</p>
<p>幸运的是，我在另一台测试上找到了遗留的备份文件，舒服了！</p>
<h2 id="2019年10月14日"><a href="#2019年10月14日" class="headerlink" title="2019年10月14日"></a>2019年10月14日</h2><p>下个版本4.0.0有一个长长长长长的测试列表，我这几天慢慢测一下。测完了先会丢到GooglePlay的beta测试里，之后才能正式上线。</p>
<h2 id="2019年9月11日"><a href="#2019年9月11日" class="headerlink" title="2019年9月11日"></a>2019年9月11日</h2><p>嘿嘿，摸了。。主要是Android 10的夜间主题不好弄，逻辑有点乱，容我整一整。</p>
<h2 id="2019年9月4日"><a href="#2019年9月4日" class="headerlink" title="2019年9月4日"></a>2019年9月4日</h2><p>既然Android 10出了，那就适配一下再出4.0.0吧。</p>
<h2 id="2019年8月31日"><a href="#2019年8月31日" class="headerlink" title="2019年8月31日"></a>2019年8月31日</h2><p>各位，新版本4.0.0近期发布，能赶得上Andorid 10的话就顺便适配一下。因为是取消专业版后的第一个版本,而且最近也在一直重构代码库，所以新功能不多。</p>
<p>另外，在<a href="#2018%E5%B9%B410%E6%9C%8821%E6%97%A5">2018年10月21日</a>曾提到的内存泄露中，其中一个泄露被证实是Android相关SDK的问题，于是我在汇报为这个问题贡献了一个百分百重现的Demo。然后前段时间收到一份邮件说要感谢我为AS 3.5质量提升做出的贡献，本来以为只是个<del>像捐款签个名之类</del>普通的感谢，但最近3.5发布后，在发布日志页，发现我的用户名出现在了仅有的几十个人之中。。受宠若惊 ====&gt; <a href="https://developer.android.com/studio/releases#3-5-community-contributors">https://developer.android.com/studio/releases#3-5-community-contributors</a> 名字是DeweyReed。</p>
<h2 id="2019年8月25日"><a href="#2019年8月25日" class="headerlink" title="2019年8月25日"></a>2019年8月25日</h2><p>XP用户要小心了，Xposed可能会导致应用的通知无法显示，进而导致崩溃。我现在还没有找到能从应用代码层面解决这个问题的办法。</p>
<p>另外，今天看了一下后台统计，发现朗读居然是最受欢迎的行为之一。本来以为TTS在国内系统都阉割地差不多了，但意外的有很多人用。</p>
<h2 id="2019年8月14日"><a href="#2019年8月14日" class="headerlink" title="2019年8月14日"></a>2019年8月14日</h2><p>下个版本是4.0.0，修修过去一个月成吨的的Bug、清理清理专业版的遗产、加几个小功能。更新时间未知，所以现在这里给大伙儿拜个早年啦!</p>
<h2 id="2019年7月18日"><a href="#2019年7月18日" class="headerlink" title="2019年7月18日"></a>2019年7月18日</h2><p>在计时器运行在后台播放音乐时，大伙儿遇到过音乐播放突然暂停的情况吗？正常情况下，计时器的各种行为会临时暂停音乐播放，行为结束后就恢复音乐播放，但最近遇到过好几次暂停后就不恢复、没有行为也会暂停的情况。如果各位也遇到了，请通过反馈/邮件告诉我（虽然我不知道该怎么解决。。。</p>
<h2 id="2019年7月12日"><a href="#2019年7月12日" class="headerlink" title="2019年7月12日"></a>2019年7月12日</h2><p>下次更新的时间说不好，哪天Bug积累的差不多了就更新。</p>
<p>今天看某up主的视频提到了一个名词：自嗨式开发。这不就是我一开始的更新思路吗233。但后来变好了一些，会根据用户的呼声和关键的体验进行更新，但还是很容易陷入自嗨的境地。</p>
<h2 id="2019年7月8日"><a href="#2019年7月8日" class="headerlink" title="2019年7月8日"></a>2019年7月8日</h2><p>服务器已经停掉了。都给我升级到最新版。</p>
<h2 id="2019年7月6日"><a href="#2019年7月6日" class="headerlink" title="2019年7月6日"></a>2019年7月6日</h2><p>在今晚放出的3.8.0，将取消专业版。具体的解释在这里：<a href="https://github.com/DeweyReed/site/blob/master/source/_posts/timer-death.md">https://github.com/DeweyReed/site/blob/master/source/_posts/timer-death.md</a></p>
<h2 id="2019年7月3日"><a href="#2019年7月3日" class="headerlink" title="2019年7月3日"></a>2019年7月3日</h2><p>这个美好的世界，每一天都充满了希望 (✿◕‿◕✿)</p>
<blockquote>
<p>很抱歉，您的应用未通过审核，原因是：</p>
<ol>
<li>详情如下：</li>
<li>应用设计较为粗糙，应用整体质量未达到小米应用商店收录标准，请丰富应用功能、提高应用质量后再上传</li>
</ol>
</blockquote>
<h2 id="2019年7月1日"><a href="#2019年7月1日" class="headerlink" title="2019年7月1日"></a>2019年7月1日</h2><p>最近新功能的开发先停一停，我需要：为Android Q适配、试着把应用上架到更多的应用商店、清理一下代码库为4.0做准备。</p>
<h2 id="2019年6月29日"><a href="#2019年6月29日" class="headerlink" title="2019年6月29日"></a>2019年6月29日</h2><p>如果不能用LeanCloud，那么其实AppCenter也可能被搞（更不用提它的Auth和Data还在Preview中），要不打游击？把现有的账号注册体系，换成激活码体系，然后打一枪换一个地方。头大。。</p>
<h2 id="2019年6月26日"><a href="#2019年6月26日" class="headerlink" title="2019年6月26日"></a>2019年6月26日</h2><p>LeanCloud又送来一个坏消息：未来需要一个备过案的域名作为API接口。这个就有点强人所难了，个人域名备案流程很复杂、很多样、很混乱、坑很深，这趟浑水我是真的不想趟。但各位的数据又不能丢掉，我需要想个办法。</p>
<h2 id="2019年6月22日"><a href="#2019年6月22日" class="headerlink" title="2019年6月22日"></a>2019年6月22日</h2><p>3.7.0发布了，有不少新功能，也修复了LeanCloud的问题。没法登陆、注册的现在必须更新了。</p>
<p>另外，刚刚手贱，在测试应用的时候，把我自己用的应用的数据给清了。。心疼我的运行记录啊！！！为此我要加一个数据自动备份的功能，不过这咋下手呢？</p>
<h2 id="2019年6月20日"><a href="#2019年6月20日" class="headerlink" title="2019年6月20日"></a>2019年6月20日</h2><p>今天的LeanCloud（各位的数据都保存的他们的服务器上）的域名出问题了，意味着登录、注册、激活等等都会停摆。只能等它们那边修了。根据<a href="https://blog.leancloud.cn/">它们的博客</a>似乎是被有关部门安排了。。</p>
<p>另外，GooglePlay的版本是接入了GooglePlay的支付渠道的，出现类似问题的几率低得多。不想受此类苦而且有本事的，可以迁移到那边。但注意两边账号是不共通的，所以专业版的问题给我发邮件就可以，不需要各位花第二份钱。</p>
<p>还有，我已经在思考把数据迁移到AppCenter了。</p>
<p>我会在明天或后天发一个新版本，按他们官网提供的临时解决方式的搞一搞。</p>
<h2 id="2019年6月15日"><a href="#2019年6月15日" class="headerlink" title="2019年6月15日"></a>2019年6月15日</h2><p>下个版本的新功能：微调时间的第二个主按钮，应用内的使用手册。</p>
<h2 id="2019年6月14日"><a href="#2019年6月14日" class="headerlink" title="2019年6月14日"></a>2019年6月14日</h2><p>新的测试功能，时间标签，基本能用。但无论是微调一下时间或者使用了挂起行为，都会让时间出问题，未来几个版本慢慢改。</p>
<h2 id="2019年6月12日"><a href="#2019年6月12日" class="headerlink" title="2019年6月12日"></a>2019年6月12日</h2><p>正在做六个可选的时间表盘：当前计时器已用时间、已用时间占计时器总时间的百分比、计时器总剩余时间、总剩余时间占计时器总时间的百分比、步骤的预计结束时间、计时器的预计结束时间。</p>
<p>这六个时间的计算都涉及到当前计时器的已用时间，但现在有个问题，我没法精确地算出它。。</p>
<h2 id="2019年6月10日"><a href="#2019年6月10日" class="headerlink" title="2019年6月10日"></a>2019年6月10日</h2><p>诸事不顺，回来更新了。</p>
<p>接下来的更新计划，首先要更新一下应用内的使用指导，因为还是有不少新用户不会用；添加一些计时器示例；显示当前计时器已用时间、剩余时间和预计完成时间（UI怎么设计是个问题，越来越挤了）。</p>
<h2 id="2019年6月4日"><a href="#2019年6月4日" class="headerlink" title="2019年6月4日"></a>2019年6月4日</h2><p>最近新功能加的有点多，失去了灵魂，要歇一歇，找找方向。</p>
<p>接下来的更新计划，首先是3.5.1修修Bug（但似乎没什么大问题），同时更新一下应用介绍、截图和使用指南。然后我要去学一些另外的东西，回来后再决定下一步吧。</p>
<h2 id="2019年5月31日"><a href="#2019年5月31日" class="headerlink" title="2019年5月31日"></a>2019年5月31日</h2><p>3.5.0会有了新的测试中的“通知”行为，也修了一些Bug。然后我要去学ASO了，所以下个版本是3.5.1，继续修Bug。</p>
<h2 id="2019年5月23日"><a href="#2019年5月23日" class="headerlink" title="2019年5月23日"></a>2019年5月23日</h2><p>过半和倒数新版本就发，因为步子有点大，放到了实验室里，需要到设置里手动打开。另外因为时间问题，通知下下个版本再加。3.4.0已经进入测试阶段了，预计周末能放出吧。</p>
<h2 id="2019年5月21日"><a href="#2019年5月21日" class="headerlink" title="2019年5月21日"></a>2019年5月21日</h2><p>倒计时需要+1s。。现在情况时，比如5秒钟的计时器，显示的内容是“4，3，2，1，0”，每个持续一秒。但这个样子并不合适，尤其是最后一个0，它虽然代表时间已经结束，但实际上在看到它后，再过一秒，计时器才算结束。所以想让它显示“5，4，3，2，1”，但这样又有个问题，看不到0了，因为最后一个1会在一秒后，直接跳转到下一步骤，比如直接从1跳到10。这可咋整啊。</p>
<h2 id="2019年5月17日"><a href="#2019年5月17日" class="headerlink" title="2019年5月17日"></a>2019年5月17日</h2><p>接下来的更新计划，三个新行为（名字还没想好）：半路（在步骤中途朗读内容）、倒数（在步骤最后数秒）、通知（在步骤开始时显示一个通知，试着适配手环）。另外，这么多行为，添加时就会显示一个很长的对话框，寻思着把它们分两列显示，但这我需要得从头写一个。还有，音乐选择器得更新了，一方面是因为它需要更多的功能，另一方面是为了适配Android Q。</p>
<h2 id="2019年5月6日"><a href="#2019年5月6日" class="headerlink" title="2019年5月6日"></a>2019年5月6日</h2><p>今天或明天放出一个版本修修Bug，然后就要肝<del>一年一度的画饼大会</del>Google IO啦。</p>
<h2 id="2019年5月3日"><a href="#2019年5月3日" class="headerlink" title="2019年5月3日"></a>2019年5月3日</h2><p>Fabric要凉凉后，我就迁移到了微软的AppCenter。当初的AppCenter只有一些简单的功能，崩溃、统计、推送、云端编译……今天的AppCenter-SDK-Android有了认证和数据。虽然文档还找不到，但是不是意味着AppCenter要进军Baas啦，这样的话，我在考虑将之前保存在LeanCloud的数据，迁移到AppCenter啦。</p>
<h2 id="2019年4月29日"><a href="#2019年4月29日" class="headerlink" title="2019年4月29日"></a>2019年4月29日</h2><p>3.3.0的Code Review结束啦，测试完就可以找小白鼠啦。另外新的使用手册和应用介绍也快完成了。</p>
<h2 id="2019年4月25日"><a href="#2019年4月25日" class="headerlink" title="2019年4月25日"></a>2019年4月25日</h2><p>3.3.0将有的内容：设置来电时是否暂停计时器的设置选项、运行记录将包含开启时间、更好的悬浮窗界面、修理Bug。因为最近在研究前端的内容，还要更新使用手册，估计下个礼拜才能发布。</p>
<h2 id="2019年4月24日"><a href="#2019年4月24日" class="headerlink" title="2019年4月24日"></a>2019年4月24日</h2><p>在Android O及以后的系统上，通过计划任务或Tasker停止计时器时，可能会出现程序未响应的问题。因为Android的规矩是，我要在启动服务后5秒后，必须显示一个通知，否则程序未响应。但是，既然是停止计时器，5秒内计时器已经都停止了，所以在5秒时服务已经关闭了，哪来的通知？结果就未响应了。这可咋整啊？</p>
<h2 id="2019年4月21日"><a href="#2019年4月21日" class="headerlink" title="2019年4月21日"></a>2019年4月21日</h2><p>花了一礼拜恶补了很多前端的知识。相比只有十年的Android，发展了几十年的前端可真是遍地开花。现在到了各种框架的阶段，看得我头疼。</p>
<h2 id="2019年4月15日"><a href="#2019年4月15日" class="headerlink" title="2019年4月15日"></a>2019年4月15日</h2><p>白名单呀白名单，至少给个“锁屏清理”的绿灯吧。要用Tasker的话，可能还需要个“被唤醒”的绿灯。不然计时器跑着跑着没响儿了，得多难受。<del>然后你也可以再给个差评，让我陪你一块儿难受。</del></p>
<p>3.2.0重做了底层链接计时器的逻辑，测试过程中一切顺利。<del>就看各位先更新的小白鼠的使用体验了。</del></p>
<h2 id="2019年4月13日"><a href="#2019年4月13日" class="headerlink" title="2019年4月13日"></a>2019年4月13日</h2><p>突然想加个Dropbox, Google Drive, OneDrive的云备份，这可是个大坑。</p>
<h2 id="2019年4月11日"><a href="#2019年4月11日" class="headerlink" title="2019年4月11日"></a>2019年4月11日</h2><p>3.2.0的新功能将会有：挂起行为可以正向计时，朗读行为可以自定义内容并可以朗读当前循环次数，嘟嘟行为的暂停其他背景音选项。有Bug的话，3.2.1将只会修修Bug。然后我又要岔出去学点新的东西了。</p>
<h2 id="2019年4月9日"><a href="#2019年4月9日" class="headerlink" title="2019年4月9日"></a>2019年4月9日</h2><p>Android在对话框里弹出个软键盘怎么就怎么难？</p>
<h2 id="2019年4月2日"><a href="#2019年4月2日" class="headerlink" title="2019年4月2日"></a>2019年4月2日</h2><p>为了支持正向计时和解决昨天提到的问题，现在要重做整个计时器链接的逻辑。初步定在3.2.0。</p>
<h2 id="2019年4月1日"><a href="#2019年4月1日" class="headerlink" title="2019年4月1日"></a>2019年4月1日</h2><p>嗯。。之前<a href="#2019%E5%B9%B43%E6%9C%8821%E6%97%A5">2019年3月21日</a>提到的问题，终于重现了一次。这个问题会造成两种崩溃，都是涉及运行多个计时器时，通过通知终止所有计时器（或许还有其他情况？），造成一些情况下应用崩溃。修起来比较棘手，只能从底层重构链接计时器的整个逻辑。找不到现成的轮子，只有自己来了。</p>
<h2 id="2019年3月31日"><a href="#2019年3月31日" class="headerlink" title="2019年3月31日"></a>2019年3月31日</h2><p>3.1.0会有两个专业版的功能：设置一个计时器结束后自动启动下一个的设置，Tasker支持。</p>
<h2 id="2019年3月27日"><a href="#2019年3月27日" class="headerlink" title="2019年3月27日"></a>2019年3月27日</h2><p>3.0.0 有个大Bug，<del>争取今天中午能发出安装包。暂时把酷安应用下架了避免没更新的各位更新。虽然好像找不到重新上架的按钮了。。。</del>有条件升级的都给我升级。</p>
<h2 id="2019年3月21日"><a href="#2019年3月21日" class="headerlink" title="2019年3月21日"></a>2019年3月21日</h2><p>看到几个莫名其妙、理论上不可能发生但的确发生了的崩溃，一直都没头绪。它是关于停止所有计时器的，反正停止所有计时器和直接崩溃的效果都差不多，我就先搜集一下相关信息，未来几个版本再想办法解决。</p>
<h2 id="2019年3月15日"><a href="#2019年3月15日" class="headerlink" title="2019年3月15日"></a>2019年3月15日</h2><p>一直狂按下一步，会有极小几率崩溃，原因不明，估计是在快速显示新步骤和隐藏旧步骤时，RecyclerView处理不过来了。<strong>因此才有的双击步骤序号快速跳转的功能呀</strong>。</p>
<h2 id="2019年3月14日"><a href="#2019年3月14日" class="headerlink" title="2019年3月14日"></a>2019年3月14日</h2><p>重构差不多了。清理清理就上马3.0，虽然并没有什么特别激动人心的新功能。新功能留到3.1吧。</p>
<h2 id="2019年3月13日"><a href="#2019年3月13日" class="headerlink" title="2019年3月13日"></a>2019年3月13日</h2><p>重构代码就跟捅了马蜂窝一样，这个比喻真形象。现在已经有了16个Module了。。</p>
<h2 id="2019年3月8日"><a href="#2019年3月8日" class="headerlink" title="2019年3月8日"></a>2019年3月8日</h2><p>问：为什么这个应用无论怎么改，UI都透露着一股贫穷和简陋？</p>
<h2 id="2019年2月13日"><a href="#2019年2月13日" class="headerlink" title="2019年2月13日"></a>2019年2月13日</h2><p>发现了一些Bug：在有任意对话框打开的情况下，旋转屏幕，很大几率崩溃。不过不急着修，大伙儿又不会没事儿转着手机玩。另外Android传数据是真的繁琐。</p>
<h2 id="2019年2月12日"><a href="#2019年2月12日" class="headerlink" title="2019年2月12日"></a>2019年2月12日</h2><p>APK逐渐膨胀快到4MB了，东西越加越多是这个样子的。</p>
<h2 id="2019年2月11日"><a href="#2019年2月11日" class="headerlink" title="2019年2月11日"></a>2019年2月11日</h2><p>2.1.0已经在测试了。之后还是规矩，清理清理代码，需要的话出个2.1.1修Bug。然后我要岔出去搞搞应用介绍、应用截图和造一些其他轮子。</p>
<h2 id="2019年2月9日"><a href="#2019年2月9日" class="headerlink" title="2019年2月9日"></a>2019年2月9日</h2><p>一个有意思的现象：开始/暂停按钮显示的是它要执行的动作（运行时显示暂停图标，暂停时显示运行图标），但锁定按钮显示的是当前状态（锁定时显示锁定图标，解锁时显示解锁图标）。</p>
<h2 id="2019年2月8日"><a href="#2019年2月8日" class="headerlink" title="2019年2月8日"></a>2019年2月8日</h2><ol>
<li><p>打算再加一个快速修改计时器步骤的功能就可以出2.1.0啦。</p>
</li>
<li><p>本来计划添加一个可以选99小时或更长时间的选择器的，但这种情况呀，最好还是手动设一个系统闹钟或一个计划任务，因为设置那么长的一个步骤会很费电。因此99小时选择器的计划延后。</p>
</li>
<li><p>很多手机在使用计划任务时，要想在手机重启后让计划任务继续生效，是需要在系统设置进行单独设置的。</p>
</li>
</ol>
<h2 id="2019年2月6日"><a href="#2019年2月6日" class="headerlink" title="2019年2月6日"></a>2019年2月6日</h2><p>我们已经尽力了.jpg</p>
<p>因为UI设计和大量数据的显示本来就不怎么配合，加上又不怎么会UI设计，结果只能注重实用性，而减小UI的权重。</p>
<h2 id="2019年2月4日"><a href="#2019年2月4日" class="headerlink" title="2019年2月4日"></a>2019年2月4日</h2><p>在Dribbble找了很多设计图，但只能说对UI优化有了个大概预想。不过在改完UI后，我估计还得优化一下内存，总感觉应用是不是吃得太多了？希望是错觉。</p>
<p>我决定今天争取发一个2.0.1修一下当前的Bug。</p>
<h2 id="2019年2月3日"><a href="#2019年2月3日" class="headerlink" title="2019年2月3日"></a>2019年2月3日</h2><p>接下来的计划：如果2.0.0有严重的Bug，就会有2.0.1来专门修理它们。如果没有，下个版本会是2.1.0，主要更新有美化UI和快速设置当前步骤和循环（居然现在才加这个功能），也会重做一下应用介绍和截图。</p>
<p>另外，激活专业版的各位记得把用户名附上呀，不能我只能等各位的邮件啦。下个版本给那几个字**<em>加粗放大</em>**。</p>
<h2 id="2019年2月1日"><a href="#2019年2月1日" class="headerlink" title="2019年2月1日"></a>2019年2月1日</h2><p>要什么beta版，再测一测就上正式版。大不了打补丁嘛。</p>
<p>已知Bug：</p>
<ol>
<li>运行N(N &gt; 1)个计时器，在其中一个嘟嘟时，每次嘟嘟音会响N次。。涉及到对嘟嘟音的重新设置，下个版本修复。</li>
</ol>
<h2 id="2019年1月24日"><a href="#2019年1月24日" class="headerlink" title="2019年1月24日"></a>2019年1月24日</h2><p>内容做的差不多了。接下来的任务是1. 测试。因为改动太大，需要把整个应用都舔一遍。2. 引用了两个还在alpha和beta的第三方库，担心不稳定造成崩溃。3. 组的UI显示还是不怎么满意，但不知道怎么改进。</p>
<h2 id="2019年1月18日"><a href="#2019年1月18日" class="headerlink" title="2019年1月18日"></a>2019年1月18日</h2><p>如果创建很多个计时器（3个及以上吧），都打开，然后点击总管通知的开始暂停，这时总管通知就更新不过来了，原因是Android限制了一个应用一秒内可以更新通知的次数（据说是10次）。而在开始暂停时，每个计时器的通知都得更新名称和按钮选项。这个问题理论上无法彻底解决。能缓解问题的方法是把一些计时器的通知显示关掉。。。</p>
<h2 id="2019年1月14日"><a href="#2019年1月14日" class="headerlink" title="2019年1月14日"></a>2019年1月14日</h2><p>2.0.0还差几个小feature需要做，UI也需要提升一下。但最后的测试估计会很费劲且费时。</p>
<p>但接下来的版本已经有畅想了。2.0.1将会修理Bug。2.1.0将会加三个新功能：不需要进入编辑界面就可以快速编辑的功能、计时器排序（这个还不知道怎么做）、设置毫秒级的步骤时长。此外还会努力优化一下UI。</p>
<h2 id="2019年1月12日"><a href="#2019年1月12日" class="headerlink" title="2019年1月12日"></a>2019年1月12日</h2><p>现在的步骤编辑布局，一大串儿行为，选择打开哪个。我寻思着可以改成，默认什么都没有，加个可以选择添加哪个行为的按钮。这个样子就干净多了。</p>
<p>发布前，我得写篇很详细的使用说明。</p>
<p>另外，放弃设计了，能跑起来就不错了。Keyline对齐就已经胜利了。</p>
<p>嗯。现在组的实现差不多完成了，该收拾收拾其他东西了。</p>
<h2 id="2019年1月11日"><a href="#2019年1月11日" class="headerlink" title="2019年1月11日"></a>2019年1月11日</h2><p>在编辑界面，加入组之后，拖拽就变得很复杂。尤其是把一个步骤拖进组里或拖出组外。为了省事，新版本里打算不做这个功能了。需要的可以通过删除+新建来实现调整步骤的效果。</p>
<h2 id="2019年1月9日"><a href="#2019年1月9日" class="headerlink" title="2019年1月9日"></a>2019年1月9日</h2><p>新的组里多了一个限制：一个计时器步骤大于了2万，或一个组里的步骤大于了10万，计时器运行界面的步骤显示可能会出现错误。如果有哪位超人不够的话，跟我说，我再改改。</p>
<h2 id="2019年1月6日"><a href="#2019年1月6日" class="headerlink" title="2019年1月6日"></a>2019年1月6日</h2><p>比预料的快但也更磨人。编辑界面凑活能用了，但是丑，很过分地丑。跑了一圈Dribbble也莫得灵感。</p>
<h2 id="2019年1月5日"><a href="#2019年1月5日" class="headerlink" title="2019年1月5日"></a>2019年1月5日</h2><p>我要放弃组中组的功能开发了。一方面因为这有点过于复杂，不仅仅是数据层面（如何保存一个可以在子树中循环的多叉树的状态？），还有界面层面（编辑时，组就需要一个单独页面；运行时，将会比文件树视图还要复杂）。</p>
<p>所以2.0.0的变动将会有:</p>
<ol>
<li>在现有四种步骤类型的基础上，新增一个“组”步骤类型。组里可以放多个步骤，并可以有自己的循环。但组里不能嵌套另外的组。</li>
<li>数据导入导出的格式升级为.tmd2，将不会兼容之前的版本。需要的可以在升级到2.0.0之后，重新导出一次数据。</li>
</ol>
<p>在2.0.1会有一些UI上的优化。</p>
<h2 id="2019年1月4日"><a href="#2019年1月4日" class="headerlink" title="2019年1月4日"></a>2019年1月4日</h2><p>数据层的工作完成了。比想象中的快了不少。接下来就是UI层。头疼，不知道怎么塞进新的“组”的概念。</p>
<h2 id="2018年12月31日"><a href="#2018年12月31日" class="headerlink" title="2018年12月31日"></a>2018年12月31日</h2><p>比想象中的复杂。现在的方法是把计时器的状态（在哪一步骤运行中）保存到一个整数里，是把计时器“捋平”后再记录。为了适应更复杂的结构，原来的方法就显得太臃肿了。现在得想个更好的办法，这可就不好弄了。有没有现成的轮子啊啊啊。</p>
<p>过了一会后</p>
<p>重做计时驱动层吧，现在计时器们也有跟Android一样的lifecycle啦。</p>
<h2 id="2018年12月30日"><a href="#2018年12月30日" class="headerlink" title="2018年12月30日"></a>2018年12月30日</h2><p>2.0.0在做了，主要任务就是一个特殊步骤：组。组有自己的名字和循环，组里也可以放步骤。</p>
<p>然后这玩意儿现在成了多叉树，这可就复杂了。。为了记录当前步骤，就要一个迭代遍历多叉树的操作，头大。</p>
<p>另外的问题是UI，我该怎么显示一个多叉树的步骤视图和它的编辑页面？初步构想是先不支持“组里组”的这种结构（这样复杂的任务可能分成两个计时器更好)，这样UI就可以简化为步骤+带标题的步骤。</p>
<h2 id="2018年12月25日"><a href="#2018年12月25日" class="headerlink" title="2018年12月25日"></a>2018年12月25日</h2><p>1.1.1差不多了，主要是修修补补。该准备2.0.0了，虽然连规划还没开始。</p>
<h2 id="2018年12月23日"><a href="#2018年12月23日" class="headerlink" title="2018年12月23日"></a>2018年12月23日</h2><p>做好了，但是好丑啊啊啊。。等未来的版本再用吧。</p>
<h2 id="2018年12月20日"><a href="#2018年12月20日" class="headerlink" title="2018年12月20日"></a>2018年12月20日</h2><p>打算重做一下运行时所有步骤的那个控件，为了解决前面提到的Bug，应该做起来比较简单吧。。</p>
<h2 id="2018年12月15日"><a href="#2018年12月15日" class="headerlink" title="2018年12月15日"></a>2018年12月15日</h2><p>APK爆炸了。。最大的到了5.1MB。不行，我得想想办法，争取限制在4MB里。之所以是4MB，估计和当时Instnat App最大只能4MB有关，虽然现在10MB了，但心里的那条线已经画好了。</p>
<p>过了一会</p>
<p>啊，回炉重做吧。</p>
<h2 id="2018年12月14日"><a href="#2018年12月14日" class="headerlink" title="2018年12月14日"></a>2018年12月14日</h2><p>发现一个Bug：如果创建很多步骤，7、8个吧，然后疯狂点下一步，很快就会崩溃。暂时解决不了，可能的话会在1.1.1里重写一下控件。</p>
<h2 id="2018年12月13日"><a href="#2018年12月13日" class="headerlink" title="2018年12月13日"></a>2018年12月13日</h2><p>1.1.0，有一些新功能和一个高级付费版，来维持开发。</p>
<p>1.1.1，修理Bug，引入Material Design 2。</p>
<p>2.0.0，引入组的概念，可以把步骤放到组里，组有单独的名字和循环。</p>
<h2 id="2018年12月2日"><a href="#2018年12月2日" class="headerlink" title="2018年12月2日"></a>2018年12月2日</h2><p>十五分钟内的多个计划任务就会失效，这也就是为什么奥利奥上循环计时器不能用的原因。</p>
<p>1.0.6还没出，我已经在畅想2.0.0怎么做了。。</p>
<h2 id="2018年11月29日"><a href="#2018年11月29日" class="headerlink" title="2018年11月29日"></a>2018年11月29日</h2><p>最近其实加了不少新功能，但在新版本里其实都把入口隐藏了，因为最近一直在加东西，有点迷茫。</p>
<h2 id="2018年11月21日"><a href="#2018年11月21日" class="headerlink" title="2018年11月21日"></a>2018年11月21日</h2><p>有个Bug：加1分钟后，计时条会失效。因为加1分钟是临时的，所以计时条找不到当前步骤的总时间。那这可怎么解决哩？</p>
<h2 id="2018年11月20日"><a href="#2018年11月20日" class="headerlink" title="2018年11月20日"></a>2018年11月20日</h2><p>用了evernote的android-job来实现计划任务了，虽然底层都差不多，但总比自己造轮子好。不过最近我的手机闹钟都不响了，其他第三方应用设置的闹钟靠谱才怪哩。</p>
<p>这次的发布不怎么顺利啊，发现了不少Bug。</p>
<h2 id="2018年11月15日"><a href="#2018年11月15日" class="headerlink" title="2018年11月15日"></a>2018年11月15日</h2><p>打算加一个每秒播放提示音的步骤行为，但好肝啊。</p>
<h2 id="2018年11月12日"><a href="#2018年11月12日" class="headerlink" title="2018年11月12日"></a>2018年11月12日</h2><p>开发者吃狗粮体验：别用自己喜欢的音乐作为步骤音乐，会把它听毁掉的。可以考虑用手机自带的提示音或者朗读步骤名称。</p>
<h2 id="2018年11月11日"><a href="#2018年11月11日" class="headerlink" title="2018年11月11日"></a>2018年11月11日</h2><p>代码难产啦。倒不是没有要做的东西，相反，要做的太多了。</p>
<p>过了一会</p>
<p>有位哥们儿反馈了一个默认铃声无法停止循环的Bug，<del>试了一下，没什么头绪，好像是Android的Bug吧，我再试一试。</del> 真凶抓到了，<code>.ogg</code>自带无限循环，换成<code>.mp3</code>就好啦。</p>
<h2 id="2018年11月7日"><a href="#2018年11月7日" class="headerlink" title="2018年11月7日"></a>2018年11月7日</h2><p>如果一切顺利的话，跑完测试就可以放出1.0.4了。新版本主要对UI进行了不少优化，还为下一步做了不少铺垫。</p>
<p>什么？APK大小破3MB了？</p>
<h2 id="2018年10月31日"><a href="#2018年10月31日" class="headerlink" title="2018年10月31日"></a>2018年10月31日</h2><p>代码又难产了。。。</p>
<p>发现居然循环计时器在有的奥利奥设备上居然能运行，这究竟是手机厂商的宽容大度还是谷歌的过于严格？</p>
<h2 id="2018年10月28日"><a href="#2018年10月28日" class="headerlink" title="2018年10月28日"></a>2018年10月28日</h2><p>接下来要做的工程都很复杂呀。。</p>
<p>过了一会。</p>
<p>什么？支持平板？谷歌<del>爸爸</del>的平板都停产绝版了。。如果以后闲到无事可做，我可能会考虑适配一下平板。。</p>
<h2 id="2018年10月25日"><a href="#2018年10月25日" class="headerlink" title="2018年10月25日"></a>2018年10月25日</h2><p>1.0.3丢去测试了，不出大问题今天出。修改了计划任务的实现，不知道会不会影响到正常使用。。这之后又要重构了，这次重构UI，新功能的添加搁置一段时间。</p>
<h2 id="2018年10月23日"><a href="#2018年10月23日" class="headerlink" title="2018年10月23日"></a>2018年10月23日</h2><p>我估计还得再来几天，因为现在IDE都坏掉了。</p>
<h2 id="2018年10月22日"><a href="#2018年10月22日" class="headerlink" title="2018年10月22日"></a>2018年10月22日</h2><p>修了一整天内存泄露。。</p>
<h2 id="2018年10月21日"><a href="#2018年10月21日" class="headerlink" title="2018年10月21日"></a>2018年10月21日</h2><p>研究了一会OCR，回来鼓捣计时机器啦。估计这个月能更新一下下。</p>
<p>过了一会儿：</p>
<p>以前LeakCanary一直在报告有内存泄漏，但因为之前很多次都是Android系统的泄露，所以一直都忽视了。今天稍微用了一会发现泄露的通知怎么挤爆了。。。我才发现应用的内存泄露有点严重，现在正在修理中。。都怪Android系统。</p>
<h2 id="2018年10月16日"><a href="#2018年10月16日" class="headerlink" title="2018年10月16日"></a>2018年10月16日</h2><p>最近在造一个动态主题的轮子，真正地在造轮子。。</p>
<h2 id="2018年10月7日"><a href="#2018年10月7日" class="headerlink" title="2018年10月7日"></a>2018年10月7日</h2><p>有用户提醒我PIP没做，因为PIP比悬浮窗简单，就顺手做了一下，却发现在暗色主题下，显示不出来？？？会不会又发现了Android的坑啦。</p>
<h2 id="2018年10月3日"><a href="#2018年10月3日" class="headerlink" title="2018年10月3日"></a>2018年10月3日</h2><p>Bug越测试越多可还行。整个应用败絮其中，只能缝缝补补才能过日子的样子。</p>
<h2 id="2018年10月2日"><a href="#2018年10月2日" class="headerlink" title="2018年10月2日"></a>2018年10月2日</h2><p>加了一波小功能，测试过了就放出1.0.2，然后我要去试着写一个悬浮窗 + OCR的应用原型，其中用到的悬浮窗也算为计时机器的下一步打基础了。</p>
<h2 id="2018年10月1日"><a href="#2018年10月1日" class="headerlink" title="2018年10月1日"></a>2018年10月1日</h2><p>有些设置该放到工具箱里呢，还是设置里呢？我要想一想。</p>
<h2 id="2018年9月28日"><a href="#2018年9月28日" class="headerlink" title="2018年9月28日"></a>2018年9月28日</h2><p>之前提过循环计时器是系统闹钟机制，计时机器是前台服务机制，所以一直想着把闹钟机制的功能移植到计时机器中。但现在突然想到闹钟机制只能在棒棒糖、棉花糖和牛轧糖上运行啊，对奥利奥及以后根本不起作用，同时新设备也越来越多。这么看来，闹钟机制的添加冒着支持旧设备 + 可能失效的危险，这么想就懒得添加闹钟机制了。</p>
<p>什么，循环计时器不灵了？可以用计时机器呀。什么，怕前台服务费电？可以用循环计时器呀。什么，循环计时器功能不够多？可以用计时机器呀。</p>
<p>不过，还没人跟我抱怨过应用费电的问题，估计是杞人忧天了。</p>
<h2 id="2018年9月25日"><a href="#2018年9月25日" class="headerlink" title="2018年9月25日"></a>2018年9月25日</h2><p>虽然在主题、导入导出上遇到一些问题，但成功解决了。可喜可贺。</p>
<p>接下来？清理一下代码库，向AndroidX迁移，然后可能要考虑悬浮窗和付费功能了。付费功能不好做啊。</p>
<h2 id="2018年9月18日"><a href="#2018年9月18日" class="headerlink" title="2018年9月18日"></a>2018年9月18日</h2><p>在思考数据导出的问题，文件格式叫TimeR Machine Data，后缀可以简称.tmd。</p>
<h2 id="2018年9月14日"><a href="#2018年9月14日" class="headerlink" title="2018年9月14日"></a>2018年9月14日</h2><p>主题搞定，造了一个大轮子，下一步先收拾收拾、整理整理任务，定一些计划。</p>
<h2 id="2018年9月5日"><a href="#2018年9月5日" class="headerlink" title="2018年9月5日"></a>2018年9月5日</h2><p>1.0.0差不多了，处理处理文案之类的工作就要放粗来啦。</p>
<h2 id="2018年8月30日"><a href="#2018年8月30日" class="headerlink" title="2018年8月30日"></a>2018年8月30日</h2><p>最近在造一些轮子，完了之后就着手给计时机器修理漏洞、添加使用指导之类的东西，准备1.0。</p>
<p>1.0之后打算先全面支持一下Android派，然后再想办法增加新功能、新界面和更多的自定义属性。</p>
<h2 id="2018年8月18日"><a href="#2018年8月18日" class="headerlink" title="2018年8月18日"></a>2018年8月18日</h2><p>0.3.3发布了，对通知和多计时器进行了大量改动，可能出现不少问题，也会在最近陆续修复。漏洞修光光后，就发布到正式版1.0.0，然后又是新增更多功能。</p>
<h2 id="2018年8月17日"><a href="#2018年8月17日" class="headerlink" title="2018年8月17日"></a>2018年8月17日</h2><p>在思考要不要加些付费功能，Google那边就很简单。国内的话，考虑到用户量不多，最可行的还是依赖一个后端存储信息 + 手动确认。</p>
<h2 id="2018年8月13日"><a href="#2018年8月13日" class="headerlink" title="2018年8月13日"></a>2018年8月13日</h2><p>commit过千了。</p>
<p>为了庆祝，我想实现一个功能，首先在任何运行的时候，至少有一个通知。然后当有一个计时器时，只显示一个通知；两个及以上时，显示多个计时通知 + 一个总管通知。这个逻辑 + 每个计时器都有可能不显示通知 + 任何计时器都会在任何时候开始和结束，就诞生了一个炒鸡复杂的管理机制。这个复杂的通知管理，有五个状态，任何计时器开始都会让状态切换。挖了一个好大的坑呀。(ノへ￣、)</p>
<h2 id="2018年8月12日"><a href="#2018年8月12日" class="headerlink" title="2018年8月12日"></a>2018年8月12日</h2><p>最近代码洁癖犯了，处理了很多第三方Library。要么重写，要么优化。</p>
<h2 id="2018年7月30日"><a href="#2018年7月30日" class="headerlink" title="2018年7月30日"></a>2018年7月30日</h2><p>最近想用一个方便的RecyclerView，找遍了Arsenal和Github都找不到一个顺手的。顺便试了一下Flutter，的确很舒服，虽说Dart不熟练，但开发过程挺舒服，只可惜没什么想写的应用。</p>
<h2 id="2018年7月21日"><a href="#2018年7月21日" class="headerlink" title="2018年7月21日"></a>2018年7月21日</h2><p>在确保现有功能不出问题的前提下，就要发布1.0.0了，然后又是一大波新功能的添加。</p>
<h2 id="2018年7月11日"><a href="#2018年7月11日" class="headerlink" title="2018年7月11日"></a>2018年7月11日</h2><p>加了几个新功能。我估计新功能稳定后就可以发布1.0.0版本了，毕竟Beta也半年多了。</p>
<h2 id="2018年7月2日"><a href="#2018年7月2日" class="headerlink" title="2018年7月2日"></a>2018年7月2日</h2><p>0.3.1修复了一个在一些设备上无法选择音乐的Bug。但在Moto G4 Play上会出现Native Crash，莫名其妙，能不能解决随缘吧。</p>
<h2 id="2018年6月29日"><a href="#2018年6月29日" class="headerlink" title="2018年6月29日"></a>2018年6月29日</h2><p>正在准备0.3.0的发布，新内容不多，但算是给新内容的添加打好了基础。</p>
<p>但现在有很多很多Bug得修理。</p>
<h2 id="2018年6月28日"><a href="#2018年6月28日" class="headerlink" title="2018年6月28日"></a>2018年6月28日</h2><p>考虑关闭通知时间提醒的功能，在手机上更新通知并算不上多么好的体验和实践。</p>
<h2 id="2018年5月23日"><a href="#2018年5月23日" class="headerlink" title="2018年5月23日"></a>2018年5月23日</h2><p>重构基本完成了。等加点新功能在放出新版本吧，打算撸个好看点儿的UI。</p>
<h2 id="2018年5月6日"><a href="#2018年5月6日" class="headerlink" title="2018年5月6日"></a>2018年5月6日</h2><p>最近在重构整个应用，导致Bug攒了一大堆。。</p>
<h2 id="2018年4月24日"><a href="#2018年4月24日" class="headerlink" title="2018年4月24日"></a>2018年4月24日</h2><p>手痒又想重构了。重构==新功能暂时加不了，旧功能各种出问题+以后会爽到。</p>
<h2 id="2018年4月13日"><a href="#2018年4月13日" class="headerlink" title="2018年4月13日"></a>2018年4月13日</h2><p>2017年12月18日 那天的日志中提到的问题又重现了。应用被冻结，不是被杀，而是被执行暂停。只有在屏幕再次打开时，应用才会继续执行下一步。</p>
<p>这是一个跟国内厂商斗智斗勇的故事。计时器既然需要精确地计时，就要让CPU一直运行，这一点用WakeLock很容易解决。但这样阿猫阿狗都可以让CPU一直运行，不久流氓应用遍地了吗？于是各厂商就增加了应用冻结（或其他名字）的功能，如果应用让CPU一直运行，但又没有做什么实质性的工作，就会冻结它，不是杀了它，是暂停它。这样屏幕一打开，应用又可以继续工作了。</p>
<p>把应用添加到各个厂商手机中的白名单、保护应用、后台执行之类设置中，可以一定程度解决问题。至少我在测试中这么做，清空后台后，原本3分钟就被冻结的应用，现在3分钟、5分钟、10分钟也没问题了。</p>
<p>我在思考通过一些机制让应用正常工作。</p>
<h2 id="2018年4月12日"><a href="#2018年4月12日" class="headerlink" title="2018年4月12日"></a>2018年4月12日</h2><p>本来打算今天发布0.2.0了，但决定给计时器执行实现加一些测试，过几天再发布吧。</p>
<h2 id="2018年4月6日"><a href="#2018年4月6日" class="headerlink" title="2018年4月6日"></a>2018年4月6日</h2><p>重构数据层。下个版本可能要丢数据了。。。因为忘了给Model加Proguard。。</p>
<h2 id="2018年4月4日"><a href="#2018年4月4日" class="headerlink" title="2018年4月4日"></a>2018年4月4日</h2><p>又要开始爆肝更新了。任务出奇的多啊，数据层也打算重构一下。Beta测试放飞自我，更新之后丢一些数据也是很正常的。</p>
<h2 id="2018年4月3日"><a href="#2018年4月3日" class="headerlink" title="2018年4月3日"></a>2018年4月3日</h2><p>最近在充电，学各种东西，也在新功能开发各种库。</p>
<h2 id="2018年3月24日"><a href="#2018年3月24日" class="headerlink" title="2018年3月24日"></a>2018年3月24日</h2><p>最近只修了一些Bug。重新搭了一下博客，研究了一会儿自动化脚本。。</p>
<h2 id="2018年3月12日"><a href="#2018年3月12日" class="headerlink" title="2018年3月12日"></a>2018年3月12日</h2><p>正在重构代码库。改一改就要跑一遍测试确保不会大崩坏。不过这Gradle Building + 测试可要了命了，跑一遍测试就等几分钟。。都能摸出鲸鱼了。</p>
<h2 id="2018年3月8日"><a href="#2018年3月8日" class="headerlink" title="2018年3月8日"></a>2018年3月8日</h2><p>昨天发布了0.1.2。内容有步骤颜色、朗读步骤名称、电子表显示。接下来要清理一下代码库为下一步更多自定义功能做准备了。</p>
<p>似乎支持手环需要各个厂商的API，拿不到就支持不了了。</p>
<h2 id="2018年3月3日"><a href="#2018年3月3日" class="headerlink" title="2018年3月3日"></a>2018年3月3日</h2><p>把朗读步骤名称做好了，也做了一些控件。文字转语音还是得用户自己想办法装一个能用的引擎并下载语音数据。</p>
<h2 id="2018年2月25日"><a href="#2018年2月25日" class="headerlink" title="2018年2月25日"></a>2018年2月25日</h2><p>要加朗读步骤名称的行为了。在系统设置里配置好文字转语音（TextToSpeech，TTS）后，用起来还算方便，但国内各系统肯定各有各的阉割。</p>
<h2 id="2018年2月23日"><a href="#2018年2月23日" class="headerlink" title="2018年2月23日"></a>2018年2月23日</h2><p>第二个Beta版本发布，解决了不知道计时器是否已经开始或结束的问题。接下来就要处理棘手的界面问题了。</p>
<h2 id="2018年2月18日"><a href="#2018年2月18日" class="headerlink" title="2018年2月18日"></a>2018年2月18日</h2><p>现阶段主要在研究增强后的步骤选项，有点复杂，焦头烂额。</p>
<h2 id="2018年2月14日"><a href="#2018年2月14日" class="headerlink" title="2018年2月14日"></a>2018年2月14日</h2><p>Beta阶段的任务就很多了。比如增强后的步骤选项（自定义的提醒步骤、只运行一次的启动和结束步骤）、更理想更多的计时器详细页面、朗读步骤名称。。。</p>
<p>最近刚刚重写了选取时间的控件。</p>
<h2 id="2018年2月8日"><a href="#2018年2月8日" class="headerlink" title="2018年2月8日"></a>2018年2月8日</h2><p>可以进入Beta测试了。虽然有很多小细节可以改进，还有几个重要功能需要加入，但核心功能已经基本齐备了。</p>
<h2 id="2018年2月7日"><a href="#2018年2月7日" class="headerlink" title="2018年2月7日"></a>2018年2月7日</h2><p>计时器流水线工作解决的差不多了，但发现计划任务在Android O上失效的问题，应该和最新的后台限制有关，暂时解决不了。Beta阶段试一试第三方Library。</p>
<h2 id="2018年2月5日"><a href="#2018年2月5日" class="headerlink" title="2018年2月5日"></a>2018年2月5日</h2><p>发现现有的计时器的流水线工作存在一些小Bug，比如不停地暂停、+1分钟、前进、后退……就有可能把计数器玩儿坏。我得专门再次重构一下这块，年前发布不了不过年。</p>
<h2 id="2018年2月4日"><a href="#2018年2月4日" class="headerlink" title="2018年2月4日"></a>2018年2月4日</h2><p>试着向下兼容KitKat，但会出现multiDex与lifecycle无法兼容导致崩溃的迷之Bug。或许在使用Proguard后可以继续在KitKat上使用，但Debug起来就很费事。找不到解决方案前可能无法支持Android 4.4了。</p>
<h2 id="2018年2月2日"><a href="#2018年2月2日" class="headerlink" title="2018年2月2日"></a>2018年2月2日</h2><p>增加了夜间主题和介绍页。</p>
<h2 id="2018年1月27日"><a href="#2018年1月27日" class="headerlink" title="2018年1月27日"></a>2018年1月27日</h2><p>0.0.5修复了无法正常保存的问题</p>
<h2 id="2018年1月26日"><a href="#2018年1月26日" class="headerlink" title="2018年1月26日"></a>2018年1月26日</h2><p>想解决一个问题：在通知栏右侧显示一个类似于系统闹钟的小图标，提示未来有计划任务。研究了一下，那个小图标似乎是全系统的唯一且共享的。这意味着，如果手机上既有闹钟也有计划任务，两个就重叠了，只能看到一个，其实这也起不到原先的目的了。那就先不加入这个功能了，给系统让路。</p>
<h2 id="2018年1月25日"><a href="#2018年1月25日" class="headerlink" title="2018年1月25日"></a>2018年1月25日</h2><ol>
<li>发现计划任务的重复设置可能有些Bug，一次性的似乎没问题。</li>
<li>发布了0.0.4。更新有：临时为计时器增加一分钟；钦定的紫蓝主题色；增加帮助和相关页面；修复了计划任务的Bug。</li>
<li>在加入一些小功能、跑一些测试、确保程序正常运行后，就可以进入Beta测试了。</li>
</ol>
<h2 id="2018年1月24日"><a href="#2018年1月24日" class="headerlink" title="2018年1月24日"></a>2018年1月24日</h2><p>增加了帮助与反馈。</p>
<p>在考虑需不需要增加一个单独的计时器启动和结束步骤。不然计时器启动或结束了都不知道。加入的话，需要加一个步骤还是多个步骤，是使用专门的Field保存，还是整合到已有的Steps中？</p>
<h2 id="2018年1月22日"><a href="#2018年1月22日" class="headerlink" title="2018年1月22日"></a>2018年1月22日</h2><ol>
<li>在支持多主题（皮肤）的过程中遇到诸多困难，放弃了。可能会在加入夜间模式，但自定义颜色的设置可能要放在很久以后了。</li>
<li>研究了一下其他应用的多主题原理。Todoist使用预定颜色，通过recreate() Activity实现。Telegram似乎是吧所有用到的Paint, Drawable等等都罗列在一个三千行的Theme类中，通过直接修改颜色来实现（看呆了)。都不是很理想的方法，最后可能使用前者。</li>
<li>先给计时机器钦定了紫蓝的主题色。</li>
</ol>
<h2 id="2018年1月14日"><a href="#2018年1月14日" class="headerlink" title="2018年1月14日"></a>2018年1月14日</h2><p>0.0.3发布。现在可以新建计划任务了：按预定时间开启或关闭一个计时器，一次性的或者按星期几重复。</p>
<p>安装新版本前要写手动卸载旧版本（既然是Alpha测试，数据库结构改动就随心所欲放飞自我了）。</p>
<h2 id="2018年1月12日"><a href="#2018年1月12日" class="headerlink" title="2018年1月12日"></a>2018年1月12日</h2><p>初步完成了计划任务的功能。可以像定闹钟一样设置，什么时候开启或停止一个计时器。</p>
<p>理想情况下，这是可以按预期工作的。但Android系统上，所有跟闹钟搭上边的应用都面临一个无法按时触发的问题。</p>
<p>一方面，系统为了优化电池性能而优化（推迟）闹钟触发时间。这一点可以调用在Android 6.0及以后的setExactWhileIde（似乎叫这个）来最大程度绕过，但4.4-5.1只有setExact，4.3及以前只有set了。效果当然是依次递减了。</p>
<p>另一方面，也是最担心也最没办法的。国内各厂商自定义的各个系统，为了应对国内众多流氓应用，会在清理应用后台时，把我设定的计划任务的闹钟也给清理掉，结果自然是没法触发。如果用户清理了最近使用的应用话，这个情况就会发生。</p>
<p>补充：Android O的后台限制也会极大影响能否触发。</p>
<h2 id="2018年1月10日"><a href="#2018年1月10日" class="headerlink" title="2018年1月10日"></a>2018年1月10日</h2><p>Alpha 0.0.2更新了，主要加入了一些无法打开的正常开发的功能选项，也修复了很多计时器方面的问题。别的不能保证，但不删除旧版就直接安装，肯定崩溃。</p>
<h2 id="2018年1月9日"><a href="#2018年1月9日" class="headerlink" title="2018年1月9日"></a>2018年1月9日</h2><ol>
<li><p>决定暂时停止对Android 5.0(API Level 21)以下的支持，兼容老版本过于浪费精力和时间。在正式版发布后再考虑兼容老版本的问题。</p>
</li>
<li><p>真是谜一般的Bug，在8.1上使用Ringtone就播放无声音，非得使用MediaPlayer才可以。</p>
</li>
</ol>
<h2 id="2018年1月4日"><a href="#2018年1月4日" class="headerlink" title="2018年1月4日"></a>2018年1月4日</h2><p>计时器的定时开启和关闭和闹钟的设置差不多，但由于国内各厂商的设置，设置的这些闹钟不一定能唤醒。</p>
<h2 id="2017年12月29日"><a href="#2017年12月29日" class="headerlink" title="2017年12月29日"></a>2017年12月29日</h2><p>由于疏忽，导致当前的测试版本在Android O(8.0, API Level 26)及以上无法创建Notification Channel，也就是会无法通知渠道。下个版本修复。</p>
<h2 id="2017年12月26日"><a href="#2017年12月26日" class="headerlink" title="2017年12月26日"></a>2017年12月26日</h2><p>计划在正式版发布前加入定时启动和停止的功能。多计时器的查看功能整合在计时器列表中。</p>
<h2 id="2017年12月18日"><a href="#2017年12月18日" class="headerlink" title="2017年12月18日"></a>2017年12月18日</h2><ol>
<li><p>最担心的事情发生了，Foreground Service无法准时唤醒手机，又得找黑科技解决。FML</p>
</li>
<li><p>似乎用WakeLock解决了，这意味了必须用ForegroundService + WakeLock == 一直保持CPU唤醒状态 == 消耗更多的电量。</p>
</li>
<li><p>不过我为什么不设计一个结合两个应用优点的应用呢，既可以使用AlarmManager省电但稍有不准，也可以使用ForegroundService + WakeLock<br>耗电但准时提醒？当然是能力不够啦。或许TimerMachine做的差不多后，可以在考虑添加AlramManager的实现方式。</p>
</li>
</ol>
<h2 id="2017年12月14日"><a href="#2017年12月14日" class="headerlink" title="2017年12月14日"></a>2017年12月14日</h2><table>
<thead>
<tr>
<th align="center">应用比较</th>
<th align="center">Cycle Timer</th>
<th align="center">Timer Machine</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现原理</td>
<td align="center">系统闹钟(AlarmManager.setExact…)</td>
<td align="center">前台服务(Foreground Service)</td>
</tr>
<tr>
<td align="center">准确度</td>
<td align="center">少数特定手机、少数特定情况可能失效</td>
<td align="center">非常准确</td>
</tr>
<tr>
<td align="center">可能的失效原因</td>
<td align="center">权限、系统限制一定时间内的唤醒次数</td>
<td align="center">权限、内存及其不够时服务被杀</td>
</tr>
<tr>
<td align="center">可自定义内容</td>
<td align="center">名称、循环、节点及其名称、是否振动、提醒音乐</td>
<td align="center">名称、循环、每个节点的名称音乐振动唤醒屏幕</td>
</tr>
<tr>
<td align="center">耗电</td>
<td align="center">系统分配唤醒时间，影响小</td>
<td align="center">需保持计时器一直运行，影响大</td>
</tr>
<tr>
<td align="center">生命周期</td>
<td align="center">维护尾声</td>
<td align="center">正在开发</td>
</tr>
</tbody></table>
<h2 id="2017年12月11日"><a href="#2017年12月11日" class="headerlink" title="2017年12月11日"></a>2017年12月11日</h2><p>提醒方式将会有音乐、振动、弹出屏幕、朗读节点名称。各自的自定义会陆续加入。</p>
<h2 id="2017年12月10日"><a href="#2017年12月10日" class="headerlink" title="2017年12月10日"></a>2017年12月10日</h2><p>循环计时器+计时机器的开发日志。</p>
<p>之所以打算放弃维护循环计时器，重新开发新的计时机器，是因为前者是第一个正式上架的应用，用的还是MVC，代码库很乱，数据库储存格式更乱，</p>
<p>考虑到更多新功能的加入，决定写一个技术更前卫，使用更灵活的计时器。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
